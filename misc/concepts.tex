% Natural Language Toolkit Miscellaneous Report:
% Catalog of Concepts and Datatypes
%
% Copyright (C) 2001 University of Pennsylvania
% Author: Edward Loper <edloper@gradient.cis.upenn.edu>
% URL: <http://nltk.sf.net>
% For license information, see LICENSE.TXT
%
% $Id$

\documentclass{article}
\usepackage{fullpage}


\begin{document}
\title{Notes on the NL Toolkit}
\author{Edward Loper}
\maketitle

This document catalogs some of the different conceptual entities which
the tooklit should deal with.  These conceptual entities sometimes
draw more distinctions than is convenient when actually working with
objects.  

An open question is how strict the toolkit should be about enforcing
the distinctions between conceptually distinct types of entities.  On
one hand, strictly enforcing these distinctions is conceptually
``simpler,'' and may promote clearer thinking.  On the other hand, it
is often cumbersome to make these distinctions -- in many
circumstances, they don't matter, so they get dropped in practice.
For example, most people will not distinguish ``tokens'' from ``token
types'' unless they need to.  In a sense, this question boils down to
whether it will be easier to learn/use a set of rules/conventions that
are simpler, but somewhat less intuitive; or more complex, but more
intuitive.  I think that one danger is that the more complex rules
will only be more intuitive some of the time.  And it may be dangerous
to be inconsistantly intuitive..

Another open question is whether the current names should be kept.  In
particular, names of conceptual entities should be both \emph{correct}
and \emph{easy to use/remember}.

Also, it may be possible that some of these conceptual entities could
be merged or done away with altogther.  Are all of these entities
serving useful purposes?



\section{Token Stuff}

{\it (Currently, many of these definitions
are a bit hand-wavey.  That partially stems from the fact that they
are not really as well-defined as we would like (esp the more
primitive ones).  But I'll try to clean them up eventually.)}

\begin{itemize}

  \item \textbf{Lexeme:} An identifier for a word-like thing.
  Normally, this would be a string.  But if you wanted to process text
  more efficiently, it could be an integer.  It might be stemmed, not
  stemmed, case-normalized, not case-normalized, etc.
 
  \item \textbf{Token Type:} A word-like unit of text.  Includes a
  lexeme, and may also include other info, like part of speech tag,
  etc.

  \item \textbf{Token:} An occurance of a token type

  \item \textbf{Location:} The location of something in text.  There
  are actually a number of ways of representing locations: as indexes,
  as spans, etc.  Also, indexes can refer to word number, character
  number, etc.

\end{itemize}

\section{Syntax Tree Stuff}

\begin{itemize}

  \item \textbf{SyntaxNode:} The annotation that appears at a node
  in a syntax tree.  E.g., this might hold a phrase type (``NP'' or
  ``V'').

  \item \textbf{SyntaxTree:} An occurance of a tree or subtree.
  Consists of a SyntaxNode and an ordered list of zero or more
  children.  Children must be SyntaxTrees or Tokens.

  \item \textbf{SyntaxTreeType:} The ``type'' of a syntax tree (as
  opposed to an occurance of a syntax tree).  Consists of a SyntaxNode
  and an ordered list of zero or more children.  Children must be
  SyntaxTreeTypes or TokenTypes.

\end{itemize}

\section{How much to enforce?}

So basically, the question of deciding how strictly to enforce these
distinctions comes down to two questions:

\begin{enumerate}
  \item Should any entities/distinctions be eliminated?
  \item Should it be possible to use entities in environments that
        are not \emph{strictly speaking} correct?
\end{enumerate}

I'll leave the first question for later, and concentrate on the
second.  There are a number of ways that objects could try to be more
friendly when you use them in ways that that are not strictly speaking
correct:

\begin{itemize}
  \item Equality tests: What happens when you compare a string to a
  token?  A string to a TokenType?  A Token to a TokenType?  etc.?  A
  related question is how to handle comparisons within one class
  hierarchy.  E.g., equality tests between a tagged token and a simple
  token.  The strict view would say that any of these comparisons
  should raise an exception.  However, if we decide not to be strict,
  there are a number of places where these equality tests could be
  well-defined.  Examples that come to mind are:
  \begin{itemize}
    \item equality between a string and a SimpleTokenType
    \item equality between a string and a Token (ignore location)
    \item equality between an integer and a Location
    \item equality between a list and a SyntaxTree(Type)
  \end{itemize}

  \item Arguments to methods: Should methods attempt to handle
  arguments that are not quite the expected type?  E.g., when Steven
  passed strings to a FreqDist, when it was really (sort of) expecting
  TokenTypes.

  \item Arguments to constructors: Should constructors automatically
  ``wrap'' objects if they're not the right type?  E.g., should
  Token(``cat'') automatically create a SimpleTokenType containing
  ``cat''?
\end{itemize}

\section{Printing}

One thing that guides peoples intuitions about what an object is is
how it looks when it prints.  If two things look the same when you
print them, then intuitively they should be the same.  I think this
may have been a source of confusion in the first problem set, where
TokenTypes look just like strings when you print them, so users will
be tempted to do things like use ``=='' to test whether a TokenType
is equal to a string.

\newpage
\section{Implementation details}

\begin{itemize}
  \item \textbf{Lexeme}: normally an internal Python type, like string
  or int.

  \item \textbf{Token Type}: a class with TokenTypeI as a base.

  \item \textbf{Token}: the class Token

  \item \textbf{Location}: a class with LocationI as a base.

  \item \textbf{SyntaxNode}: a class with SyntaxNodeI as a base.

  \item \textbf{SyntaxTree}: the class SyntaxTree

  \item \textbf{SyntaxTreeType}: the class SyntaxTreeType

\end{itemize}

\noindent
Accessing the lexeme of a token:\\
\begin{tabular}{|l|ccccc|}
\hline
Code    &my\_token&. & type()&. & lexeme() \\
\hline
Entity  &Token && Token Type && Lexeme \\
Type    &\tt Token && \tt TokenTypeI && \tt string \\
\hline
\end{tabular}

\vspace{2mm}\noindent
Accessing the location of a token:\\
\begin{tabular}{|l|ccccc|}
\hline
Code    &my\_token&. & source()&. & index() \\
\hline
Entity  &Token && Location && Index \\
Type    &\tt Token && \tt LocationI && \tt int \\
\hline
\end{tabular}\\
(should that be .loc() instead of .source()?)

\vspace{2mm}\noindent
Accessing the tag of a syntax tree:\\
\begin{tabular}{|l|ccccc|}
\hline
Code    &my\_stree&. & node()&. & tag() \\
\hline
Entity  &SyntaxTree && SyntaxNode && Tag \\
Type    &\tt SyntaxTree && \tt SyntaxNodeI && \tt string \\
\hline
\end{tabular}

\vspace{2mm}\noindent
Accessing the children of a syntax tree:\\
\begin{tabular}{|l|cc|}
\hline
Code    &my\_stree& [2] \\
\hline
Entity  &SyntaxTree & SyntaxTree or Token \\
Type    &\tt SyntaxTree & {\tt SyntaxTree} or {\tt Token}\\
\hline
\end{tabular}

\end{document}
