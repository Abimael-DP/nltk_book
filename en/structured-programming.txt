.. -*- mode: rst -*-
.. include:: ../definitions.txt
.. include:: regexp-defns.txt
.. sectnum::

===================================
6. Structured Programming in Python
===================================

------------
Introduction
------------

In this chapter we pick up where we left off in |Programming|.
We review key concepts in programming and introduce new topics
in structured programming, functional decomposition,
algorithmic problem solving, ...
The chapter contains many working program fragments and exercises
which you should try yourself.

---------
Sequences
---------

.. range(n)

* review
* copy vs deepcopy
* iterators
* generators


List Comprehensions
-------------------

Many language processing tasks involve applying the same operation to
every item in a list.  `List comprehensions`:dt: are a convenient Python
construct for doing this.  Here we lowercase each word:

    >>> sent = ['The', 'dog', 'gave', 'John', 'the', 'newspaper']
    >>> [word.lower() for word in sent]
    ['the', 'dog', 'gave', 'john', 'the', 'newspaper']

As another example, we could remove all determiners from a list of
words:

    >>> def is_lexical(word):
    ...     return word.lower() not in ('a', 'an', 'the', 'that', 'to')
    >>> [word for word in sent if is_lexical(word)]
    ['dog', 'gave', 'John', 'newspaper']

Or equivalently:

    >>> filter(is_lexical, sent)
    ['dog', 'gave', 'John', 'newspaper']

Combining the transformations...

    >>> [word.lower() for word in sent if is_lexical(word)]
    ['dog', 'gave', 'john', 'newspaper']


.. Another example: stemming each word:
..   >>> from nltk_lite import stem
..   >>> stemmer = stem.Regexp('ing$|s$|e$')

The following code builds a list of tuples, where each tuple consists
of a word and its length.

    >>> [(x, len(x)) for x in sent]
    [('The', 3), ('dog', 3), ('gave', 4), ('John', 4), ('the', 3), ('newspaper', 9)]

We can build a list of n-grams as follows:

    >>> n = 3
    >>> [sent[i:i+n] for i in range(len(sent)-n+1)]
    [['The', 'dog', 'gave'],
     ['dog', 'gave', 'John'],
     ['gave', 'John', 'the'],
     ['John', 'the', 'newspaper']]


Iterators
---------

Generating all permutations of words, to check which ones are
grammatical (broken):

    >>> def permute(words, level):
    ...     if level == 1:
    ...         yield words
    ...     else:
    ...         for i in range(level):
    ...             permute(words, level-1)
    ...             if level % 2 == 1:
    ...                 words[0], words[level-1] = words[level-1], words[0]
    ...             else:
    ...                 words[i], words[level-1] = words[level-1], words[i]
    ...
    >>> list(permute([1,2,3], 3))


Formatted Strings
-----------------

Formatted output typically contains a combination of variables and
pre-specified strings, e.g. given a dictionary ``wordcount``
consisting of words and their frequencies we could do:

    >>> wordcount = {'cat':3, 'dog':4, 'snake':1}
    >>> for word in wordcount:
    ...     print word, "->", wordcount[word], ";",
    dog -> 4 ; cat -> 3 ; snake -> 1

Apart from the problem of unwanted whitespace, such print statements
alternating variables and constants can be difficult to read and
maintain.  Instead:

    >>> for word in wordcount:
    ...    print "%s->%d;" % (word, wordcount[word]),
    dog->4; cat->3; snake->1
    
**Tabulation:**

Now that we can load a significant quantity of tagged text, we can
process it and extract items of interest.  The following code iterates
over the fifteen genres of the Brown Corpus (accessed using
``brown.items()``).  Each of these is tokenized in turn.  The next
step is to check if the token has the ``md`` tag.  For each of these
words we increment a count.  This uses the conditional frequency
distribution, where the condition is the current genre, and the event
is the modal.

    >>> cfdist = ConditionalFreqDist()
    >>> for genre in brown.items:                  # each genre
    ...     for sent in brown.tagged(genre):       # each sentence
    ...         for (word,tag) in sent:            # each tagged token
    ...             if tag == 'md':                # found a modal
    ...                  cfdist[genre].inc(word.lower())

The conditional frequency distribution is nothing more than a mapping
from each genre to the distribution of modals in that genre.  The
following code fragment identifies a small set of modals of interest,
and processes the data structure to output the required counts.

    >>> modals = ['can', 'could', 'may', 'might', 'must', 'will']
    >>> print "%-18s" % 'Genre', ' '.join([("%6s" % m) for m in modals])
    Genre                 can  could    may  might   must   will
    >>> for genre in cfdist.conditions():    # generate rows
    ...     print "%-18s" % brown.item_name[genre],
    ...     for modal in modals:
    ...         print "%6d" % cfdist[genre].count(modal),
    ...     print
    press: reportage       94     86     66     36     50    387
    press: reviews         44     40     45     26     18     56
    press: editorial      122     56     74     37     53    225
    skill and hobbies     273     59    130     22     83    259
    religion               84     59     79     12     54     64
    belles-lettres        249    216    213    113    169    222
    popular lore          168    142    165     45     95    163
    miscellaneous: gov    115     37    152     13     99    237
    fiction: general       39    168      8     42     55     50
    learned               366    159    325    126    202    330
    fiction: science       16     49      4     12      8     16
    fiction: mystery       44    145     13     57     31     17
    fiction: adventure     48    154      6     58     27     48
    fiction: romance       79    195     11     51     46     43
    humor                  17     33      8      8      9     13

There are some interesting patterns in this table.  For instance,
compare the rows for government literature and adventure literature;
the former is dominated by the use of ``can, may, must, will`` while
the latter is characterised by the use of ``could`` and ``might``.
With some further work it might be possible to guess the genre of a
new text automatically, according to its distribution of modals.

**Example: concordance display**

Issues: handling padding, escaping ``%`` in formatting strings, alignment

    >>> context = 30
    >>> word = "line"
    >>> format = "%%%ds %s %%-%ds" % (context, word, context)
    >>> for sent in brown.raw('a'):
    ...     try:
    ...         pos = sent.index(word)
    ...         left = ' '.join(sent[:pos])
    ...         right = ' '.join(sent[pos+1:])
    ...         print format % (left[-context:], right[:context])
    ...     except ValueError:
    ...         pass
     , is today closer to the NATO line .                             
    more activity across the state line in Massachusetts than in Rhode
     gained five yards through the line and then uncorked a 56-yard to
                   `` Our interior line and out linebackers played exc
    then moved Cooke across with a line drive to left . Jay Porter dre
    al doubled down the rightfield line and Cooke singled off Phil Sha
    1 -- ( AP ) -- Billy Gardner's line double , which just eluded the
     Jan. 23 -- Nick Skorich , the line coach for the football champio
     general manager . Maris is in line for a big raise .             
    d be impossible to work on the line until then because of the larg
           Murray makes a complete line of ginning equipment except fo
      The company sells a complete line of gin machinery all over the 
    er Co. of Sherman makes a full line of gin machinery and equipment
    ed E. Perlman said Tuesday his line would face the threat of bankr
    ale of property disposed of in line with a plan of liquidation . L
    ittle effort spice up any chow line .                             
     , filed through the cafeteria line .                             
    be particularly sensitive to a line between first and second class
    skilled worker on the assembly line , for example , earns $37 a we


---------
Functions
---------

* call by reference vs call by name
* keyword arguments
* return
* function pointers
* schwartzian transform



Predicting the Next Word (Revisited)
------------------------------------


    >>> from nltk_lite.corpora import genesis
    >>> from nltk_lite.probability import ConditionalFreqDist
    >>> cfdist = ConditionalFreqDist()

We then examine each token in the corpus, and increment the
appropriate sample's count.  We use the variable ``prev`` to record
the previous word.

    >>> prev = None
    >>> for word in genesis.raw():
    ...     cfdist[prev].inc(word)
    ...     prev = word

.. Note:: Sometimes the context for an experiment is unavailable, or
   does not exist.  For example, the first token in a text does not
   follow any word.  In these cases, we must decide what context to
   use.  For this example, we use ``None`` as the context for the
   first token.  Another option would be to discard the first token.

Once we have constructed a conditional frequency distribution for the
training corpus, we can use it to find the most likely word for any
given context. For example, taking the word `living`:lx: as our context,
we can inspect all the words that occurred in that context.

    >>> word = 'living'
    >>> cfdist[word].samples()
    ['creature,', 'substance', 'soul.', 'thing', 'thing,', 'creature']

We can set up a simple loop to generate text: we set an initial
context, picking the most likely token in that context as our next
word, and then using that word as our new context:

    >>> word = 'living'
    >>> for i in range(20):
    ...     print word,
    ...     word = cfdist[word].max()
    living creature that he said, I will not be a wife of the land
    of the land of the land



NOW: doing this with functions...

Recursive Functions
-------------------

Iterative solution:

    >>> def factorial(n):
    ...     result = 1
    ...     for i in range(n+1):
    ...         result *= i
    ...     return result

Recursive solution (base case, induction step)

    >>> def factorial(n):
    ...     if n == 1:
    ...         return n
    ...     else:
    ...         return n * factorial(n-1)




Functional Decomposition
------------------------

Well-structured programs often make extensive use of functions.  Often
when a block of program code grows longer than a screenful, it is a
great help to readability if it is decomposed into one or more
functions.



-----
Trees
-----

In this part of the book we will be investigating the constituent
structure of sentences, and we will see how these can be represented
using syntactic trees.  Here we will look at tree structures in NLTK.

A tree is a set of connected nodes, each of which is labeled with a
category.  It common to use a 'family' metaphor to talk about the
relationships of nodes in a tree: for example, `S`:gc: is the
`parent`:dt: of `VP`:gc:; conversely `VP`:gc: is a `daughter`:dt: (or
`child`:dt:) of `S`:gc:.  Also, since `NP`:gc: and `VP`:gc: are both
daughters of `S`:gc:, they are also `sisters`:dt:. 
Here is an example of a tree:

.. ex::
  .. tree:: (S (NP Lee) (VP (V saw) (NP the dog)))

Although it is helpful to represent trees in a graphical format, for
computational purposes we usually need a more text-oriented
representation. One standard method is to use a combination of bracket
and labels to indicate the structure, as shown here:

.. doctest-ignore::
      (S 
         (NP  'Lee')
         (VP 
            (V 'saw')
            (NP 
               (Det 'the')
               (N  'dog'))))

The conventions for displaying trees in NLTK are similar:

.. doctest-ignore::
      (S: (NP: 'Lee') (VP: (V: 'saw') (NP: 'the' 'dog')))

In such trees, the node value is a string containing the tree's
constituent type (e.g., `NP`:gc: or `VP`:gc:), while the children encode
the hierarchical contents of the tree [#]_.

.. [#] Although the ``Tree`` class is usually used for encoding
   syntax trees, it can be used to encode *any* homogeneous hierarchical
   structure that spans a text (such as morphological structure or
   discourse structure).  In the general case, leaves and node values do
   not have to be strings.

Trees are created with the ``Tree`` constructor, which takes a
node value and a list of zero or more children.  Here's an example of
a simple NLTK tree with a single child node, where the latter is a token:

    >>> from nltk_lite.parse.tree import Tree
    >>> tree1 = Tree('NP', ['John'])
    >>> print tree1
    (NP: 'John')

Here is an example with two children:

    >>> tree2 = Tree('NP', ['the', 'man'])
    >>> print tree2
    (NP: 'the' 'man')

Finally, here is a more complex example, where one of the
children is itself a tree:

    >>> tree3 = Tree('VP', ['saw', tree2])
    >>> print tree3
    (VP: 'saw' (NP: 'the' 'man'))

A tree's root node value is accessed with the ``node`` property, and
its leaves are accessed with the ``leaves()`` method:

    >>> tree3.node
    'VP'
    >>> tree3.leaves()
    ['saw', 'the', 'man']

One common way of defining the subject of a sentence `S`:gc: in
English is as *the noun phrase that is the daughter of* `S`:gc: *and
the sister of* `VP`:gc:. Although we cannot access subjects directly,
in practice we can get something similar by using `tree
positions`:dt:. Consider ``tree4`` defined as follows:

    >>> tree4 = Tree('S', [tree1, tree3])
    >>> print tree4
    (S: (NP: 'John') (VP: 'saw' (NP: 'the' 'man')))

Now we can just use indexing to access the subtrees of this tree:

    >>> tree4[0]
    (NP: 'John')
    >>> tree4[1]
    (VP: 'saw' (NP: 'the' 'man'))

Since the value of ``tree4[1]`` is itself a tree, we can index into that as well:

    >>> tree4[1][0]
    'saw'
    >>> tree4[1][1]
    (NP: 'the' 'man')

The printed representation for complex trees can be difficult to read.
In these cases, the ``draw`` method can be very useful. 

.. doctest-ignore::
    >>> tree3.draw()

This method opens a new window, containing a graphical representation
of the tree:

.. image:: ../images/parse_draw.png
   :scale: 70

The tree display window allows you to zoom in and out;
to collapse and expand subtrees; and to print the graphical
representation to a postscript file (for inclusion in a document).

To compare multiple trees in a single window, we can use the
``draw_trees()`` method:

.. doctest-ignore::
    >>> from nltk_lite.draw.tree import draw_trees
    >>> draw_trees(tree1, tree2, tree3)

The ``Tree`` class implements a number of other useful methods.  See
the ``Tree`` reference documentation for more information about these
methods.

The ``nltk_lite.corpora`` module defines the ``treebank`` corpus,
which contains a collection of hand-annotated parse trees for English
text, derived from the Penn Treebank.

    >>> from nltk_lite.corpora import treebank, extract
    >>> print extract(0, treebank.parsed())
    (S:
      (NP-SBJ:
        (NP: (NNP: 'Pierre') (NNP: 'Vinken'))
        (,: ',')
        (ADJP: (NP: (CD: '61') (NNS: 'years')) (JJ: 'old'))
        (,: ','))
      (VP:
        (MD: 'will')
        (VP:
          (VB: 'join')
          (NP: (DT: 'the') (NN: 'board'))
          (PP-CLR:
            (IN: 'as')
            (NP: (DT: 'a') (JJ: 'nonexecutive') (NN: 'director')))
          (NP-TMP: (NNP: 'Nov.') (CD: '29'))))
      (.: '.'))


Recursion on Trees
------------------

1. recurse over tree to display in some useful way (e.g. whitespace formatting)

2. recurse over tree to look for coordinate constructions (cf 4th
   example in chapter 1.1)

3. generate new dependency tree from a phrase-structure tree

(possible extension: callback function for Tree.subtrees())


XML and ElementTree
-------------------

* inspecting and processing XML
* example: find nodes matching some criterion and add an attribute


------------
Dictionaries
------------

* persistent storage
* dictionary keys and immutability

-------------------
Program Development
-------------------

Programming is a skill which is acquired over several years of
experience with a variety of programming languages and tasks.  Key
high-level abilities are *algorithm design* and its manifestation in
*structured programming*.  Key low-level abilities include familiarity
with the syntactic constructs of the language, and knowledge of a
variety of diagnostic methods for trouble-shooting a program which
does not exhibit the expected behaviour.

Programming Style
-----------------

We have just seen how the same task can be performed in different
ways, with implications for efficiency.  Another factor influencing
program development is *programming style*.  Consider the following
program to compute the average length of words in the Brown Corpus:

    >>> from nltk_lite.corpora import brown
    >>> count = 0
    >>> total = 0
    >>> for sent in brown.raw('a'):
    ...     for token in sent:
    ...         count += 1
    ...         total += len(token)
    >>> print float(total) / count
    4.2765382469

In this program we use the variable ``count`` to keep track of the
number of tokens seen, and ``total`` to store the combined length of
all words.  This is a low-level style, not far removed from machine
code, the primitive operations performed by the computer's CPU.
The two variables are just like a CPU's registers, accumulating values
at many intermediate stages, values which are almost meaningless. 
We say that this program is written in a *procedural* style, dictating
the machine operations step by step.  Now consider the following
program which computes the same thing:

    >>> tokens = [token for sent in brown.raw('a') for token in sent]
    >>> total = sum(map(len, tokens))
    >>> print float(total)/len(tokens)
    4.2765382469

The first line uses a list comprehension to construct the sequence of
tokens.  The second line *maps* the ``len`` function to this sequence,
to create a list of length values, which are summed.  The third line
computes the average as before.  Notice here that each line of code
performs a complete, meaningful action.  Moreover, they do not dictate
how the computer will perform the computations; we state high level
relationships like "``total`` is the sum of the lengths of the tokens"
and leave the details to the Python interpreter.  Accordingly, we say
that this program is written in a *declarative* style.

Here is another example to illustrate the procedural/declarative
distinction.  Notice again that the procedural version
involves low-level steps and a variable having meaningless
intermediate values:

    >>> word_list = []
    >>> for sent in brown.raw('a'):
    ...     for token in sent:
    ...         if token not in word_list:
    ...             word_list.append(token)
    >>> word_list.sort()

The declarative version (given second) makes use of higher-level
built-in functions:

    >>> tokens = [word for sent in brown.raw('a') for word in sent]
    >>> word_list = list(set(tokens))
    >>> word_list.sort()

What do these programs compute?  Which version did you find easier to interpret?

Consider one further example, which sorts three-letter words by their
final letters.  The words come from the widely-used Unix word-list,
made available as an NLTK corpus called ``words``.  Two words ending
with the same letter will be sorted according to their second-last
letters.  The result of this sort method is that many rhyming words will be
contiguous.  Two programs are given; Which one is more declarative,
and which is more procedural?

As an aside, for readability we define a function for reversing
strings that will be used by both programs:

    >>> def reverse(word):
    ...     return word[::-1]

Here's the first program.  We define a helper function ``reverse_cmp``
which calls the built-in ``cmp`` comparison function on reversed
strings.  The ``cmp`` function returns ``-1``, ``0``, or ``1``,
depending on whether its first argument is less than, equal to, or
greater than its second argument.  We tell the list sort function to
use ``reverse_cmp`` instead of ``cmp`` (the default).

    >>> from nltk_lite.corpora import words
    >>> def reverse_cmp(x,y):
    ...     return cmp(reverse(x), reverse(y))
    >>> word_list = [word for word in words.raw('en') if len(word) == 3]
    >>> word_list.sort(reverse_cmp)
    >>> print word_list[-12:]
    ['toy', 'spy', 'cry', 'dry', 'fry', 'pry', 'try', 'buy', 'guy', 'ivy', 'Paz', 'Liz']

Here's the second program.  In the first loop it collects up all the
three-letter words in reversed form.  Next, it sorts the list of
reversed words.  Then, in the second loop, it iterates over each
position in the list using the variable ``i``, and replaces each item
with its reverse.  We have now re-reversed the words, and can print
them out.

    >>> word_list = []
    >>> for word in words.raw('en'):
    ...     if len(word) == 3:
    ...         word_list.append(reverse(word))
    >>> word_list.sort()
    >>> for i in range(len(word_list)):
    ...     word_list[i] = reverse(word_list[i])
    >>> print word_list[-12:]
    ['toy', 'spy', 'cry', 'dry', 'fry', 'pry', 'try', 'buy', 'guy', 'ivy', 'Paz', 'Liz']

Choosing between procedural and declarative styles is just that, a
question of style.  There are no hard boundaries, and it is possible
to mix the two.  Readers new to programming are encouraged to
experiment with both styles, and to make the extra effort required to
master higher-level constructs, such as list comprehensions, and
built-in functions like ``map`` and ``filter``.

Debugging
---------

    >>> import pdb
    >>> import mymodule
    >>> pdb.run('mymodule.test()')


Commands:

list [first [,last]]: list sourcecode for the current file

next: continue execution until the next line in the current function is reached

cont: continue execution until a breakpoint is reached (or the end of the program)

break: list the breakpoints

break n: insert a breakpoint at this line number in the current file

break file.py:n: insert a breakpoint at this line in the specified file

break function: insert a breakpoint at the first executable line of the function



Exercises
---------

1. Write a program to sort words by length.  Define a helper function
   ``cmp_len`` which uses the ``cmp`` comparison function on word
   lengths.

2. Consider the tokenized sentence
   ``['The', 'dog', 'gave', 'John', 'the', 'newspaper']``.
   Using the ``map()`` and ``len()`` functions, write a single line
   program to convert this list of tokens into a list of token
   lengths: ``[3, 3, 4, 4, 3, 9]``

-------------------------
Writing Complete Programs
-------------------------

Classifying Words Automatically
-------------------------------

A tagged corpus can be used to *train* a simple classifier, which can
then be used to guess the tag for untagged words.  For each word, we
can count the number of times it is tagged with each tag.  For
instance, the word ``deal`` is tagged 89 times as ``nn`` and 41 times
as ``vb``.  On this evidence, if we were asked to guess the tag for
``deal`` we would choose ``nn``, and we would be right over two-thirds
of the time.  The following program performs this tagging task, when
trained on the "g" section of the Brown Corpus (so-called *belles
lettres*, creative writing valued for its aesthetic content).

    >>> from nltk_lite.corpora import brown
    >>> cfdist = ConditionalFreqDist()
    >>> for sentence in brown.tagged('g'):
    ...     for token in sentence:
    ...         word = token[0]
    ...         tag = token[1]
    ...         cfdist[word].inc(tag)
    >>> for word in "John saw 3 polar bears".split():
    ...     print word, cfdist[word].max()
    John np
    saw vbd
    3 cd-tl
    polar jj
    bears vbz
    
Note that ``bears`` was incorrectly tagged as the 3rd person singular
form of a verb, since this word appears more frequently as a verb than
a noun in esthetic writing.

A problem with this approach is that it creates a huge model, with an
entry for every possible combination of word and tag.  For certain
tasks it is possible to construct reasonably good models which are
tiny in comparison.  For instance, let's try to guess whether a verb
is a noun or adjective from the last letter of the word alone.  We can
do this as follows:

    >>> tokens = []
    >>> for sent in brown.tagged('g'):
    ...     for (word,tag) in sent:
    ...         if tag in ['nn', 'jj'] and len(word) > 3:
    ...             char = word[-1]
    ...             tokens.append((char,tag))
    >>> split = len(tokens)*9/10
    >>> train, test = tokens[:split], tokens[split:]
    >>> cfdist = ConditionalFreqDist()
    >>> for (char,tag) in train:
    ...     cfdist[char].inc(tag)
    >>> correct = total = 0
    >>> for (char,tag) in test:
    ...     if tag == cfdist[char].max():
    ...         correct += 1
    ...     total += 1
    >>> print correct*100/total
    71

This result of 71% is marginally better than the result of 65% that we
get if we assign the ``nn`` tag to every word.  We can inspect the
model to see which tag is assigned to a word given its final letter.
Here we learn that words which end in ``c`` or ``l`` are more likely
to be adjectives than nouns::

    >>> print [(c, cfdist[c].max()) for c in cfdist.conditions()]
    [('%', 'nn'), ("'", None), ('-', 'jj'), ('2', 'nn'), ('5', 'nn'),
     ('A', 'nn'), ('D', 'nn'), ('O', 'nn'), ('S', 'nn'), ('a', 'nn'),
     ('c', 'jj'), ('b', 'nn'), ('e', 'nn'), ('d', 'nn'), ('g', 'nn'),
     ('f', 'nn'), ('i', 'nn'), ('h', 'nn'), ('k', 'nn'), ('m', 'nn'),
     ('l', 'jj'), ('o', 'nn'), ('n', 'nn'), ('p', 'nn'), ('s', 'nn'),
     ('r', 'nn'), ('u', 'nn'), ('t', 'nn'), ('w', 'nn'), ('y', 'nn'),
     ('x', 'nn'), ('z', 'nn')]

Exercises
---------

#. **Classifying words automatically:**
   The program for classifying words as nouns or adjectives scored 71%.
   Try to come up with better conditions, to get the system to score 80% or better.

   a) Revise the condition to use a longer suffix of the word, such as
      the last two characters, or the last three characters.  What happens
      to the performance?  Which suffixes are diagnostic for adjectives?

   #) Explore other conditions, such as variable length prefixes of a
      word, or the length of a word, or the number of vowels in a word.

   #) Finally, combine multiple conditions into a tuple, and explore
      which combination of conditions gives the best result.

#. **Exploring text genres:**
   Investigate the table of modal distributions and look for other patterns.
   Try to explain them in terms of your own impressionistic understanding
   of the different genres.  Can you find other closed classes of words that
   exhibit significant differences across different genres?

---------------
Further Reading
---------------

.. include:: footer.txt
