There are many |NLP| applications where it would be useful to have some
representation of the `meaning`:em: of a natural language
sentence. For instance, current search engine technology
can only take us so far in giving concise and correct answers to many
questions that we might be interested in. Admittedly, Google does a
good job in answering google1a_, since its first hit is google1b_.

.. _google1:
.. ex::

      .. _google1a:
      .. ex:: What is the population of Saudi Arabia?

      .. _google1b:
      .. ex:: Saudi Arabia - Population: 26,417,599

|nopar|
By contrast, the result of sending google2_ to Google is less helpful:

.. _google2:
.. ex:: Which countries border the Mediterranean?

|nopar|
This time, the topmost hit (and the only relevant one in the top ten)
presents the relevant information as a map of the Mediterranean
basin. Since the map is an image file, it is not easy to
extract the required list of countries from the returned page.

Even if Google succeeds in finding documents which contain information
relevant to our question, there is no guarantee that it will be in a
form which can be easily converted into an appropriate answer. One
reason for this is that the information may have to be inferred from more
than one source. This is likely to be the case when we seek an answer
to more complex questions like google3_:

.. _google3:
.. ex:: Which Asian countries border the Mediterranean?

|nopar|
Here, we would probably need to combine the results of two subqueries,
namely google2_ and `Which countries are in Asia?`:lx:.  

The example queries we have just given are based on a paper dating
back to 1982 [Warren1982EEA]_;
this describes a system, *Chat-80*, which converts natural
language questions into a semantic representation, and uses the latter
to retrieve answers from a knowledge base. A knowledge base is usually
taken to be a set of sentences in some formal language; in the case of
Chat-80, it is a set of Prolog clauses. However, we can encode
knowledge in a variety of formats, including relational databases,
various kinds of graph, and first-order models. In |NLTK|, we have
used the third of these options to re-implement a limited version of
Chat-80::

   Sentence: which Asian countries border the_Mediterranean
   ------------------------------
   \x.((contain(asia, x) & country (x)) & border (x, mediterranean)
   set(['turkey', 'syria', 'israel', 'lebanon'])

|nopar| As we will explain later in this chapter, a semantic
representation of the form ``\x.P(x)`` denotes a set of entities
*u* that meet some condition ``P(x)``. We then ask our
knowledge base to enumerate all the entities in this set.

Let's assume more generally that knowledge is available in some
structured fashion, and that it can be interrogated by a suitable
query language. Then the challenge for |NLP| is to find a method for
converting natural language questions into the target query
language. An alternative paradigm for question answering is to take
something like the pages returned by a Google query as our 'knowledge
base' and then to carry out further analysis and processing of the
textual information contained in the returned pages to see whether it does
in fact provide an answer to the question. In either case, it is very
useful to be able to build a semantic representation of questions.
This |NLP| challenge intersects in interesting ways with one of the
key goals of linguistic theory, namely to provide a systematic
correspondence between form and meaning.



While there are numerous subtle and difficult issues about how to
translate natural language constructions into |FOL|, we will largely ignore
these. The main focus of our discussion will be on a
different issue, namely building semantic representations which
conform to some version of the `Principle of Compositionality`:dt:.
(See [Partee1995LSC]_ for this formulation.)

Principle of Compositionality:
   The meaning of a whole is a function of the meanings of the parts
   and of the way they are syntactically combined.