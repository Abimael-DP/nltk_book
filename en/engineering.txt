.. -*- mode: rst -*-
.. include:: ../definitions.txt

.. standard global imports

    >>> import nltk, re, pprint

.. _chap-engineering:

=======================
5. Language Engineering
=======================

------------
Introduction
------------

* grammar engineering, connection to Part II, test suites, regression testing

----------
Evaluation
----------

* basic tasks of segmentation and labeling
* accuracy: why it is not enough for a labeling task

Precision and Recall
--------------------

.. _precision-recall:

.. figure:: ../images/precision-recall.png
   :scale: 70

   True and False Positives and Negatives

Consider Figure precision-recall_.
The intersection of these sets defines four regions: the true
positives (TP), true negatives (TN), false positives (FP), and false
negatives (FN).  Two standard measures are
*precision*, the fraction of guessed chunks that were correct TP/(TP+FP),
and *recall*, the fraction of correct chunks that were identified
TP/(TP+FN).  A third measure, the *F measure*, is the harmonic mean
of precision and recall, i.e. 1/(0.5/Precision + 0.5/Recall).

Windowdiff: Evaluating Segmentations
------------------------------------

.. _windowdiff:
.. figure:: ../images/windowdiff.png
   :scale: 30

   A Reference Segmentation and Two Hypothetical Segmentations

A different method must be used for comparing segmentations.  In Figure windowdiff_ we see two
possible segmentations of a sequence of items (e.g. tokenization, chunking, sentence segmentation),
which might have been produced by two programs or annotators.  If we naively score S\ :subscript:`1` and
S\ :subscript:`2` for their alignment with the reference segmentation, both will score 0 as neither
got the correct alignment.  However, S\ :subscript:`1` is clearly better than S\ :subscript:`2`,
and so we need a corresponding measure, such as `Windowdiff`:dt:.  Windowdiff is a simple
algorithm for evaluating the quality of a segmentation, by running a sliding window over the
data and awarding partial credit for near misses.  The following code illustrates the algorithm
running on the segmentations from Figure windowdiff_ using a window size of 3:

    >>> ref = "00000001000000010000000"
    >>> s1  = "00000010000000001000000"
    >>> s2  = "00010000000000000001000"
    >>> nltk.windowdiff(ref,ref,3)
    0
    >>> nltk.windowdiff(ref,s1,3)
    4
    >>> nltk.windowdiff(ref,s2,3)
    16


-----------------
Language Modeling
-----------------

* smoothing, estimation [EL]

----------------
Machine Learning
----------------

* feature selection, feature extraction
* text classification (question classification, language id, naive bayes etc)
* sequence classification (HMM, TBL)
* unsupervised learning (clusterers) 

.. include:: footer.txt

