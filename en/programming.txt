.. -*- mode: rst -*-
.. include:: ../definitions.txt

======================================
2. Programming Fundamentals and Python
======================================

This chapter provides a non-technical overview of Python and will
cover the basic programming knowledge needed for the rest of
the chapters in Part 1.  It contains many examples and exercises;
there is no better way to learn to program than to dive in and try
these yourself.  You should then feel confident to adapt them for your
own purposes.  Before you know it you will be programming!

---------------------
Python the Calculator
---------------------

One of the friendly things about Python is that it allows
you to type directly into the `interpreter`:dt: |mdash| the program that
will be running your Python programs. We want you to be completely
comfortable with this before we begin, so let's start it up:

.. doctest-ignore::
  Python 2.4.3 (#1, Mar 30 2006, 11:02:16) 
  [GCC 4.0.1 (Apple Computer, Inc. build 5250)] on darwin
  Type "help", "copyright", "credits" or "license" for more information.
  >>>

This blurb depends on your installation; the main thing to check is that
you are running Python 2.4 or greater (here it is 2.4.3).
The ``>>>`` prompt indicates that the Python interpreter is now waiting for input. If you are
using the Python interpreter through the Interactive DeveLopment Environment
(IDLE) then you should see a colorized version.
We have colorized our examples in the same way, so that you can tell if you
have typed the code correctly.
Let's begin by using the Python prompt as a calculator:

    >>> 3 + 2 * 5 - 1
    12
    >>>

There are several things to notice here.  First, once the
interpreter has finished calculating the answer and displaying it, the
prompt reappears. This means the Python interpreter is waiting for another
instruction.  Second, notice that Python deals with the
order of operations correctly (unlike some older calculators), so the
``2 * 5`` is calculated before it is added to ``3``.

Try a few more expressions of your own. You can use asterisk (``*``)
for multiplication and slash (``/``) for division, and parentheses for
bracketing expressions. One strange thing you might come across is
that division doesn't always behave how you expect:

    >>> 3/3
    1
    >>> 1/3
    0
    >>>

The second case is surprising because we would expect the answer to
be ``0.333333``.
We will come back to why that is the case later on in this chapter.
For now, let's simply observe that these examples demonstrate
that you can work interactively with the
interpreter, which means you can experiment and explore.
Also, as you will see later, your intuitions about numerical expressions
will be useful for manipulating all kinds of data in Python.

You should also try nonsensical expressions to see how the interpreter handles it:

    >>> 1 +
    Traceback (most recent call last):
      File "<stdin>", line 1
        1 +
          ^
    SyntaxError: invalid syntax
    >>>

.. The real output doesn't contain the "Traceback ..." line, but
   doctest doesn't recognize it as an exception without it.

Here we have produced a `syntax error`:dt:.  It doesn't make sense
to end an instruction with a plus sign. The Python interpreter indicates
the line where the problem occurred.

-----------------------------------------------
Understanding the Basics: Strings and Variables
-----------------------------------------------

Representing text
-----------------

We can't simply type text directly into the interpreter because it would
try to interpret the text as part of the Python language:

    >>> Hello World
    Traceback (most recent call last):
      File "<stdin>", line 1
        Hello World
                  ^
    SyntaxError: invalid syntax
    >>>

.. The real output doesn't contain the "Traceback ..." line, but
   doctest doesn't recognize it as an exception without it.

Here we see an error message.  Note that the interpreter is
confused about the position of the error, and points to the end of
the string rather than the start.

Python represents a piece of text using a `string`:dt:.  Strings are
`delimited`:dt: |mdash| or separated from the rest of the program |mdash| by quotation marks:

    >>> 'Hello World'
    'Hello World'
    >>> "Hello World"
    'Hello World'
    >>>

We can use either single or double quotation marks, as long as we use the
same ones on either end of the string.

Now we can perform calculator-like operations on strings.
For example, adding two strings together
seems intuitive enough that you could guess the result:

    >>> 'Hello' + 'World'
    'HelloWorld'
    >>>

This operation is called `concatenation`:dt: and it produces a new string
which is a copy of the two original strings pasted together end to end.
Notice that this doesn't do anything clever like insert a space between
the words.  The Python interpreter has no way of knowing that
you want a space; it does *exactly* what it is told.
Based on this it is also possible to guess what multiplication might do
(we have given you a hint too!):

    >>> 'Hi' + 'Hi' + 'Hi'
    'HiHiHi'
    >>> 'Hi'*3
    'HiHiHi'
    >>>

The point to take from this (apart from learning about strings) is that
in Python, intuition about what should work gets you a long way, so it
is worth just trying things to see what happens.  You are very unlikely
to break something, so just give it a go!

Storing and reusing values
--------------------------

After a while it gets quite tiresome to be retyping Python
expressions over and over again. Your programs won't get very interesting
or helpful either. Instead, we need a way to store the results of
calculations so we can use them again, instead of retyping them.
We do this by saving results to a location in the computer's memory,
and giving the location a name.  Such a named place is called a `variable`:dt:.
In Python we create variables by `assignment`:dt:, which involves putting
a value into the variable:

    >>> msg = 'Hello World'
    >>> msg
    'Hello World'
    >>>

Here we have created a variable called ``msg`` (short for message) and
set it to have the string value ``'Hello World'``. We used the ``=``
operation, which *assigns* the value of the expression on the right to
the variable on the left.  Notice the Python interpreter does not print
any output; this is because an assignment statement returns no value. On the
second line we inspect the contents of the variable by naming it on the
command line ``msg``. The interpreter prints out the contents on the
next line.

We can use variables in any place where we used values previously:

    >>> msg + msg
    'Hello WorldHello World'
    >>> three = 3
    >>> msg * three
    'Hello WorldHello WorldHello World'
    >>>

We can also assign a new value to a variable just by using assignment again:

    >>> msg = msg*2
    >>> msg
    'Hello WorldHello World'
    >>>

Here we have taken the value of ``msg``, multiplied it by ``2`` and then
stored that new string (``Hello WorldHello World``) back into the variable
``msg``.

Printing and inspecting strings
-------------------------------

.. In the previous section, we left msg with a value of
   "Hello WorldHello World".  But in this section, we are assuming
   that its value is back to just "Hello World".  Hopefully that
   won't confuse readers.  But in order to keep doctest from flagging
   an error, we'll set its value back inside the body of this comment:

     >>> msg = 'Hello World'

So far, when we have wanted to look at the contents of a variable or see
the result of a calculation, we have just typed the variable name into the interpreter.
For example, we can look at the contents of ``msg`` using:

    >>> msg
    'Hello World'
    >>>

Exercises
---------

1. Start up the Python interpreter (e.g. by running IDLE).
   Try the examples in the last section, before experimenting
   with the use of Python as a calculator.

2. Try the examples in this section, then try the following.

   a) Create a variable called ``msg`` and put some message
      of your own in this variable.  Remember that strings need
      to be quoted, so you will need to type something like:

      >>> msg = "I like NLP!"
    
   b) Now print the contents of this variable in two ways, first
      by simply typing the variable name and pressing enter, then
      by using the ``print`` command.

   c) Try various arithmetic expressions using this string, e.g.
      ``msg + msg``, and ``5 * msg``.
   
   d) Define a new string ``hello``, and then try ``hello + msg``.
      Change the ``hello`` string so that it ends with a space
      character, and then try ``hello + msg`` again.

------------------
Slicing and Dicing
------------------

Strings are so important that we will spend some more time on them.
Here we will learn how to access the individual `characters`:dt: that make
up a string, how to pull out arbitrary `substrings`:dt:, and how to reverse
strings.

Accessing individual characters
-------------------------------

The positions within a string are numbered, starting from zero.  To
access a position within a string, we specify the position inside
square brackets:

    >>> msg = 'Hello World'
    >>> msg[0]
    'H'
    >>> msg[3]
    'l'
    >>> msg[5]
    ' '
    >>>

This is called `indexing`:dt: or `subscripting`:dt: the string.
The position we specify inside the square brackets is called the `index`:dt:.
We can retrieve not only letters but any character, such as the space at
index ``5``.

The fact that strings are numbered from zero may seem
counter-intuitive.  However, it goes back to the way variables are
stored in a computer's memory.  As mentioned earlier, a variable is
actually the name of a location, or `address`:dt:, in memory.  Strings
are arbitrarily long, and their address is taken to be the position of
their first character, as shown in the figure below.

.. figure:: ../images/string-memory.png

   Variables and Computer Memory
   :scale:120

When we index into a string, the computer adds the index to the string's address.
Thus ``msg[3]`` is found at memory location ``3136 + 3``.  Accordingly, the first
position in the string is found at ``3136 + 0``, or ``msg[0]``.

Now, what happens when we try to access an index that is outside of the string?

  >>> msg[11]
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
  IndexError: string index out of range
  >>>

The index of ``11`` is outside of the range of valid indices (i.e. 0 to 10) for
the string ``'Hello World'``.
This results in an error message.  This time it is not a syntax error; the
program fragment is syntactically correct.  Instead, the error occurred
while the program was running.  The ``Traceback`` message indicates which
line the error occurred on (line 1 of 'standard input').  It is followed
by the name of the error, ``IndexError``, and a brief explanation.

In general, how do we know what we can index up to?  If we know the
length of the string, the highest valid index will be one less.  We
can get access to the length of the string using the ``len`` function.

    >>> len(msg)
    11
    >>>

.. Informally, a `function`:dt: is a named snippet of code that provides a
   service to our program when we `call`:dt: or execute it by name.

We call the ``len`` function by putting parentheses after
the name and giving it the string ``msg`` we want to know the length
of. Because ``len`` is built into the Python interpreter, IDLE colors
it purple.

We have seen what happens when the index is too large.  What about when it is too small?
Let's see what happens when we use values less than zero:

    >>> msg[-1]
    'd'
    >>>

This does not generate an error.  Instead, negative indices work from the
*end* of the string, so ``-1`` indexes the last character, which is ``'d'``.

    >>> msg[-3]
    'r'
    >>> msg[-6]
    ' '
    >>>

Now the computer works out the location in memory relative to the string's address
plus its length, e.g. ``3136 + 11 - 1 = 3146``.  Thus we have two ways to access
the characters in a string, from the start or the end.  For example, we can
access the space in the middle of ``Hello`` and ``World`` with either
``msg[5]`` or ``msg[-6]``; these refer to the same location, because
``5 = len(msg) - 6``.

Accessing substrings
--------------------

Next, we might want to access more than one character at a time. This is
also pretty simple, we just need to specify a range of characters for
indexing rather than one.  This process is called `slicing`:dt: and we
indicate a slice using a colon in the square brackets to separate the
beginning and end of the range:

    >>> msg[1:4]
    'ell'
    >>>

Here we see the characters are ``'e'``, ``'l'`` and ``'l'`` which correspond
to ``msg[1]``, ``msg[2]`` and ``msg[3]``, but not ``msg[4]``. This is because
a slice *starts* at the first index but finishes *one before* the end index.
This is consistent with starting indexing from zero: indexing starts from
zero and goes up to *one before* the length of the string. We can see that
by indexing with ``len`` directly:

    >>> len(msg)
    11
    >>> msg[0:11]
    'Hello World'
    >>>

We can also slice with negative indices |mdash| the same basic rules of starting
from the start index and stopping one before the end index applies;
here we stop before the space character:

    >>> msg[0:-6]
    'Hello'
    >>>

Python provides two
shortcuts for commonly used slice values. If the start index is ``0`` then
you can leave it out entirely, and if the end index is the length of the
string then you can leave it out entirely:

    >>> msg[:3]
    'Hel'
    >>> msg[6:]
    'World'
    >>>

The first example above selects the first three characters from the string,
and the second example selects from the character with index 6, namely ``'W'``,
to the end of the string. These shortcuts lead to a couple of common Python
idioms: 

    >>> msg[:-1]
    'Hello Worl'
    >>> msg[:]
    'Hello World'
    >>>

The first chomps off just the last character of the string, and the second
makes a complete copy of the string (which is more important when we come
to lists below).

Finally, we can also specify a step size for the slice.  
This returns every second character within the slice, in a forwards or
reverse direction:

    >>> msg[6:11:2]
    'Wrd'
    >>> msg[10:5:-2]
    'drW'
    >>>

We can also omit the slice indices.  The result is a useful idiom for
reversing strings:

    >>> msg[::-1]
    'dlroW olleH'
    >>>

Exercises
---------

1. Define a string ``s = 'colorless'``.  Write a Python statement
   that changes this to "colourless" using only the slice and
   concatenation operations.

#. Try the slice examples from this section using the interactive
   interpreter.  Then try some more of your own.  Guess what the result
   will be before executing the command.

#. We can use the slice notation to remove affixes of words.  For example,
   ``'dogs'[:-1]`` removes the last character of ``dogs``, leaving ``dog``.
   Use slice notation to remove affixes from these words:
   ``dishes``, ``running``, ``nationality``, ``undo``, ``preheat``.

#. We saw how we can generate an ``IndexError`` by indexing beyond the end
   of a string.  Is it possible to construct an index that goes too far to
   the left, before the start of the string?

---------------------------------
Strings, Sequences, and Sentences
---------------------------------

We have seen how words like `Hello`:lx: can be stored as a string ``'Hello'``.
Whole sentences can also be stored in strings, and manipulated as before,
as we can see here for Chomsky's famous nonsense sentence:

    >>> sent = 'colorless green ideas sleep furiously'
    >>> sent[16:21]
    'ideas'
    >>> len(sent)
    37
    >>>

However, it turns out to be a bad idea to treat a sentence as a sequence of its characters,
because this makes it too inconvenient to access the words or work out the length.  Instead,
we would prefer to represent a sentence as a sequence of its words, so that indexing a sentence
accesses its words, not its characters.  We will see how to do this now.

Lists
-----

A `list`:dt: is designed to store a sequence of values.  A list is
similar to a string in many ways except that individual items can be
*any type*, including strings, integers or even other lists.

A Python list is represented as a sequence of comma-separated items,
delimited by square brackets. Let's create part of Chomsky's
sentence as a list and put it in a variable ``phrase1``:

    >>> phrase1 = ['colorless', 'green', 'ideas']
    >>> phrase1
    ['colorless', 'green', 'ideas']
    >>>

Because lists and strings are both `sequence types`:dt:, they share lots of
functionality. In particular, sequence types support indexing and
slicing, which we can do with a list as well. The following example
applies many of the above operations to the list ``phrase1``:

    >>> len(phrase1)
    3
    >>> phrase1[0]
    'colorless'
    >>> phrase1[-1]
    'ideas'
    >>> phrase1[-5]
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    IndexError: list index out of range
    >>>

Here, ``phrase1[-5]`` generates an
error, because the fifth-last item in a three item list would
occur before the list started, i.e. it is undefined.
We can also slice lists in exactly the same way as strings:

    >>> phrase1[1:3]
    ['green', 'ideas']
    >>> phrase1[-2:]
    ['green', 'ideas']
    >>>

Lists can be concatenated just like strings.
Here we will put the resulting list into a new variable ``phrase2``.
The original variable ``phrase1`` is not changed in the process:

    >>> phrase2 = phrase1 + ['sleep', 'furiously']
    >>> phrase2
    ['colorless', 'green', 'ideas', 'sleep', 'furiously']
    >>> phrase1
    ['colorless', 'green', 'ideas']
    >>>

Now, lists and strings do not have exactly the same functionality.
Lists have the added power that you can change their elements. Let's
imagine that we want to change the 0th element of ``phrase1`` to
``'colorful'``, we can do that by assigning to the index ``phrase1[0]``:

    >>> phrase1[0] = 'colorful'
    >>> phrase1
    ['colorful', 'green', 'ideas']
    >>>

On the other hand if we try to do that with a string (for example
changing the 0th character in ``msg`` to ``'J'`` we get:

    >>> msg[0] = 'J'
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: object does not support item assignment
    >>>

This is because strings are `immutable`:dt: |mdash| you can't change a
string once you have created it.  However, lists are `mutable`:dt:,
and their contents can be modified at any time.  As a result, lists
support a number of operations, or `methods`:dt:, which modify the
original value rather than returning a new value. Two of these are
*sorting* and *reversing*: 

    >>> phrase2.sort()
    >>> phrase2
    ['colorless', 'furiously', 'green', 'ideas', 'sleep']
    >>> phrase2.reverse()
    >>> phrase2
    ['sleep', 'ideas', 'green', 'furiously', 'colorless']
    >>>

Notice that the prompt reappears on the line after ``phrase2.sort()`` and
``phrase2.reverse()``. That is because these methods do not return a new
list, but instead modify the original list stored in the variable ``phrase2``.
On the other hand, we can use the slice trick from above, ``[::-1]``
to create a *new* reversed list without changing ``phrase2``:

  >>> phrase2[::-1]
  ['colorless', 'furiously', 'green', 'ideas', 'sleep']
  >>> phrase2
  ['sleep', 'ideas', 'green', 'furiously', 'colorless']
  >>>

Lists also support an ``append`` method for adding items to the
end of the list and an ``index`` method for finding the index
of particular items in the list:

    >>> phrase2.append('said')
    >>> phrase2.append('Chomsky')
    >>> phrase2
    ['sleep', 'ideas', 'green', 'furiously', 'colorless', 'said', 'Chomsky']
    >>> phrase2.index('green')
    2
    >>>

Finally, just as a reminder, you can create lists of any values you like.
They don't even have to be the same type, although this is rarely a good
idea:

    >>> bat = ['bat', [[1, 'n', 'flying mammal'], [2, 'n', 'striking instrument']]]
    >>>

Working on sequences one item at a time
---------------------------------------

We can process each item in a sequence using a ``for`` loop.  This is our first example
of a `control structure`:dt: in Python, a statement that *controls* how other statements
are run:

    >>> for word in phrase2:
    ...     print len(word), word
    5 sleep
    5 ideas
    5 green
    9 furiously
    9 colorless
    4 said
    7 Chomsky

This program runs the statement ``print len(word), word`` for every
item in the list of words.  This process is called `iteration`:dt:.
Each *iteration* of the ``for`` loop starts by assigning the next
element of the list ``phrase2`` to the loop variable ``word``. Then
the indented `body`:dt: of the loop is run. Here the body consists of
a single command, but in general the body can contain as many lines of
code as you want, so long as it is indented by the same amount.

.. Note:: The interactive interpreter changes the prompt from
   ``>>>`` to the ``...`` prompt. This indicates it is expecting an
   indented block of code to appear next.  However, it is up to you to
   do the indentation.  To finish the indented block just enter a blank line.

We can run another ``for`` loop over the Chomsky nonsense sentence,
and calculate the average word length.  Observe that this program uses
the ``len`` function in two ways, to count the number of characters in
a word, and to count the number of words in a phrase.  Note that ``x += y``
is shorthand for ``x = x + y``.

    >>> total = 0
    >>> for word in phrase2:
    ...     total += len(word)
    ...
    >>> total / len(phrase2)
    6
    >>>

String Formatting
-----------------

The output of a program is usually structured to make the information
easily digestible by a reader.  Instead of running some code then
manually inspecting the contents of a variable, we would like the code
to tabulate some output.  We already saw this above, where each line of output
contained a word length, followed by the word in question.

There are many ways we might want to format such output.  For
instance, we might want the length value in parentheses after the
word, and all output on a single line:

    >>> for word in phrase2:
    ...     print word, '(', len(word), '),',
    sleep ( 5 ), ideas ( 5 ), green ( 5 ), furiously ( 9 ), colorless ( 9 ),
    said ( 4 ), Chomsky ( 7 ), 

Notice that the print statement ends with a comma, which is how we tell Python
not to print a newline at the end.

This approach has a couple of problems.  First, the print statement
intermingles variables and punctuation, making it a little difficult
to read.  Second, the output has spaces around every item that was
printed.  A cleaner way to produce structured output uses Python's
`string-formatting expressions`:dt:, e.g.:

    >>> for word in phrase2:
    ...     print "%s (%d)," % (word, len(word)),
    sleep (5), ideas (5), green (5), furiously (9), colorless (9), said (4), Chomsky (7), 

Here, the ``print`` keyword is followed by a three-part object having
the syntax: ``format % values``.  The format section is a string containing
`format specifiers`:dt: such as ``%s`` and ``%d`` which Python will replace
with the supplied values.  The ``%s`` specifier tells Python that the corresponding
variable is a string (or should be converted into a string), while
the ``%d`` specifier indicates that the corresponding variable should be
converted into a decimal representation.

Converting between strings and lists
------------------------------------

Often we want to convert between a string containing a space-separated
list of words and a list of strings.  Python strings have built-in support
for these operations.  First we'll consider the ``join`` method:

    >>> phrase3 = ' '.join(phrase2)
    >>> phrase3
    'sleep ideas green furiously colorless said Chomsky'
    >>>

This notation for the ``join`` method will seem very odd at
first. However, it follows exactly the same convention as ``sort`` and
``append`` above.  A method is called on a particular object using the
object's name, then a period, then the name of the method, and finally
the parentheses containing any arguments.
Here, the object is a string that consists of a single space ``' '``.  The
name of the method is ``join``, and the single argument to the ``join`` method
is the list of strings ``phrase2``.  As you can see from the example above, this takes
the space and creates a new string by inserting it between all of the items in
the list ``phrase2``. We have stored that string in the variable ``phrase3``.
We can do the same with other strings:

    >>> ' -> '.join(phrase2)
    'sleep -> ideas -> green -> furiously -> colorless -> said -> Chomsky'
    >>>

Now we want to reverse the process, splitting a string into a list.
This time, let's split the new string ``phrase3`` on the space character:

    >>> phrase3.split(' ')
    ['sleep', 'ideas', 'green', 'furiously', 'colorless', 'said', 'Chomsky']
    >>> phrase3.split('s')
    ['', 'leep idea', ' green furiou', 'ly colorle', '', ' ', 'aid Chom', 'ky']
    >>>

We can also split on any character, so we tried splitting on ``'s'``
as well.

Exercises
---------

1. Using the Python interpreter in interactive mode, experiment with
   the examples in this section.  Think of a sentence and
   represent it as a list of strings, e.g. ['Hello', 'world'].
   Try the various operations for indexing, slicing and sorting the elements
   of your list.  Extract individual items (strings), and perform
   some of the string operations on them.

#. We have seen how to represent a sentence as a list of words, where
   each word is a list of characters.  What does ``phrase1[2][2]`` do?
   Why?  Experiment with other index values.

#. Write a ``for`` loop to print out the characters of a string, one per line.

#. Process the list ``phrase2`` using a ``for`` loop, and store
   the result in a new list ``lengths``.  Hint: begin by assigning the empty
   list to ``lengths``, using ``lengths = []``, each time through the loop, use
   ``append()`` to add another length value to the list.

#. Define a variable ``silly`` to contain the string:
   ``'newly formed bland ideas are unexpressible in an infuriating
   way'``.  (This happens to be the legitimate interpretation that
   bilingual English-Spanish speakers can assign to Chomsky's
   famous phrase, according to Wikipedia).  Now write code to perform
   the following tasks:

   a) Split this string into a list of strings, one per
      word, using Python's ``split()`` operation.

   b) Extract the second letter of each word and join them into a
      string, to get ``'eoldrnnnna'``.

   c) Generate a list consisting of all the words up to (but not
      including) ``in``.  Hint: use the ``index()`` function in
      combination with list slicing.

   d) Combine these words back into a single string, using ``join()``.
      Make sure the words in the resulting string are separated with
      whitespace.

   e) Print the words of this sentence in alphabetical order, one per line.

#. What happens if you call ``split`` on a string, with no argument,
   e.g. ``phrase3.split()``?  What happens when the string being split
   contains tab characters, consecutive space characters, or a sequence
   of tabs and spaces?

#. Create a variable ``words`` containing a list of words.
   Experiment with ``words.sort()`` and ``sorted(words)``.
   What is the difference?

----------------
Making Decisions
----------------

So far, our simple programs have been able to manipulate sequences of
words, and perform some operation on each one.  We saw this for lists
consisting of a few words, but it works the same for lists of
arbitrary size, containing thousands of items.  Thus, such programs
have some interesting qualities: (i) the ability to work with
language, and (ii) the potential to save human effort through
automation.  Another useful feature of programs is their ability to
make decisions on our behalf; this is our focus in this section.

Making simple decisions
-----------------------

Most programming languages permit us to execute a block of code when a
`conditional expression`:dt:, or ``if`` statement, is satisfied.  In
the following program, we have created a variable called ``word``
containing the string value ``'cat'``. The ``if`` statement then
checks whether the condition ``len(word) < 5`` is true.  Because the
conditional expression is true, the *body* of the ``if`` statement is
invoked and the ``print`` statement is executed.

    >>> word = "cat"
    >>> if len(word) < 5:
    ...   print 'word length is less than 5'
    ... 
    word length is less than 5
    >>>

If we change the conditional expression to ``len(word) >= 5`` |mdash|
the length of ``word`` is greater than or equal to ``5`` |mdash|
then the conditional expression will no longer
be true, and the body of the ``if`` statement will not be run:

    >>> if len(word) >= 5:
    ...   print 'word length is greater than or equal to 5'
    ... 
    >>>

The ``if`` statement, just like the ``for`` statement above is a *control structure*.
An ``if`` statement is a control structure because it controls whether the
code in the body will be run.
You will notice that both ``if`` and ``for`` have a colon at the end of the line,
before the indentation begins. That's because all Python control structures end with
a colon.

What if we want to do something when the conditional expression is not true?
The answer is to add an ``else`` clause to the ``if`` statement:

    >>> if len(word) >= 5:
    ...   print 'word length is greater than or equal to 5'
    ... else:
    ...   print 'word length is less than 5'
    ... 
    word length is less than 5
    >>>

Finally, if we want to test multiple conditions in one go we can use an
``elif`` clause which acts like an ``else`` and an ``if`` combined:

    >>> if len(word) < 3:
    ...   print 'word length is less than three'
    ... elif len(word) == 3:
    ...   print 'word length is equal to three'
    ... else:
    ...   print 'word length is greater than three'
    ... 
    word length is equal to three
    >>>

Conditional expressions
-----------------------

Python supports a wide range of operators like ``<`` and ``>=`` for
testing the relationship between values. The full set of these *relational
operators* are:

======== ==============
Operator Relationship
======== ==============
``<``    less than
``<=``   less than or equal to
``==``   equal to (note this is two not one ``=`` sign)
``!=``   not equal to
``>``    greater than
``>=``   greater than or equal to
======== ==============

Normally we use conditional expressions as part of an ``if`` statement.
However, we can test these conditional operators directly at the prompt:

    >>> 3 < 5
    True
    >>> 5 < 3
    False
    >>>

Here we see that these expressions have `Boolean`:dt: values, namely
``True`` or ``False``.  Strings and lists also support conditional operators:

    >>> word = 'sovereignty'
    >>> 'sovereign' in word
    True
    >>> 'gnt' in word
    True
    >>> 'pre' in word
    False
    >>> 'Hello' in ['Hello', 'World']
    True
    >>>

Strings also have methods for testing what appears at the
beginning and the end of a string (as opposed to anywhere in the
string:

    >>> word.startswith('sovereign')
    True
    >>> msg.endswith('ty')
    True
    >>>

Iteration, items, and "if"
--------------------------

Now it is time to put some of the pieces together. We are going to take
the string ``'how now brown cow'`` and print out all of the words ending
in ``'ow'``.  Let's build the program up in stages.
The first step is to split the string into a list of words:

    >>> sentence = 'how now brown cow'
    >>> words = sentence.split()
    >>> words
    ['how', 'now', 'brown', 'cow']
    >>>

Next, we need to iterate over the words in the list. Just so we don't
get ahead of ourselves, let's print each word, one per line:

  >>> for word in words:
  ...     print word
  ... 
  how
  now
  brown
  cow
  >>>

The next stage is to only print out the words if they end in the
string ``'ow``'.  Let's check that we know how to do this first:

    >>> 'how'.endswith('ow')
    True
    >>> 'brown'.endswith('ow')
    False
    >>>

Now we are ready to put an ``if`` statement inside the ``for`` loop.
Here is the complete program:

    >>> sentence = 'how now brown cow'
    >>> words = sentence.split()
    >>> for word in words:
    ...     if word.endswith('ow'):
    ...         print word
    ... 
    how
    now
    cow
    >>>

As you can see, even with this small amount of Python knowledge it is
possible to develop useful programs. The key idea is to develop the
program in pieces, testing that each one does what you expect, and
then combining them to produce whole programs.  This is why the Python
interpreter is so great, and why you should get comfortable using it
directly.

Exercises
---------

1. Assign a new value to ``sentence``, the string
   ``'she sells sea shells by the sea shore'``, then
   write code to perform the following tasks:

   a) Print all words beginning with `sh`:lx:

   b) Print all words longer than 4 characters.

   c) Generate a new sentence that adds the popular
      hedge word `like`:lx: before every word
      beginning with `se`:lx:.  Your result should
      be a single string.

#. Write conditional expressions, such as ``'H' in msg``, but applied
   to lists instead of strings.  Check whether particular words are
   included in the Chomsky nonsense sentence.

#. Write code to abbreviate text by removing all the vowels.
   Define ``sentence`` to hold any string you like, then initialize
   a new string ``result`` to hold the empty string ``''``.  Now write
   a ``for`` loop to process the string, one character at a time,
   and append any non-vowel characters to the result string.

#. Write code to convert text into *hAck3r*, where
   ``e`` |rarr| ``3``,
   ``i`` |rarr| ``1``,
   ``o`` |rarr| ``0``,
   ``l`` |rarr| ``|``,
   ``s`` |rarr| ``5``,
   ``.`` |rarr| `` 5w33t!``,
   ``ate`` |rarr| ``8``.

-----------------
Getting organized
-----------------

.. TODO: figure xref, figure size

Strings and lists are a simple way to organize data.  In particular,
they *map* integers to values.  We can "look up" a string using an
integer to get one of its letters, and we can also look up a list of
words using an integer to get one of its strings.  These cases are
shown in the two tables on the left in the following figure.

.. _maps:
.. figure:: ../images/maps.png

   Sequences vs Dictionaries
   :scale:120

However, we will need to have a more flexible way to organize and
access our data.  Consider the other examples in figure maps_.  In the
case of a phone book, we look up an entry using a *name*, and get back
a number.  When we type a domain name in a web browser, the computer
looks this up to get back an IP address.  A frequency table allows us
to look up a word and find its frequency in a text collection.  In all
these cases cases, we are mapping from names to numbers.  In general,
we would like to be able to map between arbitrary types of
information.  The following table lists a variety of linguistic
objects, along with what they map.

====================  ==============  ====================================================
Linguistic Object     Maps from       Maps to
====================  ==============  ====================================================
Document Index        Word            List of pages (where the word is found)
Thesaurus             Word sense      List of synonyms
Dictionary            Headword        Entry (part of speech, sense definitions, etymology)
Comparative Wordlist  Gloss term      Cognates (list of words, one per language)
Morph Analyzer        Surface form    Morphological analysis (list of component morphemes)
====================  ==============  ====================================================

Most often, we are mapping from a string to some structured object.
For example, a document index maps from a word (which we can represent
as a string), to a list of pages (represented as a list of integers).
In this section, we will see how to represent such mappings in Python.

Accessing data with data
------------------------

Python provides a `dictionary`:dt: data type, which can be used for
mapping between arbitrary types.  Here we define ``pos`` to be an
empty dictionary and then add three entries to (for part-of-speech
information).  Observe that we add elements to a dictionary using
the familiar square bracket notation:

    >>> pos = {}
    >>> pos['colorless'] = 'adj'
    >>> pos['furiously'] = 'adv'
    >>> pos['ideas'] = 'n'
    >>>

.. Monkey-patching to get our dict examples to print consistently:

  >>> from nltk_lite.utilities import SortedDict
  >>> pos = SortedDict(pos)

We can access the entries in the predictable way:

    >>> pos['ideas']
    'n'
    >>> pos['colorless']
    'adj'
    >>>

Note that the item used for lookup is called the `key`:dt:, and the
entry that is returned is known as the `value`:dt:.  As with indexing
a list or string, we get an exception when we try to access the value
of a key that does not exist:

    >>> pos['missing']
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    KeyError: 'missing'
    >>>

This raises an important question.  Unlike lists and strings, where we
can use ``len`` to work out which integers will be legal indices, how
do we work out the legal keys for a dictionary?  Fortunately, we can
check whether a key exists in a dictionary using the ``in`` operator:

    >>> 'colorless' in pos
    True
    >>> 'missing' in pos
    False
    >>> 'missing' not in pos
    True
    >>>

Notice that we can use ``not in`` to check if a key is *missing*.  Be
careful with the ``in`` operator for dictionaries: it only applies to
the keys and not their values.  If we check for a value, e.g. ``'adj'
in pos``, the result is ``False``, since ``'adj'`` is not a key.
We can loop over all the entries in a dictionary using a ``for`` loop.

    >>> for word in pos:
    ...     print "%s (%s)" % (word, pos[word])
    ... 
    colorless (adj)
    furiously (adv)
    ideas (n)
    >>>

We can see what the contents of the dictionary look like by inspecting
the variable ``pos``:

    >>> pos
    {'furiously': 'adv', 'ideas': 'n', 'colorless': 'adj'}
    >>>

Here, the contents of the dictionary are shown in `key-value
pairs`:dt:.  Notice that the order of the key-value pairs is different
from the order they were originally entered.  This is because
dictionaries are not sequences but mappings; any ordering on the keys
exists independently of the mapping.  As we shall see later, this
gives us a lot of flexibility.  We can use the same format to create
a dictionary from a collection of key-value pairs:

    >>> pos = {'furiously': 'adv', 'ideas': 'n', 'colorless': 'adj'}
    >>>

.. Monkey-patching to get our dict examples to print consistently:

    >>> pos = SortedDict(pos)

We can access the keys and values as separate lists,
and also the key-value pairs:

    >>> pos.keys()
    ['colorless', 'furiously', 'ideas']
    >>> list(pos)
    ['colorless', 'furiously', 'ideas']
    >>> pos.values()
    ['adj', 'adv', 'n']
    >>> pos.items()
    [('colorless', 'adj'), ('furiously', 'adv'), ('ideas', 'n')]
    >>>

Counting with dictionaries
--------------------------

The values stored in a dictionary can be any kind of object, not just
a string.  The most common kind is actually an integer.  It turns out
that we can use a dictionary to store a large number of counters.  For
instance, we can have a counter for each letter of the alphabet, and
each time we get a certain letter we increment its corresponding
counter:

    >>> phrase = 'colorless green ideas sleep furiously'
    >>> count = {}
    >>> for letter in phrase:
    ...     if letter not in count:
    ...         count[letter] = 0
    ...     count[letter] += 1
    >>> count
    {'a': 1, ' ': 4, 'c': 1, 'e': 6, 'd': 1, 'g': 1, 'f': 1, 'i': 2,
     'l': 4, 'o': 3, 'n': 1, 'p': 1, 's': 5, 'r': 3, 'u': 2, 'y': 1}

Observe that ``in`` is used here in two different ways:
``for letter in phrase`` iterates over every letter, running
the body of the ``for`` loop.  Inside this loop, the
conditional expression ``if letter not in count`` checks whether the letter is missing
from the dictionary.  If it is missing, we create a new entry and
set its value to zero: ``count[letter] = 0``.  Now we are sure
that the entry exists, and it may have a zero or non-zero value.
We finish the body of the ``for`` loop by incrementing this particular
counter using the ``+=`` assignment operator.
Finally, we print the dictionary, to see the letters and their counts.
This method of maintaining many counters will find many uses, and you
will become very familiar with it.

There are other useful ways to display the result, sorting alphabetically
by the letter, or sorting by frequency:

    >>> letters = count.items()
    >>> letters.sort()
    >>> letters
    [(' ', 4), ('a', 1), ('c', 1), ('d', 1), ('e', 6), ('f', 1), ..., ('y', 1)]

Getting unique entries
----------------------

Sometimes, we don't want to count at all, but just want to make a
record of the items that we have seen, regardless of repeats.  For
example, we might want to compile a vocabulary from a document.  This
is a sorted list of the words that appeared, regardless of frequency.
At this stage we have two ways to do this.  The first uses lists.

    >>> sentence = "she sells sea shells by the sea shore".split()
    >>> words = []
    >>> for word in sentence:
    ...     if word not in words:
    ...         words.append(word)
    ...
    >>> words.sort()
    >>> words
    ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

We can write this using a dictionary as well.  Each word we find
is entered into the dictionary as a key.  We use a value of ``1``, but
it could be anything we like.  We extract the keys from the dictionary
simply by converting the dictionary to a list:

    >>> found = {}
    >>> for word in sentence:
    ...     found[word] = 1
    ... 
    >>> words = list(found)
    >>> words.sort()
    >>> words
    ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

There is a third way to do this, which is best of all: using Python's
`set`:dt: data type.  We can convert ``sentence`` into a set, using
``set(sentence)``:

    >>> set(sentence)
    set(['shells', 'sells', 'shore', 'she', 'sea', 'the', 'by'])  

The order of items in a set is not significant, and they will usually
appear in a different order to the one they were entered in.  The
main point here is that converting a list to a set removes any duplicates.
We convert it back into a list, sort it, and print.  Here is the complete
program:

    >>> sentence = "she sells sea shells by the sea shore".split()
    >>> words = list(set(sentence))
    >>> words.sort()
    >>> words
    ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

Here we have seen that there is sometimes more than one way to solve a
problem with a program.  In this case, we used three different
built-in data types, a list, a dictionary, and a set.  The set data type
mostly closely modelled our task, so it required the least amount of work.

Scaling it up
-------------

We can use dictionaries to count word occurrences.  For example, the
following code reads *Macbeth* and counts the frequency of each word:

    >>> from nltk_lite.corpora import gutenberg
    >>> count = {}                                        # initialize a dictionary
    >>> for word in gutenberg.raw('shakespeare-macbeth'): # tokenize Macbeth
    ...     word = word.lower()                           # normalize to lowercase
    ...     if word not in count:                         # seen this word before?
    ...         count[word] = 0                           # if not, set count to zero
    ...     count[word] += 1                              # increment the counter
    ...
    >>>

This example demonstrates some of the convenience of NLTK in accessing
corpora.  We will see much more of this later.  For now, all you need
to know is that ``gutenberg.raw()`` returns a list of words, in this
case from Shakespeare's Macbeth, which we are iterating over using a
``for`` loop.  We convert each word to lowercase using the string
method ``word.lower()``, and use a dictionary to maintain a set of
counters, one per word.  Now we can inspect the contents of the
dictionary to get counts for particular words:

    >>> count['scotland']
    12
    >>> count['the']
    692
    >>>

Exercises
---------

1. Using the Python interpreter in interactive mode, experiment with
   the examples in this section.  Create a dictionary ``d``, and add
   some entries.  What happens if you try to access a non-existent
   entry, e.g. ``d['xyz']``?

#. Try deleting an element from a dictionary, using the syntax
   ``del d['abc']``.  Check that the item was deleted.

#. Create a dictionary ``e``, to represent a single lexical entry
   for some word of your choice.
   Define keys like ``headword``, ``part-of-speech``, ``sense``, and
   ``example``, and assign them suitable values.

#. Create two dictionaries, ``d1`` and ``d2``, and add some entries to
   each.  Now issue the command ``d1.update(d2)``.  What did this do?
   What might it be useful for?

#. Write a program that takes a sentence expressed as a single string,
   splits it and counts up the words.  Get it to print out each word and the
   word's frequency, one per line, in alphabetical order.

----------------------
Miscellaneous trickery
----------------------

Regular Expressions
-------------------

Python has a `regular expression`:dt: module ``re`` |mdash|
this supports powerful search and substitution inside strings.

    >>> import re
    >>> from nltk_lite.utilities import re_show
    >>> sent = "colorless green ideas sleep furiously"
    >>>

We use a utility function ``re_show`` to show how regular expressions
match against substrings.  First we search for all instances of a particular
character or character sequence:

    >>> re_show('l', sent)
    co{l}or{l}ess green ideas s{l}eep furious{l}y
    >>> re_show('green', sent)
    colorless {green} ideas sleep furiously
    >>>

Now we can perform substitutions.  In the first instance we replace
all instances of ``l`` with ``s``.  Note that this generates a string
as output, and doesn't modify the original string.  Then we replace
any instances of ``green`` with ``red``.

    >>> re.sub('l', 's', sent)
    'cosorsess green ideas sseep furioussy'
    >>> re.sub('green', 'red', sent)
    'colorless red ideas sleep furiously'
    >>>

So far we have only seen simple patterns, consisting of individual
characters or sequences of characters.  However, regular expressions can
also contain special syntax, such as ``|`` for disjunction, e.g.:

    >>> re_show('(green|sleep)', sent)
    colorless {green} ideas {sleep} furiously
    >>> re.findall('(green|sleep)', sent)
    ['green', 'sleep']
    >>>

We can also disjoin individual characters using a square bracket
notation.  For example, ``[aeiou]`` matches any of ``a``, ``e``,
``i``, ``o``, or ``u``, that is, any vowel.  The expression
``[^aeiou]`` matches anything that is not a vowel.  In the following
example, we match sequences consisting of non-vowels followed by
vowels.

    >>> re_show('[^aeiou][aeiou]', sent)
    {co}{lo}r{le}ss g{re}en{ i}{de}as s{le}ep {fu}{ri}ously
    >>> re.findall('[^aeiou][aeiou]', sent)
    ['co', 'lo', 'le', 're', ' i', 'de', 'le', 'fu', 'ri']
    >>>

We can put parentheses around parts of an expression in order to
generate structured results.  For example, here we see all those
non-vowel characters which appear before a vowel:

    >>> re.findall('([^aeiou])[aeiou]', sent)
    ['c', 'l', 'l', 'r', ' ', 'd', 'l', 'f', 'r']
    >>>

We can even generate pairs (or *tuples*), which we may then go
on and tabulate.

    >>> re.findall('([^aeiou])([aeiou])', sent)
    [('c', 'o'), ('l', 'o'), ('l', 'e'), ('r', 'e'), (' ', 'i'),
     ('d', 'e'), ('l', 'e'), ('f', 'u'), ('r', 'i')]
    >>>

For an extended discussion of regular expressions, please see the
regular expression tutorial.

Writing Programs
----------------

[Intro: Using the text editor window in IDLE.]

When we want our programs to show some output, we must use the
``print`` statement:

  >>> print msg
  Hello World
  >>>

Hmm, that seems to do the same thing! However, on closer inspection you will
see that the quotation marks which indicate that Hello World is a string are
missing in the second case. That is because inspecting a variable (that only
works in the interpreter) prints out the Python representation of a value,
whereas the ``print`` statement only prints out the value itself, which in
this case is just the text in the string.

So, if you want the users of your program to be able to see something then
you need to use ``print``. If you just want to check the contents of the
variable while you are developing your program in the interactive interpreter,
then you can just type the variable name directly into the interpreter.



Exercises
---------

#. Describe the class of strings matched by the following regular
   expressions:

   a) ``[a-zA-Z]+``
   #) ``[A-Z][a-z]*``
   #) ``\d+(\.\d+)?``
   #) ``([bcdfghjklmnpqrstvwxyz][aeiou][bcdfghjklmnpqrstvwxyz])*``
   #) ``\w+|[^\w\s]+``

#. Write regular expressions to match the following classes of strings:

  a) A single determiner (assume that *a*, *an*, and *the*
     are the only determiners).
  #) An arithmetic expression using integers, addition, and
     multiplication, such as ``2*3+8``.

#. Write code to convert text into *hAck3r*, using regular expressions
   and substitution, where
   ``e`` |rarr| ``3``,
   ``i`` |rarr| ``1``,
   ``o`` |rarr| ``0``,
   ``l`` |rarr| ``|``,
   ``s`` |rarr| ``5``,
   ``.`` |rarr| ``5w33t!``,
   ``ate`` |rarr| ``8``.
   Normalise the text to lowercase before converting it.
   Add more substitutions of your own.  Now try to map
   ``s`` to two different values: ``$`` for word-initial ``s``,
   and ``5`` for word-internal ``s``.
   
#. Write code to read a file and print it in reverse, so that the last
   line is listed first.

#. Write code to access a favorite webpage and extract some text from it.
   For example, access a weather site and extract the forecast top
   temperature for your town or city today.

#. Read the Wikipedia entry on the *Soundex Algorithm*.  Implement this
   algorithm in Python.

-------
Summary
-------

* Text is represented in Python using strings, and we type these with
  single or double quotes: ``'Hello'``, ``"World".

* The characters of a string are accessed using indexes, counting from zero:
  ``'Hello World'[1]`` gives the value ``e``.  The length of a string is
  found using ``len()``.

* Substrings are accessed using slice notation: ``'Hello World'[1:5]``
  gives the value ``ello``.  If the start index is omitted, the
  substring begins at the start of the string, similarly for the end
  index.

* Sequences of words are represented in Python using lists of strings:
  ``['colorless', 'green', 'ideas']``.  We can use indexing, slicing
  and the ``len()`` function on lists.

* Strings can be split into lists: ``'Hello World'.split()`` gives
  ``['Hello', 'World']``.  Lists can be joined into strings:
  ``'/'.join(['Hello', 'World'])`` gives ``'Hello/World'``.

* Lists can be sorted in-place: ``words.sort()``.  To produce a separate,
  sorted copy, use: ``sorted(words)``.

* We process each item in a string or list using a ``for`` statement:
  ``for word in phrase``.  This must be followed by the colon character
  and an indented block of code, to be executed each time through the loop.

* We test a condition using an ``if`` statement: ``if len(word) < 5``.
  This must be followed by the colon character and an indented block of
  code, to be executed only if the condition is true.

* A dictionary is used to map between arbitrary types of information,
  such as a string and a number: ``freq['cat'] = 12``.  We create
  dictionaries using the brace notation: ``pos = {}``,
  ``pos = {'furiously': 'adv', 'ideas': 'n', 'colorless': 'adj'}``.

* [More: regular expressions]

---------------
Further Reading
---------------

Guido Van Rossum (2003).
*An Introduction to Python*,
Network Theory Ltd.

Guido Van Rossum (2003).
*The Python Language Reference*,
Network Theory Ltd.

Guido van Rossum (2005).
*Python Tutorial*
http://docs.python.org/tut/tut.html

A.M. Kuchling.
*Regular Expression HOWTO*,
http://www.amk.ca/python/howto/regex/

*Python Documentation*
http://docs.python.org/

Allen B. Downey, Jeffrey Elkner and Chris Meyers ()
*How to Think Like a Computer Scientist: Learning with Python*
http://www.ibiblio.org/obp/thinkCSpy/

.. include:: footer.txt
