.. -*- mode: rst -*-
.. include:: ../definitions.txt

======================================
2. Programming Fundamentals and Python
======================================

This chapter provides a non-technical overview of Python and will
cover the basic programming knoweldge you need to know for the rest of
the chapters in Part 1.  It contains many examples and exercises;
there is no better way to learn to program than to dive in and try
these yourself.  You should then feel confident to adapt them for your
own purposes.  Before you know it you will be programming!

For a more detailed overview, we recommend that you consult one of the
introductions listed in the further reading section below.  More
advanced programming material is contained in a later chapter.

---------------------
Python the Calculator
---------------------

One of the friendly things about Python is that it allows
you to type directly into the `interpreter`:dt: |mdash| the program that
will be running your Python programs. We want you to be completely
comfortable with this before we begin, so let's start it up:

.. doctest-ignore::
  Python 2.4.3 (#1, Mar 30 2006, 11:02:16) 
  [GCC 4.0.1 (Apple Computer, Inc. build 5250)] on darwin
  Type "help", "copyright", "credits" or "license" for more information.
  >>>

This blurb depends on your installation; the main thing to check is that
you are running Python 2.4 or greater (here it is 2.4.3).
The ``>>>`` prompt indicates that the Python interpreter is now waiting for input. If you are
using the Python interpreter through the Interactive DeveLopment Environment
(IDLE) then you should see a colorized version.
We have colorized the examples in the same way, so that you can tell if you
have typed the code in correctly.

Let's begin by using the Python prompt as a calculator:

  >>> 3 + 2 * 5 - 1
  12
  >>>

There are several things to notice here.  First, once the
interpreter has finished calculating the answer and displaying it, the
prompt reappears. This means the Python interpreter is waiting for another
instruction.  Second, notice that Python deals with the
order of operations correctly (unlike some older calculators), so the
``2 * 5`` is calculated before it is added to ``3``.

Try a few more expressions of your own. You can use asterisk (``*``)
for multiplication and slash (``/``) for division, and parentheses for
bracketing expressions. One strange thing you might come across is
that division doesn't always behave how you expect:

  >>> 3/3
  1
  >>> 1/3
  0
  >>>

The second case is surprising because we would expect the answer to
be ``0.333333``.
We will come back to why that is the case later on in this chapter.

You probably already have a calculator, so why is it so important
that you can use Python like one? Well, there are two main reasons:
(i) this demonstrates that you *can* work interactively with the
interpreter, which means you can experiment and explore; and
(ii) your intuitions about numerical expressions will turn out to be
useful for manipulating all kinds of data in Python.

You should also try nonsensical expressions to see how the interpreter handles it:

  >>> 1 +
  Traceback (most recent call last):
    File "<stdin>", line 1
      1 +
        ^
  SyntaxError: invalid syntax
  >>>

.. The real output doesn't contain the "Traceback ..." line, but
   doctest doesn't recognize it as an exception without it.

Here we have produced a `syntax error`:dt:.  It doesn't make sense
to end an instruction with a plus sign. The Python interpreter indicates
on what line and where on the line the particular problem occurred.
Note that the interpreter can sometimes get
confused, and point to something after the actual error.

-----------------------------------------------
Understanding the Basics: Strings and Variables
-----------------------------------------------

Representing text
-----------------

We can't simply type text directly into the interpreter because it would
try to interpret the text as part of the Python language:

  >>> Hello World
  Traceback (most recent call last):
    File "<stdin>", line 1
      Hello World
                ^
  SyntaxError: invalid syntax
  >>>

.. The real output doesn't contain the "Traceback ..." line, but
   doctest doesn't recognize it as an exception without it.

Python represents text using a `type`:dt: called a `string`:dt:.  Strings are
`delimited`:dt: |mdash| or separated from the rest of the program |mdash| by quotation marks:

  >>> 'Hello World'
  'Hello World'
  >>> "Hello World"
  'Hello World'
  >>>

We can use either single or double quotation marks, as long as we use the
same ones on either end of the string.

Now we can perform calculator-like operations on strings.
For example, adding two strings together
seems intuitive enough that you could guess the result:

  >>> 'Hello' + 'World'
  'HelloWorld'
  >>>

This operation is called `concatenation`:dt: and it produces a new string
which is a copy of the two original strings pasted together end to end.
Notice that this doesn't do anything clever like insert a space between
the words.  The Python interpreter has no way of knowing that
you want a space; it only does *exactly* what it is told.
Based on this it is also possible to guess what multiplication might do
(we have given you a hint too!):

  >>> 'Hi' + 'Hi' + 'Hi'
  'HiHiHi'
  >>> 'Hi'*3
  'HiHiHi'
  >>>

The point to take from this (apart from learning about strings) is that
in Python, intuition about what should work gets you a long way, so it
is worth just trying things to see what happens.  You are very unlikely
to break something, so just give it a go!

Storing and reusing values
--------------------------

After a while it gets quite tiresome to be retyping Python
expressions over and over again. Your programs won't get very interesting
or helpful either. Instead, we need a way to store results of
calculations so we can use them again, instead of retyping them.
We do this by saving results to a location in the computer's memory,
and giving the location a name.  Such a named place is called a `variable`:dt:.
In Python we create variables by `assignment`:dt:, which involves putting
a value into the variable:

  >>> msg = 'Hello World'
  >>> msg
  'Hello World'
  >>>

Here we have created a variable called ``msg`` (short for message) and
set it to have the string value ``'Hello World'``. We used the ``=``
operation, which *assigns* the value of the expression on the right to
the variable on the left.  Notice the Python interpreter returns
immediately because an assignment statement returns no value. On the
next line we inspect the contents of the variable by naming it on the
command line ``msg``. The interpreter prints out the contents on the
next line.

We can use variables in any place where we used values previously:

  >>> msg + msg
  'Hello WorldHello World'
  >>> three = 3
  >>> msg * three
  'Hello WorldHello WorldHello World'
  >>>

We can also assign a new value to a variable just by using assignment again:

  >>> msg = msg*2
  >>> msg
  'Hello WorldHello World'
  >>>

Here we have taken the value of ``msg``, multiplied it by ``2`` and then
stored that new string (``Hello WorldHello World``) back into the variable
``msg``.

Printing and inspecting strings
-------------------------------

.. In the previous section, we left msg with a value of
   "Hello WorldHello World".  But in this section, we are assuming
   that its value is back to just "Hello World".  Hopefully that
   won't confuse readers.  But in order to keep doctest from flagging
   an error, we'll set its value back inside the body of this comment:

   >>> msg = 'Hello World'

So far, when we have wanted to look at the contents of a variable or see
the result of a calculation, we have just typed it into the interpreter.
For example, we can look at the contents of ``msg`` using:

  >>> msg
  'Hello World'
  >>>

However, this trick only works in the interactive interpreter.  When we want
our programs to show some output, we must use the ``print`` statement:

  >>> print msg
  Hello World
  >>>

Hmm, that seems to do the same thing! However, on closer inspection you will
see that the quotation marks which indicate that Hello World is a string are
missing in the second case. That is because inspecting a variable (that only
works in the interpreter) prints out the Python representation of a value,
whereas the ``print`` statement only prints out the value itself, which in
this case is just the text in the string.

So, if you want the users of your program to be able to see something then
you need to use ``print``. If you just want to check the contents of the
variable while you are developing your program in the interactive interpreter,
then you can just type the variable name directly into the interpreter.

Exercises
---------

1. Start up the Python interpreter (e.g. by running IDLE).
   Try the examples in the last section, before experimenting
   with the use of Python as a calculator.

2. Try the examples in this section, then try the following.

   a) Create a variable called ``msg`` and put some message
      of your own in this variable.  Remember that strings need
      to be quoted, so you will need to type:

      >>> msg = "I like NLP!"
    
   b) Now print the contents of this variable in two ways, first
      by simply typing the variable name and pressing enter, then
      by using the ``print`` command.

   c) Try various arithmetic expressions using this string, e.g.
      ``msg + msg``, and ``5 * msg``.
   
   d) Define a new string ``hello``, and then try ``hello + msg``.
      Change the ``hello`` string so that it ends with a space
      character, and then try ``hello + msg`` again.

------------------
Slicing and Dicing
------------------

Strings are so important that we will spend some more time on them.
Here we will learn how to access the individual `characters`:dt: that make
up a string, how to pull out arbitrary `substrings`:dt:, and how to reverse
strings.

Accessing individual characters
-------------------------------

The positions within a string are numbered, starting from zero.  To
access a position within a string, we specify the position inside
square brackets:

  >>> msg = 'Hello World'
  >>> msg[3]
  'l'
  >>> msg[5]
  ' '
  >>> msg[0]
  'H'
  >>>

This is called `indexing`:dt: or `subscripting`:dt: the string.
The position we specify inside the square brackets is called the `index`:dt:.
We can retrieve not only letters but any character, such as the space at
index ``5``.

The fact that strings are numbered from zero may seem counter-intuitive.
However, it goes back to the way variables are stored in a computer's memory:
A variable is actually the name of a location, or `address`:dt:, in memory.
Strings are arbitrarily long, and their address is taken to be the position
of their first character, as shown in the figure below.

.. figure:: ../images/string-memory.png

   Variables and Computer Memory
   :scale:120

When we index into a string, the computer adds the index to the string's address.
Thus ``msg[3]`` is found at memory location ``3136 + 3``.  Accordingly, the first
position in the string is found at ``3136 + 0``, or ``msg[0]``.

Now, what happens when we try to access an index that is outside of the string?

  >>> msg[11]
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
  IndexError: string index out of range
  >>>

The index of ``11`` is outside of the range of valid indexes (0 to 10) for
the string ``'Hello World'``.
This results in an error message.  This time it is not a syntax error; the
program fragment is syntactically correct.  Instead, the error occurred
while the program was running.  The ``Traceback`` message indicates which
line the error occurred on (line 1 of 'standard input').  It is followed
by the name of the error, ``IndexError``, and a brief explanation.

In general, how do we know what we can index up to? We can get access to the length
of the string using the ``len`` function:

  >>> len(msg)
  11
  >>>

.. Informally, a `function`:dt: is a named snippet of code that provides a
   service to our program when we `call`:dt: or execute it by name.

We call the ``len`` function by putting parentheses after
the name and giving it the string ``msg`` we want to know the length
of. Because ``len`` is built into the Python interpreter, IDLE colors
it purple.

We have seen what happens when the index is too large.  What about when it is too small?
Let's see what happens when we use values less than zero:

  >>> msg[-1]
  'd'
  >>>

This does not generate an error.  Instead, negative indexes work from the
*end* of the string, so ``-1`` indexes the last character, which is ``'d'``.

  >>> msg[-3]
  'r'
  >>> msg[-6]
  ' '
  >>>

Now the computer works out the location in memory relative to the string's address
plus its length, e.g. ``3136 + 11 - 1 = 3146``.  Thus we have two ways to access
the characters in a string, from the start or the end.  For example, we can
access the space in the middle of ``Hello`` and ``World`` with either
``msg[5]`` or ``msg[-6]``; these refer to the same location, because
``5 = len(msg) - 6``.

Accessing substrings
--------------------

Next, we might want to access more than one character at a time. This is
also pretty simple, we just need to specify a range of characters for
indexing rather than one.  This process is called `slicing`:dt: and we
indicate a slice using a colon in the square brackets to separate the
beginning and end of the range:

  >>> msg[1:4]
  'ell'
  >>>

Here we see the characters are ``'e'``, ``'l'`` and ``'l'`` which correspond
to ``msg[1]``, ``msg[2]`` and ``msg[3]``, but not ``msg[4]``. This is because
a slice *starts* at the first index but finishes *one before* the end index.
This is consistent with starting indexing from zero: indexing starts from
zero and goes up to *one before* the length of the string. We can see that
by indexing with ``len`` directly:

  >>> len(msg)
  11
  >>> msg[0:11]
  'Hello World'
  >>>

We can also slice with negative indexes |mdash| the same basic rules of starting
from the start index and stopping one before the end index applies:

  >>> msg[0:-6]
  'Hello'
  >>>

so here that means we stop before the space character. Python provides two
shortcuts for commonly used slice values. If the start index is ``0`` then
you can leave it out entirely, and if the end index is the length of the
string then you can leave it out entirely:

  >>> msg[:3]
  'Hel'
  >>> msg[6:]
  'World'
  >>>

The first example above selects the first three characters from the string,
and the second example selects from the character with index 6 ``'W'``
to the end of the string. This shortcut leads to a couple of common Python
idioms: 

  >>> msg[:-1]
  'Hello Worl'
  >>> msg[:]
  'Hello World'
  >>>

The first chomps off just the last character of the string, and the second
makes a complete copy of the string (which is more important when we come
to lists below).

Finally, we can also specify a step size for the slice.  
This returns every second character within the slice, in a forwards or
reverse direction:

  >>> msg[6:11:2]
  'Wrd'
  >>> msg[10:5:-2]
  'drW'
  >>>

We can also omit the slice indexes.  The result is a useful idiom for
reversing strings:

  >>> msg[::-1]
  'dlroW olleH'
  >>>

Exercises
---------

1. Define a string ``s = 'colorless'``.  Write a Python statement
   that changes this to 'colourless', using only the slice and
   concatenation operations.

#. Try the slice examples from this section using the interactive
   interpreter.  Then try some more of your own.  Guess what the result
   will be before executing the command to make sure you are correct.

#. We can use the slice notation to remove suffixes of words.  For example,
   ``'dogs'[:-1]`` removes the last character of ``dogs``, leaving ``dog``.
   Use slice notation to remove suffixes from these words:
   ``dishes``, ``running``, ``nationality``.

#. We saw how we can generate an ``IndexError`` by indexing beyond the end
   of a string.  Is it possible to construct an index that goes too far to
   the left, before the start of the string?

---------------------------------
Strings, Sequences, and Sentences
---------------------------------

We have seen how words like `Hello`:lx: can be stored as a string ``'Hello'``.
Whole sentences can also be stored in strings, and manipulated as before,
as we can see here for Chomsky's famous nonsense sentence:

  >>> sent = 'colorless green ideas sleep furiously'
  >>> sent[16:21]
  'ideas'
  >>> len(sent)
  37
  >>>

However, it turns out to be a bad idea to treat a sentence as a sequence of its characters,
because this makes it too inconvenient to access the words or work out the length.  Instead,
we would prefer to represent a sentence as a sequence of its words, so that indexing a sentence
accesses its words, not its characters.  We will see how to do this now.

Lists
-----

A `list`:dt: is designed to store a sequence of values.  A list is
similar to a string in many ways except that individual items can be
*any type*, including strings, integers or even other lists.

A Python list is represented as a sequence of comma-separated items,
delimited by square brackets. Let's create part of Chomsky's
sentence as a list and put it in a variable ``phrase1``:

  >>> phrase1 = ['colorless', 'green', 'ideas']
  >>> phrase1
  ['colorless', 'green', 'ideas']
  >>>

Because lists and strings are both sequence types, they share lots of
functionality. In particular, sequence types support indexing and
slicing, which we can do with a list as well. The following example
performs many of the operations you have seen above for the list ``phrase1``:

  >>> len(phrase1)
  3
  >>> phrase1[0]
  'colorless'
  >>> phrase1[-1]
  'ideas'
  >>> phrase1[-5]
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
  IndexError: list index out of range
  >>>

Here, ``phrase1[-5]`` generates an
error, because the fifth-last item in a three item list would
occur before the list started, i.e. it is undefined.
We can also slice lists in exactly the same way as strings:

  >>> phrase1[1:3]
  ['green', 'ideas']
  >>> phrase1[-2:]
  ['green', 'ideas']
  >>>

Lists can be concatenated just like strings.
Here we will put the resulting list into a new variable ``phrase2``.
The original variable ``phrase1`` is not changed in the process:

  >>> phrase2 = phrase1 + ['sleep', 'furiously']
  >>> phrase2
  ['colorless', 'green', 'ideas', 'sleep', 'furiously']
  >>> phrase1
  ['colorless', 'green', 'ideas']
  >>>

Now, lists and strings do not have exactly the same functionality.
Lists have the added power that you can change their elements. Let's
imagine that we want to change the 0th element of list ``a`` to
``'colorful'``, we can do that by assigning to the index ``a[0]``:

  >>> phrase1[0] = 'colorful'
  >>> phrase1
  ['colorful', 'green', 'ideas']
  >>>

On the other hand if we try to do that with a string (for example
changing the 0th character in ``msg`` to ``'J'`` we get:

  >>> msg[0] = 'J'
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
  TypeError: object does not support item assignment
  >>>

This is because strings are `immutable`:dt: |mdash| you can't change a
string once you have created it.  However, lists are `mutable`:dt:,
and their contents can be modified at any time.  As a result, lists
support a number of operations, or `methods`:dt:, which modify the
original value rather than returning a new value. Two of these are
*sorting* and *reversing*: 

  >>> phrase2.sort()
  >>> phrase2
  ['colorless', 'furiously', 'green', 'ideas', 'sleep']
  >>> phrase2.reverse()
  >>> phrase2
  ['sleep', 'ideas', 'green', 'furiously', 'colorless']
  >>>

Notice that the prompt reappears on the line after ``phrase2.sort()`` and
``phrase2.reverse()``. That is because these methods do not return a new
list, but instead modify the original list stored in the variable ``phrase2``.
On the other hand, we can use the slice trick from above ``phrase2[::-1]``
to create a *new* reversed list without changing ``phrase2``:

  >>> phrase2[::-1]
  ['colorless', 'furiously', 'green', 'ideas', 'sleep']
  >>> phrase2
  ['sleep', 'ideas', 'green', 'furiously', 'colorless']
  >>>

Lists also support an ``append`` method for adding items to the
end of the list and an ``index`` method for finding the index
of particular items in the list:

  >>> phrase2.append('said')
  >>> phrase2.append('Chomsky')
  >>> phrase2
  ['sleep', 'ideas', 'green', 'furiously', 'colorless', 'said', 'Chomsky']
  >>> phrase2.index('green')
  2
  >>>

Finally, just as a reminder, you can create lists of any values you like.
They don't even have to be the same type, although this is rarely a good
idea:

  >>> bat = ['bat', [[1, 'n', 'flying mammal'], [2, 'n', 'striking instrument']]]
  >>>

Working on sequences one item at a time
---------------------------------------

We can process each item in a sequence using a ``for`` loop.  This is our first example
of a `control structure`:dt: in Python, a statement that *controls* how other statements
are run:

  >>> for word in phrase2:
  ...     print len(word), word
  5 sleep
  5 ideas
  5 green
  9 furiously
  9 colorless
  4 said
  7 Chomsky

This program runs the statement ``print len(word), word`` for every
item in the list of words.  This process is called `iteration`:dt:.
Each *iteration* of the ``for`` loop starts by assigning the next
element of the list ``phrase2`` to the loop variable ``word``. Then
the indented `body`:dt: of the loop is run. Here the body consists of
a single command, but in general the body can contain as many lines of
code as you want, so long as it is indented by the same amount.

.. Note:: The interactive interpreter changes the prompt from
   ``>>>`` to the ``...`` prompt. This indicates it is expecting an
   indented block of code to appear next. To finish the indented block
   just enter a blank line.

We can run another for loop over the Chomsky nonsense, and calculate
the average word length.  Observe that this program uses the ``len``
function in two ways, to count the number of characters in a word, and
to count the number of words in a phrase.

  >>> total = 0
  >>> for word in phrase2:
  ...     total += len(word)
  ...
  >>> total / len(phrase2)
  6
  >>>

Converting between strings and lists
------------------------------------

Often we want to convert a string containing a space separated list of words
and into a list of strings. Other times you want to do the reverse: take a list
of strings and make it into a single space separated string.
Python strings have some methods of their own to make this task simple:

  >>> phrase3 = ' '.join(phrase2)
  >>> phrase3
  'sleep ideas green furiously colorless said Chomsky'
  >>>

This notation for the ``join`` method may look very odd at first. However,
it follows exactly the same convention as ``sort`` and ``append`` above.
A method is called on a particular object using the object's name, then a period,
then the name of the method, and finally the parentheses containing any arguments.

Here, the object is a string that consists of a single space ``' '``, and the
name of the method is ``join``, and the single argument to the ``join`` method
is the list of strings ``phrase2``.  As you can see from the example above, this takes
the space and creates a new string by inserting it between all of the items in
the list ``phrase2``. We have stored that string in the variable ``phrase3``.

We can do the same with any string:

  >>> ' blah '.join(phrase2)
  'sleep blah ideas blah green blah furiously blah colorless blah said blah Chomsky'
  >>>

Ok, now we want to do the reverse process, splitting a string (and let's split the
new string ``phrase3`` up on the space character:

  >>> phrase3.split(' ')
  ['sleep', 'ideas', 'green', 'furiously', 'colorless', 'said', 'Chomsky']
  >>> phrase3.split('s')
  ['', 'leep idea', ' green furiou', 'ly colorle', '', ' ', 'aid Chom', 'ky']
  >>>

We can also split on any character, so we tried splitting on ``'s'`` as well.
If you don't specify an argument to ``split`` it will split on whitespace characters.

Exercises
---------

1. Using the Python interpreter in interactive mode, experiment with
   the examples in this section.  Think of a sentence and
   represent it as a list of strings, e.g. ['Hello', 'world'].
   Try the various operations for indexing, slicing and sorting the elements
   of your list.  Extract individual items (strings), and perform
   some of the string operations on them.

#. We have seen how to represent a sentence as a list of words, where
   each word is a list of characters.  What does ``phrase1[2][2]`` do?
   Why?  Experiment with other index values.

#. Write a ``for`` loop to print out the characters of a string, one per line.

#. Process the list ``phrase2`` using a ``for`` loop, and store
   the result in a new list ``lengths``.  Hint: begin by assigning the empty
   list to ``lengths``, using ``lengths = []``, each time through the loop, use
   ``append()`` to add another length value to the list.

#. Define a variable ``silly`` to contain the string:
   ``'newly formed bland ideas are unexpressible in an infuriating
   way'``.  (This happens to be the legitimate interpretation that
   bilingual English-Spanish speakers can assign to Chomsky's
   famous phrase, according to Wikipedia).  Now write code to perform
   the following tasks:

   a) Split this string into a list of strings, one per
      word, using Python's ``split()`` operation.

   b) Extract the second letter of each word and join them into a
      string, to get ``'eoldrnnnna'``.

   c) Generate a list consisting of all the words up to (but not
      including) ``in``.  Hint: use the ``index()`` function in
      combination with list slicing.

   d) Combine these words back into a single string, using ``join()``.
      Make sure the words in the resulting string are separated with
      whitespace.

   e) Print the words of this sentence in alphabetical order, one per line.

----------------
Making Decisions
----------------

So far, our simple programs have been able to manipulate sequences of
words, and perform some operation on each one.  We saw this for lists
consisting of a few words, but it works the same for lists of
arbitrary size, containing thousands of items.  Thus, such programs
have some interesting qualities: (i) the ability to work with
language, and (ii) the potential to save human effort through
automation.  Another useful feature of programs is their ability to
make decisions on our behalf; this is our focus in this section.

Making simple decisions
-----------------------

Most programming languages permit us to execute a block of code when a
`conditional expression`:dt:, or ``if`` statement, is satisfied.  In
the following program, we have created a variable called ``word``
containing the string value ``'cat'``. The ``if`` statement then
checks whether the condition ``len(word) < 5`` is true.  Because the
conditional expression is true, the *body* of the ``if`` statement is
invoked and the ``print`` statement is executed.

  >>> word = "cat"
  >>> if len(word) < 5:
  ...   print 'word length is less than 5'
  ... 
  word length is less than 5
  >>>

If we change the conditional expression to ``len(word) >= 5`` |mdash|
the length of ``word`` is greater than or equal to ``5`` |mdash|
then the conditional expression will no longer
be true, and the body of the ``if`` statement will not be run:

  >>> if len(word) >= 5:
  ...   print 'word length is greater than or equal to 5'
  ... 
  >>>

The ``if`` statement, just like the ``for`` statement above is a *control structure*.
An ``if`` statement is a control structure because it controls whether the
code in the body will be run.
You will notice that both ``if`` and ``for`` have a colon at the end of the line,
before the indentation begins. That's because all Python control structures end with
a colon.

What if we want to do something when the conditional expression is not true?
The answer is to add an ``else`` clause to the ``if`` statement:

  >>> if len(word) >= 5:
  ...   print 'word length is greater than or equal to 5'
  ... else:
  ...   print 'word length is less than 5'
  ... 
  word length is less than 5
  >>>

Finally, if we want to test multiple conditions in one go we can use an
``elif`` clause which acts like an ``else`` and an ``if`` combined:

  >>> if len(word) < 3:
  ...   print 'word length is less than three'
  ... elif len(word) == 3:
  ...   print 'word length is equal to three'
  ... else:
  ...   print 'word length is greater than three'
  ... 
  word length is equal to three
  >>>

Conditional expressions
-----------------------

Python supports a wide range of operators like (``<`` and ``>=``) for
testing the relationship between values. The full set of these *relational
operators* are:

======== ==============
Operator Relationship
======== ==============
``<``    less than
``<=``   less than or equal to
``==``   equal to (note this is two not one ``=`` sign)
``!=``   not equal to
``>``    greater than
``>=``   greater than or equal to
======== ==============

You can test these conditional operators directly at the prompt:

  >>> 3 < 5
  True
  >>> 5 < 3
  False
  >>>

Python also supports conditional operators for lists and strings:

  >>> msg = 'Hello World'
  >>> 'H' in msg
  True
  >>> 'X' in msg
  False
  >>> 'ell' in msg
  True
  >>>

Finally, Python strings have a couple of useful methods for testing
the what appears at the beginning and the end of a string (as opposed
to anywhere in the string:

  >>> msg.startswith('Hell')
  True
  >>> msg.endswith('rld')
  True
  >>>

Iteration, items, and if
------------------------

Now it is time to put some of the pieces together. We are going to take
the string ``'how now brown cow'`` and print out all of the words ending
in ``'ow'``.  Let's build the program up in stages.
The first step is to split the string into a list of words:

  >>> sentence = 'how now brown cow'
  >>> words = sentence.split()
  >>> words
  ['how', 'now', 'brown', 'cow']
  >>>

Next, we need to iterate over the words in the list. Just so we don't
get ahead of ourselves, let's print each word, one per line:

  >>> for word in words:
  ...     print word
  ... 
  how
  now
  brown
  cow
  >>>

The next stage is to only print out the words if they end in the
string ``'ow``'.  Let's check that we know how to do this first:

  >>> 'how'.endswith('ow')
  True
  >>> 'brown'.endswith('ow')
  False
  >>>

Now we are ready to put an ``if`` statement inside the ``for`` loop.
Here is the complete program:

  >>> sentence = 'how now brown cow'
  >>> words = sentence.split()
  >>> for word in words:
  ...     if word.endswith('ow'):
  ...         print word
  ... 
  how
  now
  cow
  >>>

As you can see, even with this small amount of Python knowledge it is
possible to develop useful programs. The key idea is to develop the
program in pieces, testing that each one does what you expect, and
then combining them to produce whole programs.  This is why the Python
interpreter is so great, and why you should get comfortable using it
directly.

Exercises
---------

1. Assign a new value to ``sentence``, the string
   ``'she sells sea shells by the sea shore'``, then
   write code to perform the following tasks:

   a) Print all words beginning with `sh`:lx:

   b) Print all words longer than 4 characters.

   c) Generate a new sentence that adds the popular
      hedge word `like`:lx: before every word
      beginning with `se`:lx:.  Your result should
      be a single string.

#. Write conditional expressions, such as ``'H' in msg``, but applied
   to lists instead of strings.  Check whether particular words are
   included in the Chomsky nonsense sentence.

#. Write code to abbreviate text by removing all the vowels.
   Define ``sentence`` to hold any string you like, then initialize
   a new string ``result`` to hold the empty string ``''``.  Now write
   a ``for`` loop to process the string, one character at a time,
   and append any non-vowel characters to the result string.

#. Write code to convert text into *hAck3r*, where
   ``e`` |rarr| ``3``,
   ``i`` |rarr| ``1``,
   ``o`` |rarr| ``0``,
   ``l`` |rarr| ``|``,
   ``s`` |rarr| ``5``,
   ``.`` |rarr| `` 5w33t!``,
   ``ate`` |rarr| ``8``.

-----------------
Getting organized
-----------------

Strings and lists are a simple way to organize data.  In particular,
they *map* integers to values.  We can 'look up' a string using an integer
to get one of its letter, and we can also look up a list of words using an integer
to get one of its strings.  These cases are shown in the two tables on the left
in the following figure.

.. figure:: ../images/maps.png

   Sequences vs Dictionaries
   :scale:120

However, we will need to have a more flexible way to organize and
access our data.  Consider the other examples in this figure.  In the
case of a phone book, we look up an entry using a *name*, and get back
a number.  When we type a domain name in a web browser, the computer
looks this up to get back an IP address.  A frequency table allows us
to look up a word and find its frequency in a text collection.  In all
these cases cases, we are mapping from names to numbers.  In general,
we would like to be able to map between arbitrary types of
information.  The following table lists a variety of linguistic
objects, along with what they map.

====================  ==============  ====================================================
Linguistic Object     Maps from       Maps to
====================  ==============  ====================================================
Document Index        Word            List of pages (where the word is found)
Thesaurus             Word sense      List of synonyms
Dictionary            Headword        Entry (part of speech, sense definitions, etymology)
Comparative Wordlist  Gloss term      Cognates (list of words, one per language)
Morph Analyzer        Surface form    Morphological analysis (list of component morphemes)
====================  ==============  ====================================================

Most often, we are mapping from a string to some structured object.
For example, a document index maps from a word (which we can represent
as a string), to a list of pages (represented as a list of integers).
In this section, we will see how to represent such mappings in Python.

Accessing data with data
------------------------

Python provides a `dictionary`:dt: data type, which can be used for
mapping between arbitrary types.  Here we define ``pos`` to be an
empty dictionary and then add three entries to (for part-of-speech
information).  Observe that we access elements in a dictionary using
the familiar square bracket notation:

  >>> pos = {}
  >>> pos['colorless'] = 'adj'
  >>> pos['furiously'] = 'adv'
  >>> pos['ideas'] = 'n'
  >>>

.. Monkey-patching to get our dict examples to print consistently:

  >>> from nltk_lite.utilities import SortedDict
  >>> pos = SortedDict(pos)

We can access the entries in the predictable way:

  >>> pos['ideas']
  'n'
  >>> pos['colorless']
  'adj'
  >>>

Note that the item used for lookup is called the `key`:dt:, and the
entry that is returned is known as the `value`:dt:.  As with indexing
a list or string, we get an exception when we try to access the value
of a key that does not exist:

  >>> pos['missing']
  Traceback (most recent call last):
    File "<stdin>", line 1, in ?
  KeyError: 'missing'
  >>>

This raises an important question.  Unlike lists and strings, where we
can use ``len`` to work out which integers will be legal indexes, how
do we work out the legal keys for a dictionary?  Fortunately, we can
check whether a key exists in a dictionary using the ``in`` operator:

  >>> 'colorless' in pos
  True
  >>> 'missing' in pos
  False
  >>> 'missing' not in pos
  True
  >>>

Notice that we can use ``not in`` to check if a key is *missing*.  Be
careful with the ``in`` operator for dictionaries, it only applies to
the keys and not their values.  If we check for a value, e.g. ``'adj'
in pos``, the result is ``False``, since ``'adj'`` is not a key.
We can loop over all the entries in a dictionary using a ``for`` loop:

  >>> for word in pos:
  ...     print "%s [%s]" % (word, pos[word])
  ... 
  colorless [adj]
  furiously [adv]
  ideas [n]
  >>>

We can see what the contents of the dictionary look like by inspecting
the variable ``pos``:

  >>> pos
  {'furiously': 'adv', 'ideas': 'n', 'colorless': 'adj'}
  >>>

Here, the contents of the dictionary are shown in `key-value
pairs`:dt:.  Notice that the order of the key-value pairs is different
from the order they were originally entered.  This is because
dictionaries are not sequences but mappings; any ordering on the keys
exists independently of the mapping.  As we shall see later, this
gives us a lot of flexibility.

Now, since the interpreter always displays the contents of variables using
Python syntax, we can now see how to create a dictionary with a collection
of key-value pairs in a single command:

  >>> pos = {'furiously': 'adv', 'ideas': 'n', 'colorless': 'adj'}
  >>>

.. Monkey-patching to get our dict examples to print consistently:

  >>> pos = SortedDict(pos)

We can access the keys and values as separate lists,
and also the key-value pairs:

  >>> pos.keys()
  ['colorless', 'furiously', 'ideas']
  >>> list(pos)
  ['colorless', 'furiously', 'ideas']
  >>> pos.values()
  ['adj', 'adv', 'n']
  >>> pos.items()
  [('colorless', 'adj'), ('furiously', 'adv'), ('ideas', 'n')]
  >>>

Counting with dictionaries
--------------------------

The values stored in a dictionary can be any kind of object, not just a string.  The most
common kind is actually an integer.  It turns out that we can use a dictionary to store
a large number of counters.  For instance, we can have a counter for each letter of the alphabet,
and each time we get a certain letter we increment its corresponding counter:

  >>> phrase = 'colorless green ideas sleep furiously'
  >>> count = {}
  >>> for letter in phrase:
  ...     if letter not in count:
  ...         count[letter] = 0
  ...     count[letter] += 1
  >>> count
  {'a': 1, ' ': 4, 'c': 1, 'e': 6, 'd': 1, 'g': 1, 'f': 1, 'i': 2,
   'l': 4, 'o': 3, 'n': 1, 'p': 1, 's': 5, 'r': 3, 'u': 2, 'y': 1}

Observe that ``in`` is used here in two different ways:
``for letter in phrase`` iterates over every letter, running
the body of the ``for`` loop.  Inside this loop, the
conditional expression ``if letter not in count`` checks whether the letter is missing
from the dictionary.  If it is missing, we create a new entry and
set its value to zero: ``count[letter] = 0``.  Now we are sure
that the entry exists, and it may have a zero or non-zero value.
We finish the body of the ``for`` loop by incrementing this particular
counter.  Finally, we print the dictionary, to see the letters and their counts.
This method of maintaining many counters will find many uses, and you
will become very familiar with it.

There are other useful ways to display the result, sorting alphabetically
by the letter, or sorting by frequency:

  >>> letters = count.items()
  >>> letters.sort()
  >>> letters
  [(' ', 4), ('a', 1), ('c', 1), ('d', 1), ('e', 6), ('f', 1), ..., ('y', 1)]

Getting unique entries
----------------------

Sometimes, we don't want to count at all, but just want to make a
record of the items that we have seen, regardless of repeats.  For
example, we might want to compile a vocabulary from a document.  This
is a sorted list of the words that appeared, regardless of frequency.
At this stage we have two ways to do this.  The first uses lists.

  >>> sentence = "she sells sea shells by the sea shore".split()
  >>> words = []
  >>> for word in sentence:
  ...     if word not in words:
  ...         words.append(word)
  ...
  >>> words.sort()
  >>> words
  ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

We can write this using a dictionary as well.  Each word we find
is entered into the dictionary as a key.  We use a value of ``1``, but
it could be anything we like.  We extract the keys from the dictionary
simply by converting the dictionary to a list:

  >>> found = {}
  >>> for word in sentence:
  ...     found[word] = 1
  ... 
  >>> words = list(found)
  >>> words.sort()
  >>> words
  ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

There is a third way to do this, which is best of all: using Python's
`set`:dt: data type.  We can convert ``sentence`` into a set, using
``set(sentence)``:

  >>> set(sentence)
  set(['shells', 'sells', 'shore', 'she', 'sea', 'the', 'by'])  

The order of items in a set is not significant, and they will usually
appear in a different order to the one they were entered in.  The
main point here is that converting a list to a set removes any duplicates.
We convert it back into a list, sort it, and print.  Here is the complete
program:

  >>> sentence = "she sells sea shells by the sea shore".split()
  >>> words = list(set(sentence))
  >>> words.sort()
  >>> words
  ['by', 'sea', 'sells', 'she', 'shells', 'shore', 'the']

Here we have seen that there is sometimes more than one way to solve a
problem with a program.  In this case, we used three different
built-in data types, a list, a dictionary, and a set.  The set data type
mostly closely modelled our task, so it required the least amount of work.
As a programmer you can decide which method you find most readable.  

Scaling it up
-------------

We can use dictionaries to count word occurrences.  For example, the
following code reads *Macbeth* and counts the frequency of each word:

  >>> from nltk_lite.corpora import gutenberg
  >>> count = {}                                        # initialize a dictionary
  >>> for word in gutenberg.raw('shakespeare-macbeth'): # tokenize Macbeth
  ...     word = word.lower()                           # normalize to lowercase
  ...     if word not in count:                         # seen this word before?
  ...         count[word] = 0                           # if not, set count to zero
  ...     count[word] += 1                              # increment the counter
  ...
  >>>

This example demonstrates some of the convenience of NLTK in accessing
corpora.  We will see much more of this later.  For now, all you need
to know is that ``gutenberg.raw()`` returns a list of words, in this
case from Shakespeare's Macbeth, which we are iterating over using a
``for`` loop.  We convert each word to lowercase using the string
method ``word.lower()``, and use a dictionary to maintain a set of
counters, one per word.  Now we can inspect the contents of the
dictionary to get counts for particular words:

  >>> count['scotland']
  12
  >>> count['the']
  692
  >>>

Exercises
---------

1. Create a dictionary ``d``, and add some entries.  What happens if
   you try to access a non-existent entry, e.g. ``d['xyz']``?

#. Try deleting an element from a dictionary, using the syntax
   ``del d['abc']``.  Check that the item was deleted.

#. Create a dictionary ``e``, to represent a single lexical entry.
   Define keys like ``headword``, ``part-of-speech``, ``sense``, and
   ``example``.

#. Create two dictionaries, ``d1`` and ``d2``, and add some entries to
   each.  Now issue the command ``d1.update(d2)``.  What did this do?
   What might it be useful for?

#. Write a program that takes a sentence expressed as a single string,
   splits it, counts up the words.  Get it to print out each word and the
   word's frequency, one per line, in alphabetical order.

----------------------
Miscellaneous trickery
----------------------

Regular Expressions
-------------------

Python has a `regular expression`:dt: module ``re`` |mdash|
this supports powerful search and substitution inside strings.

  >>> import re
  >>> from nltk_lite.utilities import re_show
  >>> sent = "colorless green ideas sleep furiously"
  >>>

We use a utility function ``re_show`` to show how regular expressions
match against substrings.  First we search for all instances of a particular
character or character sequence:

  >>> re_show('l', sent)
  co{l}or{l}ess green ideas s{l}eep furious{l}y
  >>> re_show('green', sent)
  colorless {green} ideas sleep furiously
  >>>

Now we can perform substitutions.  In the first instance we replace
all instances of ``l`` with ``s``.  Note that this generates a string
as output, and doesn't modify the original string.  Then we replace
any instances of ``green`` with ``red``.

  >>> re.sub('l', 's', sent)
  'cosorsess green ideas sseep furioussy'
  >>> re.sub('green', 'red', sent)
  'colorless red ideas sleep furiously'
  >>>

So far we have only seen simple patterns, consisting of individual
characters or sequences of characters.  However, regular expressions can
also contain special syntax, such as ``|`` for disjunction, e.g.:

  >>> re_show('(green|sleep)', sent)
  colorless {green} ideas {sleep} furiously
  >>> re.findall('(green|sleep)', sent)
  ['green', 'sleep']
  >>>

We can also disjoin individual characters.  For example,
``[aeiou]`` matches any of ``a``, ``e``, ``i``, ``o``, or ``u``,
that is, any vowel.  The expression ``[^aeiou]`` matches anything
that is not a vowel.  In the following example, we match sequences
consisting of non-vowels followed by vowels.

  >>> re_show('[^aeiou][aeiou]', sent)
  {co}{lo}r{le}ss g{re}en{ i}{de}as s{le}ep {fu}{ri}ously
  >>> re.findall('[^aeiou][aeiou]', sent)
  ['co', 'lo', 'le', 're', ' i', 'de', 'le', 'fu', 'ri']
  >>>

We can put parentheses around parts of an expression in order to
generate structured results.  For example, here we see all those
non-vowel characters which appear before a vowel:

  >>> re.findall('([^aeiou])[aeiou]', sent)
  ['c', 'l', 'l', 'r', ' ', 'd', 'l', 'f', 'r']
  >>>

We can even generate pairs (or *tuples*), which we may then go
on and tabulate.

  >>> re.findall('([^aeiou])([aeiou])', sent)
  [('c', 'o'), ('l', 'o'), ('l', 'e'), ('r', 'e'), (' ', 'i'),
   ('d', 'e'), ('l', 'e'), ('f', 'u'), ('r', 'i')]
  >>>

For an extended discussion of regular expressions, please see the
regular expression tutorial.

Accessing Files and the Web
---------------------------

.. Monkey-patching to fake the file/web examples in this section:

  >>> from StringIO import StringIO
  >>> def fake_open(filename, mode=None):
  ...     return StringIO('Hello world.\nThis is a test file.\n')
  >>> def fake_urlopen(url):
  ...     return StringIO(' BBC NEWS | News Front Page News Sport '
  ...                     'Weather World Service')
  >>> open = fake_open
  >>> import urllib
  >>> urllib.urlopen = fake_urlopen

It is easy to access local files in Python.  Here are some examples.
(You will need to create a file called ``corpus.txt`` before you can
open it for reading.)

  >>> f = open('corpus.txt', 'rU')
  >>> f.read() 
  'Hello world.\nThis is a test file.\n'
  >>>

The first stage is to `open`:dt: a file using the builtin function ``open``,
which takes two arguments, the name of the file, here corpus.txt, and the
mode to open the file with |mdash| for now trust us and always use ``'rU'`` for
files you are opening for reading.

To read the contents of the file we can use lots of different methods.
The one above uses the file read method ``f.read()``, which reads
the entire contents of a file into a string.

You might be wondering what is the funny ``'\n'`` character on the end of
the string.  This is a `newline`:dt: character, which is equivalent to
pressing *Enter* and starting a new line. There is also a ``'\t'`` character
for representing tab.

We can also read a file one line at a time using the ``for`` loop construct:

  >>> f = open('corpus.txt')
  >>> for line in f:
  ...     print line[:-1]
  Hello world.
  This is a test file.
  >>>

Here we use the slice trick ``line[:-1]`` to chomp of the newline we are
reading in from the file since the ``print`` statement already adds an
extra newline.

Finally, it isn't too much more difficult in Python to read in a webpage:

  >>> from urllib import urlopen
  >>> page = urlopen("http://news.bbc.co.uk/").read()
  >>> page = re.sub('<[^>]*>', '', page)   # strip HTML markup
  >>> page = re.sub('\s+', ' ', page)      # strip whitespace
  >>> print page[:60]
   BBC NEWS | News Front Page News Sport Weather World Service
  >>>

Exercises
---------

#. Describe the class of strings matched by the following regular
   expressions:

   a) ``[a-zA-Z]+``
   #) ``[A-Z][a-z]*``
   #) ``\d+(\.\d+)?``
   #) ``([bcdfghjklmnpqrstvwxyz][aeiou][bcdfghjklmnpqrstvwxyz])*``
   #) ``\w+|[^\w\s]+``

#. Write regular expressions to match the following classes of strings:

  a) A single determiner (assume that *a*, *an*, and *the*
     are the only determiners).
  #) An arithmetic expression using integers, addition, and
     multiplication, such as ``2*3+8``.

#. Write code to convert text into *hAck3r*, using regular expressions
   and substitution, where
   ``e`` |rarr| ``3``,
   ``i`` |rarr| ``1``,
   ``o`` |rarr| ``0``,
   ``l`` |rarr| ``|``,
   ``s`` |rarr| ``5``,
   ``.`` |rarr| `` 5w33t!``,
   ``ate`` |rarr| ``8``.
   Normalise the text to lowercase before converting it.
   Add more substitutions of your own.  Now try to map
   ``s`` to two different values: ``$`` for word-initial ``s``,
   and ``5`` for word-internal ``s``.
   
#. Write code to read a file and print it in reverse, so that the last
   line is listed first.

#. Write code to access a favorite webpage and extract some text from it.
   For example, access a weather site and extract the forecast top
   temperature for your town or city today.

#. Read the Wikipedia entry on the *Soundex Algorithm*.  Implement this
   algorithm in Python.

--------------
Accessing NLTK
--------------

NLTK consists of a set of Python *modules*, each of which defines
classes and functions related to a single data structure or task.
Before you can use a module, you must ``import`` its contents.  The
simplest way to import the contents of a module is to use the ``from
module import *`` command.  For example, to import the contents of the
``nltk_lite.util`` module, which is discussed in this chapter, type:

  >>> from nltk_lite.utilities import *
  >>>

A disadvantage of this style of import statement is that it does not
specify what objects are imported; and it is possible that some of the
import objects will unintentionally cause conflicts.  To avoid this
disadvantage, you can explicitly list the objects you wish to import.
For example, as we saw earlier, we can import the ``re_show`` function
from the ``nltk_lite.util`` module as follows:

  >>> from nltk_lite.utilities import re_show
  >>>

Another option is to import the module itself, rather than
its contents.  Now its contents can then be accessed
using *fully qualified* dotted names:

  >>> from nltk_lite import utilities
  >>> utilities.re_show('green', sent)
  colorless {green} ideas sleep furiously
  >>>

For more information about importing, see any Python textbook.

NLTK is distributed with several corpora, listed in the introduction.
Many of these corpora are supported by the NLTK ``corpora`` module.
First we import the Gutenberg corpus (a selection of texts from
the Project Gutenberg electronic text archive).

  >>> from nltk_lite.corpora import gutenberg
  >>> gutenberg.items
  ['austen-emma', 'austen-persuasion', 'austen-sense', 'bible-kjv',
   'blake-poems', 'blake-songs', 'chesterton-ball', 'chesterton-brown',
   'chesterton-thursday', 'milton-paradise', 'shakespeare-caesar',
   'shakespeare-hamlet', 'shakespeare-macbeth', 'whitman-leaves']
  >>>

We access the text content using a special Python construct called an
*iterator*.  It produces a stream of words, which we can access using
the syntax ``for item in iterator``, as shown below:

  >>> count = 0
  >>> for word in gutenberg.raw('whitman-leaves'):
  ...     count += 1
  >>> print count
  154873
  >>>

NLTK-Lite also includes the Brown Corpus, the first million word,
part-of-speech tagged electronic corpus of English, created in 1961 at
Brown University.  Each of the sections ``a`` through ``r`` represents
a different genre.

  >>> from nltk_lite.corpora import brown
  >>> brown.items
  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'r']
  >>>

We can extract individual sentences from the corpus iterator using the
``extract()`` function:

  >>> from nltk_lite.corpora import extract
  >>> print extract(0, brown.raw())
  ['The', 'Fulton', 'County', 'Grand', 'Jury', 'said', 'Friday', 'an',
   'investigation', 'of', "Atlanta's", 'recent', 'primary', 'election',
   'produced', '``', 'no', 'evidence', "''", 'that', 'any', 'irregularities',
   'took', 'place', '.']
  >>>

We can also access the tagged text using the ``brown.tagged()`` method:

  >>> print extract(0, brown.tagged())
  [('The', 'at'), ('Fulton', 'np-tl'), ('County', 'nn-tl'), ('Grand', 'jj-tl'),
   ('Jury', 'nn-tl'), ('said', 'vbd'), ('Friday', 'nr'), ('an', 'at'),
   ('investigation', 'nn'), ('of', 'in'), ("Atlanta's", 'np$'), ('recent', 'jj'),
   ('primary', 'nn'), ('election', 'nn'), ('produced', 'vbd'), ('``', '``'),
   ('no', 'at'), ('evidence', 'nn'), ("''", "''"), ('that', 'cs'),
   ('any', 'dti'), ('irregularities', 'nns'), ('took', 'vbd'), ('place', 'nn'),
   ('.', '.')]
  >>>

NLTK-Lite includes a 10% fragment of the Wall Street Journal section
of the Penn Treebank.  This can be accessed using ``treebank.raw()``
for the raw text, and ``treebank.tagged()`` for the tagged text.

  >>> from nltk_lite.corpora import treebank
  >>> print extract(0, treebank.parsed())
  (S:
    (NP-SBJ:
      (NP: (NNP: 'Pierre') (NNP: 'Vinken'))
      (,: ',')
      (ADJP: (NP: (CD: '61') (NNS: 'years')) (JJ: 'old'))
      (,: ','))
    (VP:
      (MD: 'will')
      (VP:
        (VB: 'join')
        (NP: (DT: 'the') (NN: 'board'))
        (PP-CLR:
          (IN: 'as')
          (NP: (DT: 'a') (JJ: 'nonexecutive') (NN: 'director')))
        (NP-TMP: (NNP: 'Nov.') (CD: '29'))))
    (.: '.'))
  >>>

NLTK contains some simple chatbots, which will try to talk
intelligently with you.  You can access the famous Eliza
chatbot using ``from nltk_lite.chat import eliza``, then
run ``eliza.demo()``.  The other chatbots are called
``iesha`` (teen anime talk),
``rude`` (insulting talk), and
``zen`` (gems of Zen wisdom),
and were contributed by other students who have used NLTK.

Exercises
---------

#. Use the corpus module to read ``austin-persuasion.txt``.
   How many words does this book have?

#. Use the Brown corpus reader ``brown.raw()`` to access some sample
   text in two different genres.

#. Try running the various chatbots.  How *intelligent* are these programs?
   Take a look at the program code and see if you can
   discover how it works.  You can find the code online at:
   ``http://nltk.sourceforge.net/lite/nltk_lite/chat/``.

---------------
Further Reading
---------------

Guido Van Rossum (2003).
*An Introduction to Python*,
Network Theory Ltd.

Guido Van Rossum (2003).
*The Python Language Reference*,
Network Theory Ltd.

Guido van Rossum (2005).
*Python Tutorial*
http://docs.python.org/tut/tut.html

A.M. Kuchling.
*Regular Expression HOWTO*,
http://www.amk.ca/python/howto/regex/

*Python Documentation*
http://docs.python.org/

Allen B. Downey, Jeffrey Elkner and Chris Meyers ()
*How to Think Like a Computer Scientist: Learning with Python*
http://www.ibiblio.org/obp/thinkCSpy/

.. include:: footer.txt
