.. -*- mode: rst -*-
.. include:: ../definitions.txt

.. _chap-advanced-parsing:

===================
8. Advanced Parsing
===================

------------
Introduction
------------

[Summary of previous parsing chapter; terminology, key concepts, existence of shortcomings.]

As we have seen, parsing builds trees over sentences, according to a
phrase structure grammar.  However, as the coverage of the grammar
increases and the length of the input sentence grows, the number of
parse trees grows rapidly.  In fact, it grows at an astronomical rate.

Let's explore this issue with the help of a simple example.
The word `fish`:lx: is both a noun and a verb.  We can make up the
nonsense sentence `fish fish fish`:lx:, meaning *fish like to fish for
other fish*.  (Try this with `police`:lx: if you prefer something more
sensible.)  Here is a toy grammar for the 'fish' sentences.

    >>> from nltk_lite.parse import cfg, chart
    >>> grammar = cfg.parse_grammar("""
    ... S -> NP V NP
    ... NP -> NP Sbar
    ... Sbar -> NP V | V NP
    ... NP -> 'fish'
    ... V -> 'fish'
    ... """)

Now we can try parsing a longer sentence, `fish fish fish fish
fish`:lx:, which amongst other things, means *fish that are fished by
other fish are in the habit of fishing fish themselves*. We use the
|NLTK| chart parser, which is presented later on in this chapter.
This sentence has four readings.

    >>> tokens = ["fish"] * 5
    >>> cp = chart.ChartParse(grammar, chart.TD_STRATEGY)
    >>> for tree in cp.get_parse_list(tokens):
    ...     print tree
    (S:
      (NP: (NP: 'fish') (Sbar: (V: 'fish') (NP: 'fish')))
      (V: 'fish')
      (NP: 'fish'))
    (S:
      (NP: (NP: 'fish') (Sbar: (NP: 'fish') (V: 'fish')))
      (V: 'fish')
      (NP: 'fish'))
    (S:
      (NP: 'fish')
      (V: 'fish')
      (NP: (NP: 'fish') (Sbar: (V: 'fish') (NP: 'fish'))))
    (S:
      (NP: 'fish')
      (V: 'fish')
      (NP: (NP: 'fish') (Sbar: (NP: 'fish') (V: 'fish'))))

As the length of this sentence goes up (3, 5, 7, ...) we get the
following numbers of parse trees: 1; 4; 20; 112; 672; 4,224; 27,456;
183,040; 1,244,672; 8,599,552; 60,196,864; 426,008,576.  The last of
these |mdash| a figure of the order of 10\ `8`:superscript: |mdash| is
for a sentence of length 23, the average length of sentences in the
WSJ section of Penn Treebank.  (This growth is *super-exponential*
(equal to 2\ `n`:superscript:\ .C(n+1), where C(n) is the *n*\ th
Catalan number, (2n)!/(n!(n+1)!).)  No practical |NLP| system could
construct 10\ `8`:superscript: trees for a typical sentence, much less
choose the appropriate one in the context.  It's clear that humans
don't do this either!
Note that the problem is not with our choice of example. 
[ChurchPatil1982]_ point out that the syntactic ambiguity of `pp`:gc:
attachment in sentences like pp_ also grows in proportion to the Catalan
numbers.

.. _pp:
.. ex:: Put the block in the box on the table.

So much for structural ambiguity; what about lexical ambiguity?
As soon as we try to construct a broad-coverage grammar, we
are forced to make lexical entries highly ambiguous for their part of
speech.  In a toy grammar, `a`:lx: is only a determiner, `dog`:lx: is
only a noun, and `runs`:lx: is only a verb.  However, in a
broad-coverage grammar, `a` is also a noun (e.g. `part a`:lx:),
`dog`:lx: is also a verb (meaning to follow closely), and `runs`:lx:
is also a noun (e.g. `ski runs`:lx:).  In fact, all words can be
referred to by name: e.g. `the verb 'ate' is spelled with three
letters`:lx:; in speech we do not need to supply quotation marks.
Furthermore, it is possible to *verb* most nouns.  Thus a parser for a
broad-coverage grammar will be overwhelmed with ambiguity.  Even
complete gibberish will often have a reading, e.g. `the a are of
I`:lx:.  As [Abney1996]_ has pointed out, this is not word salad but a
grammatical noun phrase, in which `are`:lx: is a noun meaning a
hundredth of a hectare (or 100 sq m), and `a`:lx: and `I`:lx: are
nouns designating coordinates, as shown in Figure are_.

.. _are:
.. figure:: ../images/are.png
   :scale: 20

   The a are of I

|nopar|
Even though this phrase is unlikely, it is still grammatical and a
a broad-coverage parser should be able to construct a parse tree
for it.  Similarly, sentences which seem to be
unambiguous, such as `John saw Mary`:lx:, turn out to have other
readings we would not have anticipated (as Abney explains).  This
ambiguity is unavoidable, and leads to horrendous inefficiency in
parsing seemingly inoccuous sentences. 

Let's look more closely at this issue of efficiency.
The top-down recursive-descent parser presented
in Chapter chap-parse_ can be very inefficient, since it often builds
and discards the same sub-structure many times over.  We see this
in Figure parser-problem_, where a phrase `the block`:lx: is identified
as a noun phrase several times, and where this information is discarded
each time we backtrack.

.. Note::
   You should try the recursive-descent parser demo if you haven't
   already:
   
   .. doctest-ignore::
       >>> from nltk_lite.draw import srparser
       >>> srparser.demo()

.. table:: parser-problem

   +-----------------------------+-------------------------+
   | a. Initial stage            | b. Backtracking         |
   |                             |                         |
   | |findtheblock1|             | |findtheblock2|         |
   +-----------------------------+-------------------------+
   | c. Failing to match `on`:lx:| d. Completed parse      |
   |                             |                         |
   | |findtheblock3|             | |findtheblock4|         |
   +-----------------------------+-------------------------+

   Backtracking and Repeated Parsing of Subtrees

.. |findtheblock1| image:: ../images/findtheblock1.png
   :scale: 85
.. |findtheblock2| image:: ../images/findtheblock2.png
   :scale: 85
.. |findtheblock3| image:: ../images/findtheblock3.png
   :scale: 85
.. |findtheblock4| image:: ../images/findtheblock4.png
   :scale: 85


In this chapter, we will present two independent methods for dealing with ambiguity.
The first is `chart parsing`:em:, which uses the algorithmic technique
of dynamic programming to derive the parses of an ambiguous
sentence more `efficiently`:em:.  The second is
`probabilistic parsing`:em:, which allows us to `rank`:em:
the parses of an ambiguous sentence on the basis of evidence from corpora.

.. _chart-parsing:

-------------
Chart Parsing
-------------

`chart parsing`:topic:

The simple parsers discussed in Chapter chap-parse_ have major
limitations.  The bottom-up shift-reduce parser can only find one
parse, and it often fails to find a parse even if one exists.  As just
pointed out, the top-down recursive-descent parser can be very
inefficient, and if the grammar contains left-recursive rules, it can
enter into an infinite loop.  In order to address these problems of
completeness and efficiency, we will apply the algorithm design technique
of `dynamic programming`:idx: to the parsing problem.  As we saw in
Section sec-dynamic-programming_, dynamic programming
stores intermediate results and re-uses them when appropriate,
achieving significant efficiency gains.

Well-formed Substring Tables
----------------------------

We start off by defining a simple grammar.

    >>> from nltk_lite.parse import cfg
    >>> grammar = cfg.parse_grammar("""
    ... S -> NP VP
    ... PP -> P NP
    ... NP -> Det N | NP PP
    ... VP -> V NP | VP PP
    ... Det -> 'the'
    ... N -> 'kids' | 'box' | 'floor'
    ... V -> 'opened' 
    ... P -> 'on' 
    ... """)

As you can see, this grammar allows the `vp`:gc: 
`opened the box on the floor`:lx: to be analysed in two ways,
depending on where the `pp`:gc: is attached.

.. ex::
  .. ex::
    .. tree:: (VP (V opened)(NP (NP (Det the) (N box))(PP (P on (NP (Det the)(N floor))))))
 
  .. ex::
    .. tree:: (VP (VP (V opened)(NP (Det the) (N box)))(PP (P on (NP (Det the)(N floor)))))

Dynamic programming allows us to build the `pp`:gc: `on the floor`:lx:
just once.  The first time we build it we save it in a table, then we look it
up when we need to use it as a subconstituent of either the object `np`:gc: or
the higher `vp`:gc:. This table is known as a
`well-formed substring table`:dt: (or |WFST| for short). 
We will show how to construct the |WFST| bottom-up so as to systematically record
what syntactic constituents have been found.

Let's set our input to be the sentence `the kids opened the box on the
floor`:lx:. It is helpful to think of the input as being indexed like a Python
list. We have illustrated this in Figure stringpos_.

.. _stringpos:
.. figure:: ../images/chart_positions.png
   :scale: 25

   Slice Points in the Input String

|nopar|
This allows us to say that, for instance, the word `opened`:lx: spans
(2, 3) in the input.  This is reminiscent of the slice notation:

    >>> tokens = ["the", "kids", "opened", "the", "box", "on", "the", "floor"]
    >>> tokens[2:3]
    ['opened']

|nopar|
In a |WFST|, we record the position of the words
by filling in cells in a triangular matrix:
the vertical axis will denote the start position of a substring,
while the horizontal axis will denote the end position
(thus `opened`:lx: will appear in the cell with coordinates (2, 3)).
To simplify this presentation, we will assume each word has a unique
lexical category, and we will store this (not the word) in the matrix.
So cell (2, 3) will contain the entry `v`:gc:.
More generally, if our input string is
`a`:sub:`1`\ `a`:sub:`2`\ |cdots|\ `a`:sub:`n`, and our grammar
contains a rule of the form *A* |rarr| `a`:sub:`i`, then we add *A* to
the cell (`i`-1, `i`).

So, for every word in ``tokens``, we can look up in our grammar what
category it belongs to.

    >>> grammar.productions(rhs=tokens[2])
    [V -> 'opened']

|nopar| 
For our |WFST|, we create an *n-1* |times| *n-1* matrix
as a list of lists in Python, and initialize it
with the lexical categories of each token, in the ``init_wfst()``
function in Listing wfst_.  We also define a utility function ``display()``
to pretty-print the |WFST| for us.
As expected, there is a `v`:gc: in cell (2, 3).

.. pylisting:: wfst
   :caption: Acceptor Using Well-Formed Substring Table (based on |CYK| algorithm)

    def init_wfst(tokens, grammar):
        numtokens = len(tokens)
        wfst = [['.' for i in range(numtokens+1)] for j in range(numtokens+1)]
        for i in range(numtokens):
            productions = grammar.productions(rhs=tokens[i])
            wfst[i][i+1] = productions[0].lhs()
        return wfst
    def complete_wfst(wfst, tokens, trace=False):
        index = {}
        for prod in grammar.productions():
            index[prod.rhs()] = prod.lhs()
        numtokens = len(tokens)
        for span in range(2, numtokens+1):
            for start in range(numtokens+1-span):
                end = start + span
                for mid in range(start+1, end):
                    nt1, nt2 = wfst[start][mid], wfst[mid][end]
                    if (nt1,nt2) in index:
                        if trace:
                            print "[%s] %3s [%s] %3s [%s] ==> [%s] %3s [%s]" % \
                            (start, nt1, mid, nt2, end, start, index[(nt1,nt2)], end)
                        wfst[start][end] = index[(nt1,nt2)]
        return wfst
    def display(wfst, tokens):
        print '\nWFST ' + ' '.join([("%-4d" % i) for i in range(1, len(wfst))])
        for i in range(len(wfst)-1):
            print "%d   " % i,
            for j in range(1, len(wfst)):
                print "%-4s" % wfst[i][j],
            print

    >>> wfst0 = init_wfst(tokens, grammar)
    >>> display(wfst0, tokens)
    WFST 1    2    3    4    5    6    7    8   
    0    Det  .    .    .    .    .    .    .
    1    .    N    .    .    .    .    .    .
    2    .    .    V    .    .    .    .    .
    3    .    .    .    Det  .    .    .    .
    4    .    .    .    .    N    .    .    .
    5    .    .    .    .    .    P    .    .
    6    .    .    .    .    .    .    Det  .
    7    .    .    .    .    .    .    .    N
    >>> wfst1 = complete_wfst(wfst0, tokens)
    >>> display(wfst1, tokens)
    WFST 1    2    3    4    5    6    7    8   
    0    Det  NP   .    .    S    .    .    S
    1    .    N    .    .    .    .    .    .
    2    .    .    V    .    VP   .    .    VP
    3    .    .    .    Det  NP   .    .    NP
    4    .    .    .    .    N    .    .    .
    5    .    .    .    .    .    P    .    PP
    6    .    .    .    .    .    .    Det  NP
    7    .    .    .    .    .    .    .    N

Returning to our tabular representation, given that we have `det`:gc:
in cell (0, 1), and `n`:gc: in cell (1, 2), what should we put into
cell (0, 2)? In other words, what syntactic category derives
`the kids`:lx:? We have already established that `Det`:gc:
derives `the`:lx: and `n`:gc: derives `kids`:lx:, so we need to find a
rule of the form *A* |rarr| `det`:gc: `n`:gc:, that is, a rule whose
right hand side matches the categories in the cells we have already
found.  From the grammar, we know that we can enter `np`:gc: in cell (0,2).

More generally, we can enter *A* in (`i, j`) if there
is a production *A* |rarr| *B* *C*, and we find
nonterminal *B* in (`i, k`) and *C* in (`k, j`).
Listing wfst_ uses this inference step to complete the |WFST|.

.. note::
   To help us easily retrieve production rules by their right hand
   sides, we create an index for the grammar.
   This is an example of a space-time trade-off: we do a reverse lookup
   on the grammar, instead of having to check through entire list of
   productions each time we want to look up via the right hand side.

We conclude that there is a parse for the whole input string once
we have constructed an `s`:gc: node that covers the whole input, from
position `0` to position `8`; i.e., we can conclude that `s`:gc:
|DoubleRightArrow|\ * `a`:sub:`1`\ `a`:sub:`2`\ |cdots|\ `a`:sub:`n`.

Notice that we have not used any built-in parsing functions here.
We've implemented a primitive chart parser from the ground up.

Charts
------

By setting ``trace`` to ``True`` when calling the function ``complete_wfst()``, we get 
additional output.

    >>> wfst1 = complete_wfst(wfst0, tokens, trace=True)
    [0] Det [1]   N [2] ==> [0]  NP [2]
    [3] Det [4]   N [5] ==> [3]  NP [5]
    [6] Det [7]   N [8] ==> [6]  NP [8]
    [2]   V [3]  NP [5] ==> [2]  VP [5]
    [5]   P [6]  NP [8] ==> [5]  PP [8]
    [0]  NP [2]  VP [5] ==> [0]   S [5]
    [3]  NP [5]  PP [8] ==> [3]  NP [8]
    [2]   V [3]  NP [8] ==> [2]  VP [8]
    [2]  VP [5]  PP [8] ==> [2]  VP [8]
    [0]  NP [2]  VP [8] ==> [0]   S [8]

|nopar| For example, this says that since we found ``Det`` at
``wfst[0][1]`` and ``N`` at ``wfst[1][2]``, we can add ``NP`` to
``wfst[0][2]``.
The same information can be represented in a directed acyclic graph,
as shown in Figure chartinit_\ (a). This graph is usually called a `chart`:dt:.
Figure chartinit_\ (b) is the corresponding graph representation, where
we add a new edge labeled `np`:gc: to cover the input from `0` to `2`.

.. table:: chartinit

   +---------------------------------------------------------+
   | a. Initialized WFST                                     |
   | |chart_init0|                                           |
   +---------------------------------------------------------+
   | b. Adding an `np`:gc: Edge                              |
   | |chart_init1|                                           |
   +---------------------------------------------------------+

   A Graph Representation for the WFST

.. |chart_init0| image:: ../images/chart_init0.png
   :scale: 25

.. |chart_init1| image:: ../images/chart_init1.png
   :scale: 25

(Charts are more general than the |WFST|\ s we have seen, since they
can hold multiple hypotheses for a given span.)

A |WFST| is a data structure that can be used by a variety of parsing
algorithms. The particular method for constructing a |WFST| that we
have just seen and has some shortcomings.
First, as you can see, the |WFST| is not itself a parse tree, so the technique is
strictly speaking `recognizing`:dt: that a sentence is admitted by a
grammar, rather than parsing it.
Second, it requires every non-lexical grammar production to be
`binary`:em: (see Section sec-normal-forms_).
Although it is possible to convert an arbitrary |CFG| into this form,
we would prefer to use an approach without such a requirement.
Third, as a bottom-up approach it is potentially wasteful, being
able to propose constituents in locations that would not be licensed by
the grammar.
Finally, the |WFST| did not represent the structural ambiguity in
the sentence (i.e. the two verb phrase readings).  The `vp`:gc:
in cell (`2,8`) was actually entered twice, once for a `v np`:gc:
reading, and oce for a `vp pp`:gc: reading.
In the next section we will address these issues.

Exercises
---------

1. |soso| Read about string edit distance and the Levenshtein Algorithm.
   Try the implementation provided in ``nltk_lite.utilities.edit_dist``.
   How is this using dynamic programming?  Does it use the bottom-up or
   top-down approach?

#. |soso| Consider the algorithm in Listing wfst_.  Can you explain why
   parsing context-free grammar is proportional to `n`:sup:`3`\ ?

#. |soso| Modify the functions ``init_wfst()`` and ``complete_wfst()`` so
   that the contents of each cell in the |WFST| is a set of
   non-terminal symbols rather than a single non-terminal.
   
#. |hard| Modify the functions ``init_wfst()`` and ``complete_wfst()`` so
   that when a non-terminal symbol is added to a cell in the |WFST|, it includes
   a record of the cells from which it was derived. Implement a
   function which will convert a |WFST| in this form to a parse tree.

-------------
Active Charts
-------------

One important aspect of the tabular approach to parsing can be seen more
clearly if we look at the graph representation: given our grammar, there are two
different ways to derive a top-level `vp`:gc: for the input, as shown in
Table chartnp_\ (a,b).
In our graph representation, we simply combine the
two sets of edges to yield Table chartnp_\ (c).

.. table:: chartnp

   +-------------------------------------------------+
   | a. `vp`:gc: |rarr| `v`:gc: `np`:gc:             |
   | |chartnp0|                                      |
   +-------------------------------------------------+
   | b. `vp`:gc: |rarr| `vp`:gc: `pp`:gc:            |
   | |chartnp1|                                      |
   +-------------------------------------------------+
   | c. Merged Chart                                 |
   | |chartnp2|                                      |
   +-------------------------------------------------+

   Combining Multiple Parses in a Single Chart

.. |chartnp0| image:: ../images/chart_np0.png
   :scale: 25

.. |chartnp1| image:: ../images/chart_np1.png
   :scale: 25

.. |chartnp2| image:: ../images/chart_np2.png
   :scale: 25

|nopar| However, we cannot necessarily read off from the |WFST| what
the justification was for adding a specific edge. For example, in
chartnp_\ (b), the longest `vp`:gc: edge might be interpreted as having
arisen by virtue of a rule `vp`:gc: |rarr| `v np pp`:gc:. Unlike
phrase structure trees, a |WFST| does not encode a relation of
immediate dominance. In order to make such information available, we
can label edges not just with a non-terminal category, but with the
whole production which justified the addition of the edge. This is
illustrated in Figure chartprods_.

.. _chartprods:
.. figure:: ../images/chart_prods.png
   :scale: 25
   
   Chart Annotated with Productions

In general, a parser hypothesizes constituents based on the grammar
and its current knowledge about the tokens it has seen and the
constituents it has already found.  Any constituent that is consistent
with the current knowledge can be hypothesized; but many of these
hypothesized constituents may not be used in complete parses. We can
view a |WFST| as recording these hypotheses.

All of the edges that we've seen so far represent complete
constituents.  However, it can also be helpful to hypothesize
`incomplete`:dt: constituents.  For example, much of the work done by a
parser in processing the production *VP* |rarr| *V* *NP* is also useful
when processing *VP* |rarr| *V* *NP* *PP*.
Thus, we might want to record the
hypothesis that "the `v`:gc: constituent `likes`:lx: forms the beginning of a
`vp`:gc:."

We can record hypotheses of this form by adding a `dot`:dt: to the
edge's right hand side.  The children to the left of the dot specify
what children the constituent starts with; and the children to the
right of the dot specify what children still need to be found in order
to form a complete constituent.  For example, the edge in the
Figure dottededge_ records the hypothesis that "a `vp`:gc: starts with the `v`:gc:
`likes`:lx:, but still needs an `np`:gc: to become complete":

.. _dottededge:
.. figure:: ../images/chart_intro_dottededge.png
   :scale: 30
   
   Chart Containing Incomplete VP Edge

|nopar| These `dotted edges`:dt: are used to record all of the hypotheses that a
chart parser makes about constituents in a sentence.  Formally
a dotted edge [`A` |rarr| `c`:sub:`1` |dots| `c`:sub:`d` |dot| `c`:sub:`d+1` |dots| `c`:sub:`n`, (*i*, *j*)] 
records the hypothesis that a constituent of type `A` with span (`i, j`)
starts with children `c`:sub:`1` |dots| `c`:sub:`d`, but still
needs children `c`:sub:`d+1` |dots| `c`:sub:`n` to be complete
(`c`:sub:`1` |dots| `c`:sub:`d` and `c`:sub:`d+1` |dots| `c`:sub:`n` may be empty).
If `d = n`:math:, then `c`:sub:`d+1` |dots| `c`:sub:`n` is
empty and the edge represents a complete constituent and is called
a `complete edge`:dt:.  Otherwise, the edge represents an incomplete
constituent, and is called an `incomplete edge`:dt:.  In Figure
chart_terms_\ (a), [`vp`:gc: |rarr| `v`:gc: `np`:gc: |dot|, (1, 3)] is a
complete edge, and [`vp`:gc: |rarr| `v`:gc: |dot| `np`:gc:, (1, 2)] is
an incomplete edge.

If `d = 0`:math:, then `c`:sub:`1` |dots| `c`:sub:`n` is empty
and the edge is called a `self-loop edge`:dt:.  
This is illustrated in Table chart_terms_\ (b).
If a complete edge spans the entire sentence, and has the grammar's
start symbol as its left-hand side, then the edge is called a `parse
edge`:dt:, and it encodes one or more parse trees for the sentence.  In
Table chart_terms_\ (c), [`s`:gc: |rarr| `np`:gc: `vp`:gc: |dot|, (0, 3)] is a parse edge.

.. table:: chart_terms

   +--------------------------+-------------------------+-------------------------+
   | a. Incomplete Edge       | b. Self Loop Edge       | c. Parse Edge           |
   | |chart_intro_incomplete| | |chart_intro_selfloop|  | |chart_intro_parseedge| |
   +--------------------------+-------------------------+-------------------------+

   Chart Terminology

.. |chart_intro_incomplete| image:: ../images/chart_intro_incomplete.png
   :scale: 25

.. |chart_intro_selfloop| image:: ../images/chart_intro_selfloop.png
   :scale: 25

.. |chart_intro_parseedge| image:: ../images/chart_intro_parseedge.png
   :scale: 25

The Chart Parser
----------------

To parse a sentence, a chart parser first creates an empty chart
spanning the sentence.  It then finds edges that are licensed by its
knowledge about the sentence, and adds them to the chart one at a time
until one or more parse edges are found.  The edges that it adds can
be licensed in one of three ways:
      
1. The *input* can license an edge.  In particular, each word `w`:sub:`i`
   in the input licenses the complete edge [`w`:sub:`i` |rarr|
   |dot|, (*i*, *i*\ +1)].

#. The *grammar* can license an edge.  In particular, each grammar
   production A |rarr| |alpha| licenses the self-loop edge [*A* |rarr|
   |dot| |alpha|, (*i*, *i*)] for every *i*, 0 |leq| *i* < *n*.

#. The *current chart contents* can license an edge.
          
However, it is not wise to add `all`:em: licensed edges to the chart,
since many of them will not be used in any complete parse.  For
example, even though the edge in the following chart is licensed (by
the grammar), it will never be used in a complete parse:

.. _uselessedge:        
.. figure:: ../images/chart_useless_edge.png
   :scale: 30

   Chart Containing Redundant Edge

Chart parsers therefore use a set of `rules`:dt: to heuristically decide
when an edge should be added to a chart.  This set of rules, along
with a specification of when they should be applied, forms a
`strategy`:dt:.

The Fundamental Rule
--------------------

One rule is particularly important, since it is used by every chart
parser: the `Fundamental Rule`:dt:.\ [#]_  
This rule is used to combine an
incomplete edge that's expecting a nonterminal *B* with a following, complete
edge whose left hand side is *B*.

.. _fundamental-rule:
.. ex::
   `Fundamental Rule`:dt:
   
   .. parsed-literal::
   
    If the chart contains the edges
      [*A* |rarr| |alpha| |dot| *B* |beta| , (*i*, *j*\ )]
      [*B* |rarr| |gamma| |dot| , (*j*, *k*\ )]
    then add the new edge
      [*A* |rarr| |alpha| *B* |dot| |beta| , (*i*, *k*)]
    where |alpha|, |beta|, and |gamma| are (possibly empty) sequences
    of terminals or non-terminals

Note that the dot has moved one place to the right, and the span of this new edige is the combined
span of the other two.  Note also that in adding this new edge we do not remove the other two,
because they might be used again.

A somewhat more intuitive version of the operation of the Fundamental
Rule can be given using chart diagrams. Thus, if we have a chart of
the form shown in Table fr_\ (a),
then we can add a new complete edge as shown in Table fr_\ (b).

.. table:: fr

   +---------------+--------------+
   | a. Input      | b. Output    |
   | |chart_fr1|   | |chart_fr2|  |
   +---------------+--------------+

   Fundamental Rule

.. |chart_fr1| image:: ../images/chart_fr1.png
   :scale: 30

.. |chart_fr2| image:: ../images/chart_fr2.png
   :scale: 30


.. [#] The Fundamental Rule corresponds to the Completer
   function in the Earley algorithm; cf. [Jurafsky2000SLP]_.


Bottom-Up Parsing
-----------------

As we saw in Chapter chap-parse_, bottom-up parsing starts from the
input string, and tries to find sequences of words and phrases that
correspond to the *right hand* side of a grammar production. The
parser then replaces these with the left-hand side of the production,
until the whole sentence is reduced to an `S`:gc:.  Bottom-up chart
parsing is an extension of this approach in which hypotheses about
structure are recorded as edges on a chart. In terms of our earlier
terminology, bottom-up chart parsing can be seen as a parsing
strategy; in other words, bottom-up is a particular choice of
heuristics for adding new edges to a chart. 

The general procedure for chart parsing is
inductive: we start with a base case, and then show how we can move
from a given state of the chart to a new state. Since we are working
bottom-up, the base case for our induction will be determined by the
words in the input string, so we add new edges for each word.  Now,
for the induction step, suppose the chart contains an edge labeled
with constituent *A*. Since we are working bottom-up, we want to build
constituents which can have an *A* as a daughter. In other words, we
are going to look for rules of the form *B* |rarr| *A* |beta| and use
these to label new edges.

Let's look at the procedure a bit more formally.  To create a
bottom-up chart parser, we add to the Fundamental Rule two new rules:
the `Bottom-Up Initialization Rule`:dt:; and the `Bottom-Up Predict
Rule`:dt:.
The Bottom-Up Initialization Rule says to add all edges licensed by
the input.

.. _bottom-up-initialization-rule:
.. ex::
   `Bottom-Up Initialization Rule`:dt:

   .. parsed-literal::

    For every word w\ :subscript:`i` add the edge
      [`w`:subscript:`i` |rarr|  |dot| , (*i*, *i*\ +1)]

Table bu-init-chart_\ (a) illustrates this rule using the chart notation,
while Table bu-init-chart_\ (b) shows the bottom-up
initialization for the input `Lee likes coffee`:lx:.

.. table:: bu-init-chart

   +------------------------------+----------------------------+
   | a. Generic                   | b. Example                 |
   | |chart_bu_init|              | |chart_bu_ex1|             |
   +------------------------------+----------------------------+

   Bottom-Up Initialization Rule

.. |chart_bu_init| image:: ../images/chart_bu_init.png
   :scale: 30

.. |chart_bu_ex1| image:: ../images/chart_bu_ex1.png
   :scale: 30

Notice that the dot on the right hand side of these productions
is telling us that we have complete edges for the lexical items. By
including this information, we
can give a uniform statement of how the Fundamental Rule operates in
Bottom-Up parsing, as we will shortly see.

Next, suppose the chart contains a complete edge *e* whose
left hand category is *A*. Then the Bottom-Up Predict Rule requires the
parser to add a self-loop edge at the left boundary of *e*
for each grammar production whose right hand side begins with category
*A*.

.. _bottom-up-predict-rule:
.. ex::
   `Bottom-Up Predict Rule`:dt:

   .. parsed-literal::

    If the chart contains the complete edge
      [*A* |rarr| |alpha| |dot| , (*i*, *j*\ )]
    and the grammar contains the production
      *B* |rarr| *A* |beta|
    then add the self-loop edge
      [*B* |rarr|  |dot| *A* |beta| , (*i*, *i*\ )]

Graphically, if the chart looks as in Figure bu-predict-chart_\ (a),
then the Bottom-Up Predict Rule tells the parser to augment the chart
as shown in Figure bu-predict-chart_\ (b).

.. table:: bu-predict-chart

   +----------------------------+--------------------------+
   | a. Input                   | b. Output                |
   | |chart_bu_predict1|        | |chart_bu_predict2|      |
   +----------------------------+--------------------------+

   Bottom-Up Prediction Rule

.. |chart_bu_predict1| image:: ../images/chart_bu_predict1.png
   :scale: 30

.. |chart_bu_predict2| image:: ../images/chart_bu_predict2.png
   :scale: 30

To continue our earlier example, let's suppose that our grammar
contains the following lexical productions:

.. ex::
   .. parsed-literal::

     `np`:gc: |rarr| `Lee`:lx: | `coffee`:lx:
     `v`:gc: |rarr| `likes`:lx:

|nopar| This allows us to add three self-loop edges to the chart, as
shown in Figure buex2_.

.. _buex2:
.. figure:: ../images/chart_bu_ex2.png
   :scale: 30

Once we have a chart like Figure bu-predict-chart_\ (b), we can use the
Fundamental Rule to add an edge where we have "moved the dot" one
position to the right.

.. _bufr:
.. figure:: ../images/chart_bu_fr.png
   :scale: 30
        
Figure buex3_ illustrates this for our running example (we have
omitted the self-loop edges for simplicity.)

.. _buex3:
.. figure:: ../images/chart_bu_ex3.png
   :scale: 30

|nopar| We will now be able to add new self-loop edges such as 
[`s`:gc: |rarr|  |dot| `np`:gc: `vp`:gc:, (0, 0)] and
[`vp`:gc: |rarr|  |dot| `vp`:gc: `np`:gc:, (1, 1)], and use these to
build more complete edges.

Using the three rules just presented, we can parse a sentence as shown in
bottom-up-strategy_.

.. _bottom-up-strategy:
.. ex::
   `Bottom-Up Strategy`:dt:

   .. parsed-literal::

    Create an empty chart spanning the sentence. 
    Apply the Bottom-Up Initialization Rule to each word. 
    Until no more edges are added: 
      Apply the Bottom-Up Predict Rule everywhere it applies. 
      Apply the Fundamental Rule everywhere it applies. 
    Return all of the parse trees corresponding to the parse edges in the chart. 

|NLTK| provides a useful interactive tool for visualizing the way in which charts
are built; it can be invoked as follows:

.. doctest-ignore::
    >>> from nltk_lite.draw.chart import demo
    >>> demo()


The tool comes with a pre-defined input string and grammar, but both
of these can be readily modified with options inside the *Edit* menu.
Figure budemo1_ illustrates a window after the grammar has been updated:

.. _budemo1:       
.. figure:: ../images/chart_demo1.png

   Modifing the `demo()` grammar

.. Note:: To get the symbol |DoubleRightArrow| illustrated in Figure
   budemo1_. you just have to type the keyboard characters `'->'`.


Figure budemo2_ illustrates the tool interface. In order to invoke a
rule, you simply click one of the green buttons at the bottom of the window.
We show the state of the chart on the input `Lee
likes coffee`:lx: after three applications of the Bottom-Up
Initialiation Rule, followed by successive applications of the Bottom-Up Predict
Rule and the Fundamental Rule. 

.. _budemo2:       
.. figure:: ../images/chart_demo2.png
   :scale: 70

   Incomplete chart for `Lee likes coffee`:lx: 

Notice that in the topmost pane of the window, there is a partial tree
showing that we have constructed an `s`:gc: with an `np`:gc: subject
in the expectation that we will be able to find a `vp`:gc:.

Top-Down Parsing
----------------

Top-down chart parsing works in a similar way to the recursive descent
parser discussed in Chapter chap-parse_, in that it starts off with
the top-level goal of finding an `s`:gc:. This goal is then broken into
the subgoals of trying to find constituents such as `np`:gc: and
`vp`:gc: which can be immediatedly dominated by  `s`:gc:.
To create a top-down chart parser, we use the Fundamental Rule as before plus
three other rules: the `Top-Down Initialization Rule`:dt:, the `Top-Down
Expand Rule`:dt:, and the `Top-Down Match Rule`:dt:.
The Top-Down Initialization Rule in td-init-rule_
captures the fact that the root of any
parse must be the start symbol `s`:gc:\.
It is illustrated graphically in Table td-init-chart_.

.. _td-init-rule:
.. ex::
   `Top Down Initialization Rule`:dt:

   .. parsed-literal::

    For every grammar production of the form:
      `s`:gc: |rarr| |alpha|
    add the self-loop edge: 
      [`s`:gc: |rarr|  |dot| |alpha|\ , (0, 0)]

.. table:: td-init-chart

   +----------------------+------------------------------+
   | a. Generic           | b. Example                   |
   | |chart_td_init|      | |chart_td_ex1|               |
   +----------------------+------------------------------+

   Top-Down Initialization Rule

.. |chart_td_init| image:: ../images/chart_td_init.png
   :scale: 30

.. |chart_td_ex1| image:: ../images/chart_td_ex1.png
   :scale: 30


As we mentioned before, the dot on the right hand side of a production
records how far our goals have been satisfied. So in Figure
td-init-chart_\ (b), we are predicting that we will be able to find an `np`:gc: and a
`vp`:gc:, but have not yet satisfied these subgoals. So how do we
pursue them? In order to find an  `np`:gc:, for instance, we need to
invoke a production which has `np`:gc: on its left hand side. The step
of adding the required edge to the chart is accomplished with the
Top-Down Expand Rule td-expand-rule_.
This tells us that if our chart contains an incomplete
edge whose dot is followed by a nonterminal *B*, then the parser
should add any self-loop edges licensed by the grammar whose left-hand
side is *B*.

.. _td-expand-rule:
.. ex::
   `Top Down Expand Rule`:dt:

   .. parsed-literal::

    If the chart contains the incomplete edge
      [*A* |rarr| |alpha| |dot| *B* |beta| , (*i*, *j*)]
    then for each grammar production
      *B* |rarr| |gamma|
    add the edge
      [*B* |rarr| |dot| |gamma| , (*j*, *j*\ )]

|nopar| Thus, given a chart that looks like the one in Table td-expand-chart_\ (a),
the Top-Down Expand Rule augments it with the edge shown in Table td-expand-chart_\ (b).
In terms of our running example, we now have the chart shown in Table td-expand-chart_\ (c).

.. table:: td-expand-chart

   +----------------------+------------------------+---------------------------------+
   | a. Input             | b. Output              | c. Example                      |
   | |chart_td_expand1|   | |chart_td_expand2|     | |chart_td_ex2|                  |
   +----------------------+------------------------+---------------------------------+

   Top-Down Expand Rule

.. |chart_td_expand1| image:: ../images/chart_td_expand1.png
   :scale: 30

.. |chart_td_expand2| image:: ../images/chart_td_expand2.png
   :scale: 30

.. |chart_td_ex2| image:: ../images/chart_td_ex2.png
   :scale: 30

The Top-Down Match rule allows the predictions of the grammar to be
matched against the input string. Thus, if the chart contains an incomplete
edge whose dot is followed by a terminal *w*, then the parser should
add an edge if the terminal corresponds to the current input symbol.

.. _top-down-match-rule:
.. ex::
   `Top-Down Match Rule`:dt:

   .. parsed-literal::

    If the chart contains the incomplete edge
      [*A* |rarr| |alpha| |dot| w\ :subscript:`j` |beta|\ , (*i*, *j*\ )]
    then add a new complete edge
      [`w`:subscript:`j` |rarr| |dot| , (*j*, *j*\ +1)]

|nopar| Graphically, the Top-Down Match rule takes us from
Table td-match-chart_\ (a), to Table td-match-chart_\ (b).

.. table:: td-match-chart

   +--------------------------+------------------------+
   | a. Input                 | b. Output              |
   | |chart_td_match1|        | |chart_td_match2|      |
   +--------------------------+------------------------+

   Top-Down Match Rule

.. |chart_td_match1| image:: ../images/chart_td_match1.png
   :scale: 30

.. |chart_td_match2| image:: ../images/chart_td_match2.png
   :scale: 30

Figure td-example_\ (a) illustrates how our example chart after applying the
Top-Down Match rule.
What rule is relevant now? The Fundamental Rule. If we remove the
self-loop edges from Figure td-example_\ (a) for simplicity, the Fundamental
Rule gives us Figure td-example_\ (b).

.. table:: td-example

   +-----------------------------------+---------------------------------+
   | a. Apply Top-Down Match Rule      | b. Apply Fundamental Rule       |
   | |chart_td_ex3|                    | |chart_td_ex4|                  |
   +-----------------------------------+---------------------------------+

   Top-Down Example (cont)

.. |chart_td_ex3| image:: ../images/chart_td_ex3.png
   :scale: 30

.. |chart_td_ex4| image:: ../images/chart_td_ex4.png
   :scale: 30

Using these four rules, we can parse a sentence top-down as shown in
top-down-strategy_.

.. _top-down-strategy:
.. ex::
   `Top-Down Strategy`:dt:

   .. parsed-literal::

    Create an empty chart spanning the sentence. 
    Apply the Top-Down Initialization Rule to each word. 
    Until no more edges are added: 
      Apply the Top-Down Expand Rule everywhere it applies. 
      Apply the Top-Down Match Rule everywhere it applies. 
      Apply the Fundamental Rule everywhere it applies. 
    Return all of the parse trees corresponding to the parse edges in the chart. 

We encourage you to experiment with the  |NLTK| chart parser demo,
as before, in order to test out the top-down strategy yourself.

Chart Parsing in NLTK
---------------------

``nltk_lite.parse.chart`` defines a simple yet flexible chart parser,
``ChartParse``.  A new chart parser is constructed from a
grammar and a list of chart rules (also known as a *strategy*).  These
rules will be applied, in order, until no new edges are added to the
chart.  In particular, ``ChartParse`` uses the algorithm shown in chart-algorithm_.

.. _chart-algorithm:
.. ex::
   .. parsed-literal::   
  
    Until no new edges are added:
      For each chart rule *R*:
        Apply *R* to any applicable edges in the chart. 
        Return any complete parses in the chart. 
        
``nltk_lite.parse.chart`` defines two ready-made strategies:
``TD_STRATEGY``, a basic top-down strategy; and ``BU_STRATEGY``, a
basic bottom-up strategy.  When constructing a chart parser, you
can use either of these strategies, or create your own.

The following example illustrates the use of the chart parser.
We start by defining a simple grammar, and tokenizing a sentence.
We make sure it is a list (not an iterator), since
we wish to use the same tokenized sentence several times.

    >>> grammar = cfg.parse_grammar('''
    ...   S -> NP VP
    ...   VP -> V NP | VP PP
    ...   V -> "saw" | "ate"
    ...   NP -> "I" | "John" | "Mary" | "Bob" | Det N | NP PP
    ...   Det -> "a" | "an" | "the" | "my"
    ...   N -> "man" | "dog" | "cat" | "telescope"
    ...   PP -> P NP
    ...   P -> "on" | "by" | "with"
    ... ''')

    >>> from nltk_lite import tokenize
    >>> from nltk_lite.parse import ChartParse, BU_STRATEGY
    >>> sent = list(tokenize.whitespace('I saw the man with the telescope'))
    >>> parser = ChartParse(grammar, BU_STRATEGY)
    >>> for tree in parser.get_parse_list(sent):
    ...     print tree
    (S:
      (NP: 'I')
      (VP:
        (V: 'saw')
        (NP:
          (NP: (Det: 'the') (N: 'man'))
          (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope'))))))
    (S:
      (NP: 'I')
      (VP:
        (VP: (V: 'saw') (NP: (Det: 'the') (N: 'man')))
        (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope')))))

The ``trace`` parameter can be specified when creating a parser, to
turn on tracing (higher trace levels produce more verbose output).
Example butrace_ shows the trace output for parsing a
sentence with the bottom-up strategy:

.. pylisting:: butrace
   :caption: Trace of Bottom-Up Parser
   
    # Parse the sentence, bottom-up, with tracing turned on.
    >>> parser = ChartParse(grammar, BU_STRATEGY, trace=2)
    >>> parser.get_parse(sent)
    |.  I  . saw . the . man . with. the .teles.|
    Bottom Up Init Rule:
    |[-----]     .     .     .     .     .     .| [0:1] 'I' 
    |.     [-----]     .     .     .     .     .| [1:2] 'saw' 
    |.     .     [-----]     .     .     .     .| [2:3] 'the' 
    |.     .     .     [-----]     .     .     .| [3:4] 'man' 
    |.     .     .     .     [-----]     .     .| [4:5] 'with' 
    |.     .     .     .     .     [-----]     .| [5:6] 'the' 
    |.     .     .     .     .     .     [-----]| [6:7] 'telescope' 
    Bottom Up Predict Rule:
    |>     .     .     .     .     .     .     .| [0:0] NP -> * 'I' 
    |.     >     .     .     .     .     .     .| [1:1] V  -> * 'saw' 
    |.     .     >     .     .     .     .     .| [2:2] Det -> * 'the' 
    |.     .     .     >     .     .     .     .| [3:3] N  -> * 'man' 
    |.     .     .     .     >     .     .     .| [4:4] P  -> * 'with' 
    |.     .     .     .     .     >     .     .| [5:5] Det -> * 'the' 
    |.     .     .     .     .     .     >     .| [6:6] N  -> * 'telescope' 
    Fundamental Rule:
    |[-----]     .     .     .     .     .     .| [0:1] NP -> 'I' * 
    |.     [-----]     .     .     .     .     .| [1:2] V  -> 'saw' * 
    |.     .     [-----]     .     .     .     .| [2:3] Det -> 'the' * 
    |.     .     .     [-----]     .     .     .| [3:4] N  -> 'man' * 
    |.     .     .     .     [-----]     .     .| [4:5] P  -> 'with' * 
    |.     .     .     .     .     [-----]     .| [5:6] Det -> 'the' * 
    |.     .     .     .     .     .     [-----]| [6:7] N  -> 'telescope' * 
    Bottom Up Predict Rule:
    |>     .     .     .     .     .     .     .| [0:0] S  -> * NP VP 
    |>     .     .     .     .     .     .     .| [0:0] NP -> * NP PP 
    |.     >     .     .     .     .     .     .| [1:1] VP -> * V NP 
    |.     .     >     .     .     .     .     .| [2:2] NP -> * Det N 
    |.     .     .     .     >     .     .     .| [4:4] PP -> * P NP 
    |.     .     .     .     .     >     .     .| [5:5] NP -> * Det N 
    Fundamental Rule:
    |[----->     .     .     .     .     .     .| [0:1] S  -> NP * VP 
    |[----->     .     .     .     .     .     .| [0:1] NP -> NP * PP 
    |.     [----->     .     .     .     .     .| [1:2] VP -> V * NP 
    |.     .     [----->     .     .     .     .| [2:3] NP -> Det * N 
    |.     .     [-----------]     .     .     .| [2:4] NP -> Det N * 
    |.     .     .     .     [----->     .     .| [4:5] PP -> P * NP 
    |.     .     .     .     .     [----->     .| [5:6] NP -> Det * N 
    |.     .     .     .     .     [-----------]| [5:7] NP -> Det N * 
    |.     [-----------------]     .     .     .| [1:4] VP -> V NP * 
    |.     .     .     .     [-----------------]| [4:7] PP -> P NP * 
    |[-----------------------]     .     .     .| [0:4] S  -> NP VP * 
    Bottom Up Predict Rule:
    |.     .     >     .     .     .     .     .| [2:2] S  -> * NP VP 
    |.     .     >     .     .     .     .     .| [2:2] NP -> * NP PP 
    |.     .     .     .     .     >     .     .| [5:5] S  -> * NP VP 
    |.     .     .     .     .     >     .     .| [5:5] NP -> * NP PP 
    |.     >     .     .     .     .     .     .| [1:1] VP -> * VP PP 
    Fundamental Rule:
    |.     .     [----------->     .     .     .| [2:4] S  -> NP * VP 
    |.     .     [----------->     .     .     .| [2:4] NP -> NP * PP 
    |.     .     .     .     .     [----------->| [5:7] S  -> NP * VP 
    |.     .     .     .     .     [----------->| [5:7] NP -> NP * PP 
    |.     [----------------->     .     .     .| [1:4] VP -> VP * PP 
    |.     .     [-----------------------------]| [2:7] NP -> NP PP * 
    |.     [-----------------------------------]| [1:7] VP -> VP PP * 
    |.     .     [----------------------------->| [2:7] S  -> NP * VP 
    |.     .     [----------------------------->| [2:7] NP -> NP * PP 
    |.     [----------------------------------->| [1:7] VP -> VP * PP 
    |.     [-----------------------------------]| [1:7] VP -> V NP * 
    |[=========================================]| [0:7] S  -> NP VP * 
    |[=========================================]| [0:7] S  -> NP VP * 
    |.     [----------------------------------->| [1:7] VP -> VP * PP 
    ('S': ('NP': 'I') ('VP': ('V': 'saw') ('NP': ('NP': ('Det': 'the') ('N': 'man')) ('PP': ('P': 'with') ('NP': ('Det': 'the') ('N': 'telescope'))))))

|nopar| Notice that in this output, ``'[-----]'`` indicates a complete edge,
``'>'`` indicates a self-loop edge, and ``'[----->'`` indicates an
incomplete edge.

Exercises
---------

1. |easy| Use the graphical chart-parser interface to experiment with
   different rule invocation strategies. Come up with your own strategy
   which you can execute manually using the graphical interface. Describe
   the steps, and report any efficiency improvements it has (e.g. in terms
   of the size of the resulting chart). Do these improvements depend on
   the structure of the grammar? What do you think of the prospects for
   significant performance boosts from cleverer rule invocation
   strategies?

#. |easy| We have seen that a chart parser adds but never removes edges
   from a chart.  Why?

#. |soso| [Question about efficiency; use ``timeit`` to compare parser speed.]

---------------------
Probabilistic Parsing
---------------------

.. TODO: mention interest in having weights is because they can be learned.
   Without this it is mysterious why we would want to bother.
   Technical aspects follow, but this is important motivation (Steven)

.. TODO: expand opening discussion to remind reader why we're doing this
   (we had moved stuff to front of chapter) (Steven)

As we pointed out in the introduction to this
chapter, dealing with ambiguity is a key challenge to broad coverage
parsers. We have shown how chart parsing can help improve the
efficiency of computing multiple parses of the same sentences. But
the sheer number of parses can be just overwhelming. We will show how
probabilistic parsing helps to manage a large space of parses.  
However, before we deal with these parsing issues,
we must first back up and introduce weighted grammars.

Weighted Grammars
-----------------
 
We begin by considering the verb `give`:lx:.  This verb requires both
a direct object (the thing being given) and an indirect object (the
recipient).  These complements can be given in either order, as
illustrated in example dative_.  In the "prepositional dative" form,
the indirect object appears last, and inside a prepositional phrase,
while in the "double object" form, the indirect object comes first:

.. _dative:
.. ex::
   .. ex::
      Kim gave a bone to the dog
   .. ex::
      Kim gave the dog a bone

Using the Penn Treebank sample, we can examine all instances of
prepositional dative and double object constructions involving
`give`:lx:, as shown below:

    >>> from nltk_lite.corpora import treebank
    >>> from string import join
    >>> give = lambda t: t.node == 'VP' and len(t) > 2 and t[1].node == 'NP'\
    ...        and (t[2].node == 'PP-DTV' or t[2].node == 'NP')\
    ...        and ('give' in t[0].leaves() or 'gave' in t[0].leaves())
    >>> for tree in treebank.parsed():
    ...     for t in tree.subtrees(give):
    ...         print "%s [%s: %s] [%s: %s]" %\
    ...               (join(t[0].leaves()),
    ...                t[1].node, join(t[1].leaves()),
    ...                t[2].node, join(t[2].leaves()))
    gave [NP: the chefs] [NP: a standing ovation]
    give [NP: advertisers] [NP: discounts for * maintaining or increasing ad spending]
    give [NP: it] [PP-DTV: to the politicians]
    gave [NP: them] [NP: similar help]
    give [NP: them] [NP: *T*-1]
    give [NP: only French history questions] [PP-DTV: to students in a European history class]
    give [NP: federal judges] [NP: a raise]
    give [NP: consumers] [NP: the straight scoop on the U.S. waste crisis]
    gave [NP: Mitsui] [NP: access to a high-tech medical product]
    give [NP: Mitsubishi] [NP: a window on the U.S. glass industry]
    give [NP: much thought] [PP-DTV: to the rates 0 she was receiving *T*-2 , nor to the fees 0
      she was paying *T*-3]
    give [NP: your Foster Savings Institution] [NP: the gift of hope and freedom from the federal
      regulators who *T*-206 want *-1 to close its doors -- for good]
    give [NP: market operators] [NP: the authority * to suspend trading in futures at any time]
    gave [NP: quick approval] [PP-DTV: to $ 3.18 billion *U* in supplemental appropriations for
      law enforcement and anti-drug programs in fiscal 1990]
    give [NP: the Transportation Department] [NP: up to 50 days 0 * to review any purchase of
      15 % or more of the stock in an airline *T*-1]
    give [NP: the president] [NP: such power]
    give [NP: me] [NP: the heebie-jeebies]
    give [NP: holders] [NP: the right *RNR*-1 , but not the obligation *RNR*-1 , * to buy -LRB-
      a call -RRB- or sell -LRB- a put -RRB- a specified amount of an underlying investment by
      a certain date at a preset price , known * as the strike price]
    gave [NP: Mr. Thomas] [NP: only a `` qualified '' rating , rather than `` well qualified]
    give [NP: the president] [NP: line-item veto power]

We can observe a strong tendency for the shortest complement to appear
first.  However, this does not account for a form like
``give [NP: federal judges] [NP: a raise]``, where animacy may be
playing a role.  In fact there turn out to be a large number of contributing
factors, as surveyed by [BresnanHay2006]_.

How can such tendencies be expressed in a conventional context free
grammar?  It turns out that they cannot.  However, we can address the
problem by adding weights, or probabilities, to the productions of a
grammar.

A `probabilistic context free grammar`:dt: (or *PCFG*) is a context free
grammar that associates a probability with each of its productions.
It generates the same set of parses for a text that the corresponding
context free grammar does, and assigns a probability to each parse.
The probability of a parse generated by a PCFG is simply the product
of the probabilities of the productions used to generate it.

The simplest way to define a PCFG is to load it from a specially
formatted string consisting of a sequence of weighted productions,
where weights appear in brackets, as shown in Listing pcfg1_.

.. pylisting:: pcfg1
   :caption: Defining a Probabilistic Context Free Grammar (PCFG)

    from nltk_lite.parse import pcfg
    grammar = pcfg.parse_grammar("""
        S  -> NP VP              [1.0]
        VP -> 'saw' NP           [0.4]
        VP -> 'ate'              [0.3]
        VP -> 'gave' NP NP       [0.3]
        NP -> 'the' 'telescope'  [0.8]
        NP -> 'Jack'             [0.2]
        """)
    >>> print grammar
    Grammar with 6 productions (start state = S)
        S -> NP VP [1.0]
        VP -> 'saw' NP [0.4]
        VP -> 'ate' [0.3]
        VP -> 'gave' NP NP [0.3]
        NP -> 'the' 'telescope' [0.8]
        NP -> 'Jack' [0.2]
        
It is sometimes convenient to combine multiple productions into a single line,
e.g. ``VP -> 'saw' NP [0.4] | 'ate' [0.3] | 'gave' NP NP [0.3]``.
In order to ensure that the trees generated by the grammar form a
probability distribution, PCFG grammars impose the constraint
that all productions with a given left-hand side must have
probabilities that sum to one.
The grammar in Listing pcfg1_ obeys this constraint: for ``S``,
there is only one production, with a probability of 1.0; for ``VP``,
0.4+0.3+0.3=1.0; and for ``NP``, 0.8+0.2=1.0.
The parse tree returned by ``get_parse()`` includes probabilities:

    >>> from nltk_lite.parse import ViterbiParse
    >>> viterbi_parser = ViterbiParse(grammar)
    >>> print viterbi_parser.get_parse(['Jack', 'saw', 'the', 'telescope'])
    (S: (NP: 'Jack') (VP: 'saw' (NP: 'the' 'telescope'))) (p=0.064)

The next two sections introduce two probabilistic parsing algorithms
for PCFGs.  The first is a Viterbi-style algorithm that uses dynamic
programming to find the single most likely parse for a given text.
Whenever it finds multiple possible parses for a subtree, it discards
all but the most likely parse.  The second is a bottom-up chart parser
that maintains a queue of edges, and adds them to the chart one at a
time.  The ordering of this queue is based on the probabilities
associated with the edges, allowing the parser to expand more likely
edges before less likely ones.  Different queue orderings are used to
implement a variety of different search strategies.  These algorithms
are implemented in the ``nltk_lite.parse.viterbi`` and
``nltk_lite.parse.pchart`` modules.

A Viterbi-Style PCFG Parser
---------------------------

The ``ViterbiParse`` PCFG parser is a bottom-up parser that uses
dynamic programming to find the single most likely parse for a text.
It parses texts by iteratively filling in a 
`most likely constituents table`:dt:.  This table records the most likely tree for each
span and node value.  For example, after parsing the sentence "I saw the man with
the telescope" with the grammar ``pcfg.toy1``, the most likely constituents table
contains the following entries (amongst others):

.. table:: mlct

   ===== ==== =========================================================================  ============
   Span  Node Tree                                                                       Prob
   ===== ==== =========================================================================  ============
   [0:1] NP   (NP: I)                                                                    0.15
   [6:7] NP   (NN: telescope)                                                            0.5
   [5:7] NP   (NP: the telescope)                                                        0.2
   [4:7] PP   (PP: with (NP: the telescope))                                             0.122
   [0:4] S    (S: (NP: I) (VP: saw (NP: the man)))                                       0.01365
   [0:7] S    (S: (NP: I) (VP: saw (NP: (NP: the man) (PP: with (NP: the telescope)))))  0.0004163250
   ===== ==== =========================================================================  ============

   Fragment of Most Likely Constituents Table

Once the table has been completed, the parser
returns the entry for the most likely constituent that spans the
entire text, and whose node value is the start symbol.  For this
example, it would return the entry with a span of [0:6] and a node
value of "S".

Note that we only record the *most likely* constituent for any given
span and node value.  For example, in the table above, there are
actually two possible constituents that cover the span [1:6] and have
"VP" node values.
    
1. "saw the man, who has the telescope":

  (VP: saw
     (NP: (NP: John)
          (PP: with (NP: the telescope))))

2. "used the telescope to see the man":

  (VP: saw
     (NP: John)
     (PP: with (NP: the telescope)))

|nopar|
Since the grammar we are using to parse the text indicates that the
first of these tree structures has a higher probability, the parser
discards the second one.

**Filling in the Most Likely Constituents Table:**
Because the grammar used by ``ViterbiParse`` is a PCFG, the
probability of each constituent can be calculated from the
probabilities of its children.  Since a constituent's children can
never cover a larger span than the constituent itself, each entry of
the most likely constituents table depends only on entries for
constituents with *shorter* spans (or equal spans, in the case of
unary and epsilon productions).

``ViterbiParse`` takes advantage of this fact, and fills in the most
likely constituent table incrementally.  It starts by filling in the
entries for all constituents that span a single element of text.
After it has filled in all the table entries for constituents that
span one element of text, it fills in the entries for constituents
that span two elements of text.  It continues filling in the entries
for constituents spanning larger and larger portions of the text,
until the entire table has been filled.

To find the most likely constituent with a given span and node value,
``ViterbiParse`` considers all productions that could produce that
node value.  For each production, it checks the most likely
constituents table for sequences of children that collectively cover
the span and that have the node values specified by the production's
right hand side.  If the tree formed by applying the production to the
children has a higher probability than the current table entry, then
it updates the most likely constituents table with the new tree.

**Handling Unary Productions and Epsilon Productions:**
A minor difficulty is introduced by unary productions and epsilon
productions: an entry of the most likely constituents table might
depend on another entry with the same span.  For example, if the
grammar contains the production ``V`` |rarr| ``VP``, then the table
entries for ``VP`` depend on the entries for ``V`` with the same span.
This can be a problem if the constituents are checked in the wrong
order.  For example, if the parser tries to find the most likely
constituent for a ``VP`` spanning [1:3] before it finds the most
likely constituents for ``V`` spanning [1:3], then it can't apply the
``V`` |rarr| ``VP`` production.
      
To solve this problem, ``ViterbiParse`` repeatedly checks each span
until it finds no new table entries.  Note that cyclic grammar
productions (e.g. ``V`` |rarr| ``V``) will *not* cause this procedure
to enter an infinite loop.  Since all production probabilities are
less than or equal to 1, any constituent generated by a cycle in the
grammar will have a probability that is less than or equal to the
original constituent; so ``ViterbiParse`` will discard it.

Using ``ViterbiParse``
----------------------

Viterbi parsers are created using the ``ViterbiParse`` constructor.
Note that since ``ViterbiParse`` only finds the single most likely
parse, that ``get_parse_list`` will never return more than one parse.

    >>> from nltk_lite.parse import ViterbiParse
    >>> viterbi_parser1 = ViterbiParse(pcfg.toy1)
    >>> sent1 = list(tokenize.whitespace('I saw the man with the telescope'))
    >>> tree1 = viterbi_parser1.parse(sent1)
    >>> print tree1
    (S:
      (NP: 'I')
      (VP:
        (V: 'saw')
        (NP:
          (NP: (Det: 'the') (N: 'man'))
          (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope')))))) (p=0.000416325)
      
    >>> viterbi_parser2 = ViterbiParse(pcfg.toy2)
    >>> sent2 = list(tokenize.whitespace('the boy saw Jack with Bob under the table with a telescope'))
    >>> trees = viterbi_parser2.get_parse_list(sent2)
    >>> for tree in trees:
    ...     print tree
    (S:
      (NP: (Det: 'the') (N: 'boy'))
      (VP:
        (V: 'saw')
        (NP:
          (NP: (Name: 'Jack'))
          (PP:
            (P: 'with')
            (NP:
              (NP:
                (NP: (Name: 'Bob'))
                (PP:
                  (P: 'under')
                  (NP: (Det: 'the') (N: 'table'))))
              (PP:
                (P: 'with')
                (NP: (Det: 'a') (N: 'telescope')))))))) [7.53678903935e-11]

The ``trace`` method can be used to set the level of tracing output
that is generated when parsing a text.  Trace output displays the
constituents that are considered, and indicates which ones are added
to the most likely constituent table.  It also indicates the
likelihood for each constituent.

    >>> viterbi_parser1.trace(3)
    >>> tree = viterbi_parser1.parse(sent1)
    Inserting tokens into the most likely constituents table...
       Insert: |=......| I
       Insert: |.=.....| saw
       Insert: |..=....| the
       Insert: |...=...| man
       Insert: |....=..| with
       Insert: |.....=.| the
       Insert: |......=| telescope
    Finding the most likely constituents spanning 1 text elements...
       Insert: |=......| NP -> 'I' [0.15]               0.1500000000 
       Insert: |.=.....| V -> 'saw' [0.65]              0.6500000000 
       Insert: |.=.....| VP -> V [0.2]                  0.1300000000 
       Insert: |..=....| Det -> 'the' [0.8]             0.8000000000 
       Insert: |...=...| N -> 'man' [0.5]               0.5000000000 
       Insert: |....=..| P -> 'with' [0.61]             0.6100000000 
       Insert: |.....=.| Det -> 'the' [0.8]             0.8000000000 
       Insert: |......=| N -> 'telescope' [0.5]         0.5000000000 
    Finding the most likely constituents spanning 2 text elements...
       Insert: |==.....| S -> NP VP [1.0]               0.0195000000 
       Insert: |..==...| NP -> Det N [0.5]              0.2000000000 
       Insert: |.....==| NP -> Det N [0.5]              0.2000000000 
    Finding the most likely constituents spanning 3 text elements...
       Insert: |.===...| VP -> V NP [0.7]               0.0910000000 
       Insert: |....===| PP -> P NP [1.0]               0.1220000000 
    Finding the most likely constituents spanning 4 text elements...
       Insert: |====...| S -> NP VP [1.0]               0.0136500000 
    Finding the most likely constituents spanning 5 text elements...
       Insert: |..=====| NP -> NP PP [0.25]             0.0061000000 
    Finding the most likely constituents spanning 6 text elements...
       Insert: |.======| VP -> VP PP [0.1]              0.0011102000 
       Insert: |.======| VP -> V NP [0.7]               0.0027755000 
      Discard: |.======| VP -> VP PP [0.1]              0.0011102000 
    Finding the most likely constituents spanning 7 text elements...
       Insert: |=======| S -> NP VP [1.0]               0.0004163250 

The level of tracing output can also be set with an optional argument to
the ``ViterbiParse`` constructor.  By default, no tracing output is generated.
Tracing output can be turned off by calling ``trace`` with a value of ``0``.

A Bottom-Up PCFG Chart Parser
-----------------------------

.. TODO: cull implementation discussion (Steven)

The Viterbi-style algorithm described in the previous section finds
the single most likely parse for a given text.  But for many
applications, it is useful to produce several alternative parses.
This is often the case when probabilistic parsers are combined with
other probabilistic systems.  In particular, the most probable parse
may be assigned a low probability by other systems; and a parse that
is given a low probability by the parser might have a better overall
probability.

For example, a probabilistic parser might decide that the most likely
parse for "I saw John with the cookie" is is the structure with the
interpretation "I used my cookie to see John"; but that parse would be
assigned a low probability by a semantic system.  Combining the
probability estimates from the parser and the semantic system, the
parse with the interpretation "I saw John, who had my cookie" would be
given a higher overall probability.

This section describes ``BottomUpChartParser``, a parser for PCFGs
that can find multiple parses for a text.  It assumes that you have
already read the chart parsing tutorial, and are familiar with the
data structures and productions used for chart parsing.

``BottomUpChartParser`` is a bottom-up parser for PCFGs that uses
a ``Chart`` to record partial results.  It maintains a queue of
edges, and adds them to the chart one at a time.  The ordering
of this queue is based on the probabilities associated with the edges,
allowing the parser to insert more likely edges before exploring less
likely ones.  For each edge that the parser adds to the chart, it may
become possible to insert new edges into the chart; these are added to
the queue.  ``BottomUpChartParser`` continues adding the edges in the
queue to the chart until enough complete parses have been found, or
until the edge queue is empty.

Probabilistic Edges
-------------------

Like an edge in a regular chart, a probabilistic edge
consists of a dotted production, a span, and a
(partial) parse tree.  However, in the case of a probabilistic edge, the
tree is a ``ProbabilisticTree``.  Its probability
is the product of the probability of the production that
generated it and the probabilities of its children.  For example, the
probability of the edge ``[Edge: S`` |rarr| ``NP`` |dot|
``VP, 0:2]`` is the probability of the PCFG production ``S`` |rarr| ``NP VP``
multiplied by the probability of its `np`:gc: child.
Note that an edge's tree only includes children for elements to the left
of the edge's dot.  Thus, the edge's probability does *not* include
probabilities for the constituents to the right of the edge's dot.

The `edge queue`:dt: is a sorted list of edges that can be added to the
chart.  It is initialized with a single edge for each token in the
text, with the form [Edge: token |rarr| |dot|].
As each edge from the queue is added to the chart, it may
become possible to add further edges, according to two rules:
(i) the Bottom-Up Initialization Rule can be used to add a
self-loop edge whenever an edge whose dot is in position 0 is added to the chart; or
(ii) the Fundamental Rule can be used to combine a new edge
with edges already present in the chart.  These additional edges
are queued for addition to the chart.

Sorting The Edge Queue
----------------------

By changing the sorting order used by the queue, we can control the
strategy that the parser uses to search for parses of a text.  Since
there are a wide variety of reasonable search strategies,
``BottomUpChartParse`` does not define the sorting order for the
queue.  Instead, subclasses are used to implement a variety of different
queue orderings.  The remainder of this section describes four subclasses of
``BottomUpChartParse`` that are defined in the ``nltk_lite.parse.pchart`` module.

.. We should either explain "inside probabilities" or rename this parser (to
        ``LowestCostFirstParser``?). 

**InsideParse:**
The simplest way to order the queue is to sort the edges by the
probabilities of their trees.  This ordering concentrates the
efforts of the parser on edges that are more likely to be correct
descriptions of the texts that they span.  This approach is
implemented by the ``InsideParse`` class.

The probability of an edge's tree provides an upper bound on the
probability of any parse produced using that edge.  The probabilistic
"cost" of using an edge to form a parse is one minus its tree's
probability.  Thus, inserting the edges with the most likely trees
first results in a `lowest-cost-first search strategy`:dt:.
Lowest-cost-first search is optimal: the first
solution it finds is guaranteed to be the best solution.

However, lowest-cost-first search can be rather inefficient.  Since a
tree's probability is the product of the probabilities of all the
productions used to generate it, smaller trees tend to have higher
probabilities than larger ones.  Thus, lowest-cost-first search tends
to insert edges with small trees before moving on to edges with larger
ones.  But any complete parse of the text will necessarily have a
large tree; so complete parses will tend to be inserted after nearly
all other edges.

The basic problem with lowest-cost-first search is that it ignores the
probability that an edge's tree is part of a complete parse.  It will
try parses that are locally coherent, even if they are unlikely to
form part of a complete parse.  Unfortunately, it can be quite
difficult to calculate the probability that a tree is part of a
complete parse.  However, we can use a variety of techniques to
approximate that probability.

**LongestParse:**
``LongestParse`` sorts its queue in descending order of the edges'
lengths.  These lengths provide a crude approximation to the
probabilities that trees are part of complete parses.
Thus, ``LongestParse`` employs a `best-first search strategy`:dt:,
where it inserts the edges that are closest to producing
complete parses before trying any other edges.  Best-first search is
*not* an optimal search strategy: the first solution it finds is not
guaranteed to be the best solution.  However, it will usually find a
complete parse much more quickly than lowest-cost-first search.

**BeamParse:**
When large grammars are used to parse a text, the edge queue can grow
quite long.  The edges at the end of a large well-sorted queue are
unlikely to be used.  Therefore, it is reasonable to remove (or
*prune*) these edges from the queue.

``BeamParse`` provides a simple implementation of a pruning PCFG
parser.  It uses the same sorting order as ``InsideParse``.  But
whenever the edge queue grows beyond a pre-defined maximum length,
``BeamParse`` truncates it.  The resulting search strategy,
lowest-cost-first search with pruning, is a type of beam search.  (A
*beam search* is a search strategy that only keeps the best partial
results.)  The queue's predefined maximum length is called the *beam
size* (or simply the *beam*).  The parser's beam size is set by the
first argument to its constructor.

Beam search reduces the space requirements for lowest-cost-first
search, by discarding edges that are not likely to be used.  But beam
search also loses many of lowest-cost-first search's more useful
properties.  Beam search is not optimal: it is not guaranteed to find
the best parse first.  In fact, since it might prune a necessary edge,
beam search is not even *complete*: it is not guaranteed to return a
parse if one exists.

Using the NLTK Bottom-Up Chart Parsers
--------------------------------------

These parsers are created using the ``BottomUpChartParse``
subclasses's constructors.  These include: ``InsideParse``,
``LongestParse``, ``BeamParser``, and ``RandomParse``.

    >>> from nltk_lite.parse.pchart import *
    >>> inside_parser = InsideParse(pcfg.toy1)
    >>> longest_parser = LongestParse(pcfg.toy1)
    >>> beam_parser = BeamParse(20, pcfg.toy1)

    >>> print inside_parser.parse(sent1)
    (S:
      (NP: 'I')
      (VP:
        (V: 'saw')
        (NP:
          (NP: (Det: 'the') (N: 'man'))
          (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope')))))) (p=0.000416325)
          
    >>> for tree in inside_parser.get_parse_list(sent1):
    ...     print tree
    (S:
      (NP: 'I')
      (VP:
        (V: 'saw')
        (NP:
          (NP: (Det: 'the') (N: 'man'))
          (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope')))))) (p=0.000416325)        
    (S:
      (NP: 'I')
      (VP:
        (VP: (V: 'saw') (NP: (Det: 'the') (N: 'man')))
        (PP: (P: 'with') (NP: (Det: 'the') (N: 'telescope'))))) (p=0.00016653)

The ``trace`` method can be used to set the level of tracing output
that is generated when parsing a text.  Trace output displays edges as
they are added to the chart, and shows the probability for each edges'
tree.

    >>> inside_parser.trace(3)
    >>> trees = inside_parser.get_parse_list(sent1)
      |. . . . . . [-]| [6:7] 'telescope'                [1.0]
      |. . . . . [-] .| [5:6] 'the'                      [1.0]
      |. . . . [-] . .| [4:5] 'with'                     [1.0]
      |. . . [-] . . .| [3:4] 'man'                      [1.0]
      |. . [-] . . . .| [2:3] 'the'                      [1.0]
      |. [-] . . . . .| [1:2] 'saw'                      [1.0]
      |[-] . . . . . .| [0:1] 'I'                        [1.0]
      |. . [-] . . . .| [2:3] Det -> 'the' *             [0.8]
      |. . > . . . . .| [2:2] Det -> * 'the'             [0.8]
      |. . . . . [-] .| [5:6] Det -> 'the' *             [0.8]
      |. . . . . > . .| [5:5] Det -> * 'the'             [0.8]
      |. [-] . . . . .| [1:2] V  -> 'saw' *              [0.65]
      |. > . . . . . .| [1:1] VP -> * V NP               [0.7]
      |. > . . . . . .| [1:1] V  -> * 'saw'              [0.65]
      |. . . . [-] . .| [4:5] P  -> 'with' *             [0.61]
      |. . . . > . . .| [4:4] PP -> * P NP               [1.0]
      |. . . . [-> . .| [4:5] PP -> P * NP               [0.61]
      |. . . . > . . .| [4:4] P  -> * 'with'             [0.61]
      |. . . . . > . .| [5:5] NP -> * Det N              [0.5]
      |. . > . . . . .| [2:2] NP -> * Det N              [0.5]
      |. . . [-] . . .| [3:4] N  -> 'man' *              [0.5]
      |. . . > . . . .| [3:3] N  -> * 'man'              [0.5]
      |. . . . . . [-]| [6:7] N  -> 'telescope' *        [0.5]
      |. . . . . . > .| [6:6] N  -> * 'telescope'        [0.5]
      |. [-> . . . . .| [1:2] VP -> V * NP               [0.455]
      |. . . . . [-> .| [5:6] NP -> Det * N              [0.4]
      |. . [-> . . . .| [2:3] NP -> Det * N              [0.4]
      |. . . . . [---]| [5:7] NP -> Det N *              [0.2]
      |. . . . . > . .| [5:5] S  -> * NP VP              [1.0]
      |. . . . . > . .| [5:5] NP -> * NP PP              [0.25]
      |. . . . . [--->| [5:7] S  -> NP * VP              [0.2]
      |. . [---] . . .| [2:4] NP -> Det N *              [0.2]
      |. . > . . . . .| [2:2] S  -> * NP VP              [1.0]
      |. . > . . . . .| [2:2] NP -> * NP PP              [0.25]
      |. . [---> . . .| [2:4] S  -> NP * VP              [0.2]
      |. > . . . . . .| [1:1] VP -> * V                  [0.2]
      |[-] . . . . . .| [0:1] NP -> 'I' *                [0.15]
      |> . . . . . . .| [0:0] S  -> * NP VP              [1.0]
      |> . . . . . . .| [0:0] NP -> * NP PP              [0.25]
      |[-> . . . . . .| [0:1] S  -> NP * VP              [0.15]
      |> . . . . . . .| [0:0] NP -> * 'I'                [0.15]
      |. [-] . . . . .| [1:2] VP -> V *                  [0.13]
      |. . . . [-----]| [4:7] PP -> P NP *               [0.122]
      |. > . . . . . .| [1:1] VP -> * VP PP              [0.1]
      |. [-----] . . .| [1:4] VP -> V NP *               [0.091]
      |. . [---> . . .| [2:4] NP -> NP * PP              [0.05]
      |. . . . . [--->| [5:7] NP -> NP * PP              [0.05]
      |[-> . . . . . .| [0:1] NP -> NP * PP              [0.0375]
      |[---] . . . . .| [0:2] S  -> NP VP *              [0.0195]
      |[-------] . . .| [0:4] S  -> NP VP *              [0.01365]
      |. [-> . . . . .| [1:2] VP -> VP * PP              [0.013]
      |. [-----> . . .| [1:4] VP -> VP * PP              [0.0091]
      |. . [---------]| [2:7] NP -> NP PP *              [0.0061]
      |. . [--------->| [2:7] S  -> NP * VP              [0.0061]
      |. [-----------]| [1:7] VP -> V NP *               [0.0027755]
      |. . [--------->| [2:7] NP -> NP * PP              [0.001525]
      |. [-----------]| [1:7] VP -> VP PP *              [0.0011102]
      |[=============]| [0:7] S  -> NP VP *              [0.000416325]
      |. [----------->| [1:7] VP -> VP * PP              [0.00027755]
      |[=============]| [0:7] S  -> NP VP *              [0.00016653]
      |. [----------->| [1:7] VP -> VP * PP              [0.00011102]


-----------------
Grammar Induction
-----------------

As we have seen, PCFG productions are just like CFG productions,
adorned with probabilities.  So far, we have simply specified these
probabilities in the grammar.  However, it is more usual to *estimate*
these probabilities from training data, namely a collection of parse
trees or *treebank*.

The simplest method uses *Maximum Likelihood Estimation*, so called
because probabilities are chosen in order to maximize the likelihood
of the training data.  The probability of a production
``VP`` |rarr| ``V NP PP`` is *p(V,NP,PP | VP)*.  We calculate this as
follows::

                        count(VP -> V NP PP)
      P(V,NP,PP | VP) = --------------------
                        count(VP -> ...)

Here is a simple program that induces a grammar from the first
three parse trees in the Penn Treebank corpus:

    >>> from nltk_lite.corpora import treebank
    >>> from itertools import islice
    >>> productions = []
    >>> S = cfg.Nonterminal('S')
    >>> for tree in islice(treebank.parsed(),3):
    ...      productions += tree.productions()
    >>> grammar = pcfg.induce(S, productions)
    >>> for production in grammar.productions()[:10]:
    ...      print production
    PP -> IN NP [1.0]
    NNP -> 'Nov.' [0.0714285714286]
    NNP -> 'Agnew' [0.0714285714286]
    JJ -> 'industrial' [0.142857142857]
    NP -> CD NNS [0.133333333333]
    , -> ',' [1.0]
    CC -> 'and' [1.0]
    NNP -> 'Pierre' [0.0714285714286]
    NP -> NNP NNP NNP NNP [0.0666666666667]
    NNP -> 'Rudolph' [0.0714285714286]
    
.. _sec-normal-forms:

Normal Forms
------------

Grammar induction usually involves normalizing the grammar
in various ways.  The ``nltk_lite.parse.treetransforms`` module
supports binarization (Chomsky Normal Form), parent annotation,
Markov order-N smoothing, and unary collapsing.  This information
can be accessed by importing ``treetransforms`` from
``nltk_lite.parse``, then calling ``help(treetransforms)``.


    >>> from nltk_lite.parse import bracket_parse
    >>> from nltk_lite.parse import treetransforms
    >>> treebank_string = """(S (NP-SBJ (NP (QP (IN at) (JJS least) (CD nine) (NNS tenths)) )
    ...     (PP (IN of) (NP (DT the) (NNS students) ))) (VP (VBD passed)))"""
    >>> t = bracket_parse(treebank_string)
    >>> print t
    (S:
      (NP-SBJ:
        (NP: (QP: (IN: 'at') (JJS: 'least') (CD: 'nine') (NNS: 'tenths')))
        (PP: (IN: 'of') (NP: (DT: 'the') (NNS: 'students'))))
      (VP: (VBD: 'passed')))
    >>> treetransforms.collapseUnary(t, collapsePOS=True)
    >>> print t
    (S:
      (NP-SBJ:
        (NP+QP: (IN: 'at') (JJS: 'least') (CD: 'nine') (NNS: 'tenths'))
        (PP: (IN: 'of') (NP: (DT: 'the') (NNS: 'students'))))
      (VP+VBD: 'passed'))
    >>> treetransforms.chomskyNormalForm(t)
    >>> print t
    (S:
      (NP-SBJ:
        (NP+QP:
          (IN: 'at')
          (NP+QP|<JJS-CD-NNS>:
            (JJS: 'least')
            (NP+QP|<CD-NNS>: (CD: 'nine') (NNS: 'tenths'))))        
        (PP: (IN: 'of') (NP: (DT: 'the') (NNS: 'students'))))
      (VP+VBD: 'passed'))

These trees are shown in treetransforms_.

.. _treetransforms:
.. ex:: 
   .. ex::
      .. tree:: (S (NP-SBJ (NP (QP (IN at) (JJS least) (CD nine) (NNS tenths))) (PP (IN of) (NP (DT the) (NNS students)))) (VP (VBD passed)))
   .. ex::
      .. tree:: (S (NP-SBJ (NP+QP (IN at) (JJS least) (CD nine) (NNS tenths)) (PP (IN of) (NP (DT the) (NNS students)))) (VP+VBD passed))
   .. ex::
      .. tree:: (S (NP-SBJ (NP+QP (IN at) (NP+QP|\<JJS-CD-NNS\> (JJS least) (NP+QP|\<CD-NNS\> (CD nine) (NNS tenths)))) (PP (IN of) (NP (DT the) (NNS students)))) (VP+VBD passed))

---------------
Further Reading
---------------

.. [Abney1996] 
	Steven Abney (1996). 
	'Statistical Methods and Linguistics.'
	In: Judith Klavans and Philip Resnik (eds.),
	*The Balancing Act: Combining Symbolic and Statistical
	Approaches to Language*.
	MIT Press.
	`<http://www.vinartus.net/spa/95c.pdf>`_

.. [ChurchPatil1982]
    Kenneth Church and Ramesh Patil (1982).
	Coping with Syntactic Ambiguity or How to Put the Block in the Box on the Table
	American Journal of Computational Linguistics, Vol 8, No. 3--4, pp 139--149

.. [BresnanHay2006]
	Joan Bresnan and Jennifer Hay (2006). 
	'Gradient Grammar: An Effect of Animacy on the Syntax of `give`:lx: in Varieties of English.'
	`<http://www-lfg.stanford.edu/bresnan/anim-spokensyntax-final.pdf>`_

.. [ManningSchutze1999]
	Christopher Manning and Hinrich Schutze (1999).  
	*Foundations of Statistical Natural Language Processing*.  
	MIT Press.  (esp chapter 12).

.. include:: footer.txt
