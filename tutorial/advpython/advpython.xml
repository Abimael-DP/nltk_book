<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"../../docbook/sgml/docbook/xml-dtd-4.2/docbookx.dtd" [
<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "../../api/public">
<!ENTITY tutdoc "..">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Copyright & License -->
<!ENTITY copyright SYSTEM "../copyright.xml">

<!-- Version & Date -->
<!ENTITY versiondate SYSTEM "versiondate.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Edward</firstname><surname>Loper</surname></author>
    <authorinitials>edl</authorinitials>
    <title>NLTK Tutorial: New Python Features</title>
    &versiondate; &copyright;
  </articleinfo>

  <section id="intro">
    <title> Introduction </title>

    <para> This tutorial explains a few new features of the Python
    language that are used by the toolkit.  Since these features are
    new to the language, they are not covered in many textbooks.  In
    particular, they are not covered in
    <author><surname>Lutz</surname></author> &amp;
    <author><surname>Ascher</surname></author>'s <citetitle>Learning
    Python</citetitle>.  </para>

  </section>

  <section id="string_methods">
    <title> String Methods </title>

    <para> Python defines a number of useful operations on strings.
    For example, <literal>find</literal> and <literal>rfind</literal>
    can be used to find occurances of substrings;
    <literal>split</literal> can be used to divide a string into
    pieces; and <literal>strip</literal> can be used to remove leading
    and trailing whitespace from a string. </para>

    <para> Before Python 2.0, these operations were accessed with the
    <literal>string</literal> module:

<!-- Emphasis is *really* not the right tag here, but I couldn't find a 
"comment" tag or anything like that --> 
<programlisting><![CDATA[
    >>> import string

    # The index at which "simple" begins.
    >>> string.find("a simple example", "simple")
    2
        
    # The pieces composing the string
    >>> string.split("a simple example")
    ['a', 'simple', 'example']
        
    # Leading and trailing whitespace removed
    >>> string.strip("   another example  ")
    'another example'           
]]></programlisting>
</para>

    <para> However, starting with Python 2.0, these operations can be
    accessed directly using "string methods."  In particular, every
    function defined in the <literal>string</literal> module is now
    also available as a method on strings:

<programlisting><![CDATA[
    # The index at which "simple" begins.
    >>> "a simple example".find("simple")
    2

    # The pieces composing the string
    >>> "a simple example".split()
    ['a', 'simple', 'example']

    # Leading and trailing whitespace removed
    >>> "   another example  ".strip()
    'another example'           
]]></programlisting>
</para>

    <para> This new method of accessing string operations is usually
    much more convenient, and easier to understand.  If you use string
    methods, you should not need to import the string module.  </para>

    <para> Although most of the string methods are streight-forward
    and intuitive, some can be somewhat confusing to newcomers.  In
    particular, the new syntax for the <literal>join</literal> method
    can be difficult.  This operation joins a list of substrings,
    inserting a given separator between each substring.  Using the
    <literal>string</literal> library, it can be used as follows:

<programlisting><![CDATA[
    >>> string.join(['a', 'simple', 'example'], '+')
    'a+simple+example'
]]></programlisting>

    In the new syntax, <literal>join</literal> is a member of the
    <emphasis>separator</emphasis> string, not the list of substrings:

<programlisting><![CDATA[
    >>> '+'.join(['a', 'simple', 'example'])
    'a+simple+example'
]]></programlisting>

    If you try to use <literal>join</literal> as a member of the list
    of substrings, you will get an error:

<programlisting><![CDATA[
    >>> ['a', 'simple', 'example'].join('+')
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    AttributeError: 'list' object has no attribute 'join'
]]></programlisting>
</para>

    <para> For more information on string methods, see the <ulink
    url="http://www.python.org/doc/2.1/lib/string-methods.html">
    Python Library Reference</ulink>. </para>

  </section>

  <section id="list_comprehensions">
    <title> List Comprehensions </title>

    <para> List comprehensions provide a very easy means to manipulate
    lists of elements.  In particular, list comprehensions can be used
    to transform and filter lists.  A simple example of a list
    comprehension is:

<programlisting><![CDATA[
    >>> input = range(10)
    >>> print input
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> print [x*x for x in input] 
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
]]></programlisting>

    In this example, we have produced a new list, where each element
    is obtained by squaring an element in the input list.  Using this
    pattern, we can perform a number of different transformations to
    lists.  For example, we can convert every word in a list of words
    to lower case.  This might be useful if we want to ensure that
    "The" and "the" are treated as the same word.

<programlisting><![CDATA[
    >>> input = ['The', 'dog', 'gave', 'John', 'the', 'newspaper'] 
    >>> [word.lower() for word in input] 
    ['the', 'dog', 'gave', 'john', 'the', 'newspaper']
]]></programlisting>
</para>

    <para> List comprehensions can also be used to filter lists.  For
    example, the following command picks out all the even numbers from
    a list:

<programlisting><![CDATA[
    >>> input = range(10) 
    >>> [x for x in input if x%2==0] 
    [0, 2, 4, 6, 8]
]]></programlisting>

    As another example, we could remove all determiners from a list of
    words:

<programlisting><![CDATA[
    >>> def is_determiner(word): 
    ...     return word.lower() in ('a', 'an', 'the') 

    >>> input = ['The', 'dog', 'gave', 'John', 'the', 'newspaper'] 
    >>> [word for word in input if not is_determiner(word)] 
    ['dog', 'gave', 'John', 'newspaper']
]]></programlisting>
</para>

    <para> Transformations and filtering can easily be combined:

<programlisting><![CDATA[
    >>> numbers = range(10) 
    >>> [x*x for x in numbers if x%2==0] 
    [0, 4, 16, 36, 64]

    >>> words = ['The', 'dog', 'gave', 'John', 'the', 'newspaper'] 
    >>> [word.lower() for word in words if not is_determiner(word)] 
    ['dog', 'gave', 'john', 'newspaper']
]]></programlisting>
</para>

    <para> Finally, list comprehensions can iterate over multiple
    lists.  In this case, it will compute the function once for each
    <emphasis>pair</emphasis> of elements:

<programlisting><![CDATA[
    >>> xs = range(3) 
    >>> ys = range(4) 
    >>> [(x,y) for x in xs for y in ys] 
    [(0, 0), (0, 1), (0, 2), (0, 3),
     (1, 0), (1, 1), (1, 2), (1, 3),
     (2, 0), (2, 1), (2, 2), (2, 3)]
]]></programlisting>
</para>

    <para> For more information on list comprehensions, see the <ulink
    url="http://www.python.org/2.0/new-python.html#SECTION000600000000000000000">
    What's New in Python 2.0</ulink> or <ulink
    url="http://www.python.org/doc/current/tut/node7.html#SECTION007140000000000000000">
    the Python Tutorial</ulink>. </para>

  </section>

</article>
