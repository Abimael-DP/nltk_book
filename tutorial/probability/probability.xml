<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//Norman Walsh//DTD DocBk XML V3.1.3//EN" "/usr/lib/sgml/dtd/docbook-xml/docbookx.dtd" [
<!ENTITY prompt "<prompt>&gt;&gt;&gt;</prompt>">
]>

<article>
  <artheader>
    <author><firstname>Edward</firstname><surname>Loper</surname></author>
    <authorinitials>edl</authorinitials>
    <title>NLTK Tutorial: Probability</title>
  </artheader>

  <section> <title> Experiments and Samples </title>

    <para> The <literal>nltk.probability</literal> module can be used
    to model probablistic phenomena.  Most probablistic phenomena can
    be thought of as experiments.  An
    <glossterm>experiment</glossterm> is any process which leads to a
    well-defined outcome.  For example, rolling a die is an experiment
    whose possible outcomes are 1, 2, 3, 4, 5, and 6.
    </para>
    
    <para> A <glossterm>sample</glossterm> is any possible outcome of
    a given experiment.  In <literal>nltk.probability</literal>,
    almost any Python value or object can be a sample.

    <footnote><para>Samples must be immutable objects; and can not be
    Events.  See the reference documentation for <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.html">
    <literal>nltk.probability</literal></ulink> for more
    information.</para></footnote>

    Typical samples are strings, integers, Tokens, and tuples.  We can
    use a simple Python procedure to define the experiment of rolling
    a die; its samples are 1, 2, 3, 4, 5, and 6:
    </para>

<screen>
    &prompt;<command> import random</command>
    &prompt;<command> def roll():</command>
    <prompt>...</prompt><command>     return random.choice( [1, 2, 3, 4, 5, 6] )</command>
    &prompt;<command> roll()</command>
    4
</screen>

  </section>
  <section> <title>Events</title>

    <para> An event is a set of samples.  For example, the set of all
    even die outcomes is an event.  Events are written using standard
    set notation: 

<screen>
    {Event 1, 2, 3, 6}        <comment>The event containing samples 1, 2, 3, and 6</comment>
    {Event x: x&lt;3}            <comment>The event containing all samples that are less than 3</comment>
    {Event x: x is even}      <comment>The event containing all even samples</comment>
</screen>

    Events usually contain more than one sample; but sometimes they
    will contain ony one sample, or will contain no samples at all.
    </para>

    <section> <title> Simple Events </title>
    
      <para> The <literal>nltk.probability</literal> module defines a
      collection of <literal>Event</literal> classes for representing
      events in different ways.  Events are used throughout the
      <literal>probability</literal> module to define and maniuplate
      probability distributions.  The simplest types of event are
      <literal>SampleEvent</literal>s, which just consist of a single
      sample:

<screen>
    &prompt;<command> SampleEvent(3)</command>
    {Event 3}
    &prompt;<command> SampleEvent('dog')</command>
    {Event 'dog'}
</screen>
      </para>
      
      <para> Events can also be defined in terms of
      <literal>Set</literal>s, using the <literal>SetEvent</literal>
      class:

<screen>
    &prompt;<command> SetEvent( Set(1, 3, 5) )</command>
    {Event 3, 1, 5}
    &prompt;<command> SetEvent( Set(1, 12) | Set(5, 7) )</command>
    {Event 5, 1, 12, 7}
</screen>
      </para>
      
      <para> <literal>NullEvent</literal> is used to represent the
      event containing no samples; and
      <literal>UniversalEvent</literal> is used to represent the event
      containing all samples:

<screen>
    &prompt;<command> NullEvent()</command>
    {Event}
    &prompt;<command> UniversalEvent()</command>
    {Event x}
</screen>

      The <literal>UniversalEvent</literal> is different from all the
      other types of events we have seen, since it can contain an
      infinite set of samples.  For example, for an experiment that
      can generate any integer as an outcome,
      <literal>UniversalEvent</literal> contains the set of all
      integers. </para>

    </section>

    <section> <title> Using Events</title>

      <para> To test whether an event contains a sample, use the
      <literal>contains</literal> method:

<screen>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.contains(5)</command>
    1
    &prompt;<command> event.contains(9)</command>
    0
</screen>
      </para>

      <para> Events can be compared using the <literal>==</literal>
      operator, the <literal>!=</literal> operator, the
      <literal>subset</literal> method, and the
      <literal>superset</literal> method:

<screen>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 7))</command>
    &prompt;<command> event3 = SetEvent(Set(12, 3, 5, 2))</command>
    &prompt;<command> event1 == event2</command>               <comment>Is event1 equal to event2?</comment>
    0
    &prompt;<command> event1 != event2</command>               <comment>Is event1 not equal to event2?</comment>
    1
    &prompt;<command> event1.superset(event2)</command>        <comment>Is event1 a superset of event2?</comment>
    1
    &prompt;<command> event2.subset(event1)</command>          <comment>Is event2 a subset of event1?</comment>
    1
    &prompt;<command> event3.superset(event2)</command>        <comment>Is event3 a superset of event2?</comment>
    0
    &prompt;<command> event2.subset(event3)</command>          <comment>Is event2 a subset of event3?</comment>
    0
</screen>
      </para>

      <para> Events can be combined using the
      <literal>union</literal>, <literal>intersection</literal>, and
      <literal>difference</literal> methods:

<screen>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 2, 7))</command>
    &prompt;<command> event1.union(event2)</command>
    {Event 1, 2, 4, 5, 7}
    &prompt;<command> event1.intersection(event2)</command>
    {Event 1, 2, 7}
    &prompt;<command> event1.difference(event2)</command>
    {Event 4, 5}
</screen>
      </para>

      <para> To retrieve the set of samples that compose an event, use
      the <literal>samples</literal> method; and to retrieve the
      number of samples contained in an event, use the
      <literal>size</literal> method:

<screen>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.samples()</command>
    {1, 4, 5, 7}
    &prompt;<command> event.size()</command>
    4
</screen>
      </para>

      <para> Many of these member functions can also be accessed via an operator:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Method</entry><entry>Corresponding operator</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal><replaceable>event</replaceable>.contains(
                       <replaceable>sample</replaceable> )</literal></entry>
                <entry><literal><replaceable>sample</replaceable> in 
                       <replaceable>event</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.subset(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &lt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.super(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &gt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.union(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> | 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.intersection(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> ^ 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.difference(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> - 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.len()</literal></entry>
                <entry><literal>len(<replaceable>event1</replaceable>)</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>

      <para> Sometimes it is impossible to perform one of these
      operations on some types of events.  For example, an event
      containing an infinite number of samples could not possibly
      implement the <literal>samples</literal> method.  Therefore,
      most of the operations described above are optional; if they are
      not implemented for a given type of event, then using them will
      generate a <literal>NotImplementedError</literal> exception. </para>

      <para> In particular, only the <literal>contains</literal>
      method and the <literal>in</literal> operator are guaranteed to
      work on any event.  However, all of the <literal>Event</literal>
      classes in the toolkit implement all of the optional methods,
      with the following exceptions:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Event Type</entry><entry>Methods Not Implemented</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal>PredEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>subset</literal>, <literal>superset</literal>, 
                       <literal>samples</literal>, <literal>len</literal> operator</entry>
              </row>
              <row>
                <entry><literal>UniversalEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>samples</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      
    <para> See the reference documentation for  <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.EventI.html">
    <literal>EventI</literal></ulink> for more information on how to use
    events.</para>

    </section>

    <section> <title> Predicated Events</title>
      
      <para> Predicated events are events defined in terms of a
      <glossterm>predicate</glossterm>, or a function that tests
      whether a sample is contained in the event.  Examples of
      predicated events are:

<screen>
    {Event x: x&gt;8}            <comment>The event containing all samples </comment>
                                  <comment>that are greater than 8</comment>
    {Event x: x is odd}       <comment>The event containing all odd samples</comment>
</screen>

      The first event's predicate tests whether a sample is greater
      than <replaceable>x</replaceable>.  The second event's predicate
      tests whether <replaceable>x</replaceable> is odd.  In both
      cases, the events contains all samples that make their predicate
      true. </para>

      <para> Predicated events are constructed using the
      <literal>PredEvent</literal> class.  The
      <literal>PredEvent</literal> constructor expects a single
      predicate function, which will return <literal>true</literal>
      for all samples contained in the new event.

<screen>
    &prompt;<command> def gt8(x): return x&gt;8</command>        <comment>Define an function to test</comment>
                                      <comment>if a sample is greater than 8</comment>
    &prompt;<command> def odd(x): return x%2 == 1</command>   <comment>Define an "odd" function</comment>
    &prompt;<command> oddEvent = PredEvent(odd)</command>
    {Event x: odd(x)}
    &prompt; <command>233 in oddEvent</command>
    1
    &prompt; <command>104 in oddEvent</command>
    0
    &prompt;<command> gt8Event = PredEvent(gt8)</command>
    {Event x: gt8(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</screen>
      </para>

      <para> Predicated events can also be constructed directly from
      expressions using "lambda" functions (also known as "anonymous"
      functions):

<screen>
    &prompt;<command> gt8Event = PredEvent(lambda x: x>8)</command>
    {Event x: &lt;lambda&gt;(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</screen>
      </para>

    </section>
    
  </section>

  <section> <title> Frequency Distributions </title>
    <para></para>
  </section>

  <section> <title> Probability Distributions </title>
    <para></para>
  </section>

</article>
