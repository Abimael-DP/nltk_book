<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" [
<!ENTITY prompt "<prompt>&gt;&gt;&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  
  <articleinfo>
    <author><firstname>Edward</firstname><surname>Loper</surname></author>
    <authorinitials>edl</authorinitials>
    <title>NLTK Tutorial: Probability</title>
  </articleinfo>

  <section> <title> Experiments and Samples </title>

    <para> The <literal>nltk.probability</literal> module can be used
    to model probablistic phenomena.  Most probablistic phenomena can
    be thought of as experiments.  An
    <glossterm>experiment</glossterm> is any process which leads to a
    well-defined outcome.  For example, rolling a die is an experiment
    whose possible outcomes are 1, 2, 3, 4, 5, and 6.
    </para>
    
    <para> A <glossterm>sample</glossterm> is any possible outcome of
    a given experiment.  In <literal>nltk.probability</literal>,
    almost any Python value or object can be a sample.

    <footnote><para>Samples must be immutable objects; and can not be
    Events.  See the reference documentation for <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.html">
    <literal>nltk.probability</literal></ulink> for more
    information.</para></footnote>

    Typical samples are strings, integers, Tokens, and tuples.  We can
    use a simple Python procedure to define the experiment of rolling
    a die; its samples are 1, 2, 3, 4, 5, and 6:
    </para>

<screen>
    &prompt;<command> import random</command>
    &prompt;<command> def roll():</command>
    <prompt>...</prompt><command>     return random.choice( [1, 2, 3, 4, 5, 6] )</command>
    &prompt;<command> roll()</command>
    4
</screen>

  </section>
  <section> <title>Events</title>

    <para> An event is a set of samples.  For example, the set of all
    even die outcomes is an event.  Events are written using standard
    set notation: 

<screen>
    {Event 1, 2, 3, 6}        <emphasis>The event containing samples 1, 2, 3, and 6</emphasis>
    {Event x: x&lt;3}            <emphasis>The event containing all samples that are less than 3</emphasis>
    {Event x: x is even}      <emphasis>The event containing all even samples</emphasis>
</screen>

    Events usually contain more than one sample; but sometimes they
    will contain ony one sample, or will contain no samples at all.
    </para>

    <section> <title> Simple Events </title>
    
      <para> The <literal>nltk.probability</literal> module defines a
      collection of <literal>Event</literal> classes for representing
      events in different ways.  Events are used throughout the
      <literal>probability</literal> module to define and maniuplate
      probability distributions.  The simplest types of event are
      <literal>SampleEvent</literal>s, which just consist of a single
      sample:

<screen>
    &prompt;<command> SampleEvent(3)</command>
    {Event 3}
    &prompt;<command> SampleEvent('dog')</command>
    {Event 'dog'}
</screen>
      </para>
      
      <para> Events can also be defined in terms of
      <literal>Set</literal>s, using the <literal>SetEvent</literal>
      class:

<screen>
    &prompt;<command> SetEvent( Set(1, 3, 5) )</command>
    {Event 3, 1, 5}
    &prompt;<command> SetEvent( Set(1, 12) | Set(5, 7) )</command>
    {Event 5, 1, 12, 7}
</screen>
      </para>
      
      <para> <literal>NullEvent</literal> is used to represent the
      event containing no samples; and
      <literal>UniversalEvent</literal> is used to represent the event
      containing all samples:

<screen>
    &prompt;<command> NullEvent()</command>
    {Event}
    &prompt;<command> UniversalEvent()</command>
    {Event x}
</screen>

      The <literal>UniversalEvent</literal> is different from all the
      other types of events we have seen, since it can contain an
      infinite set of samples.  For example, for an experiment that
      can generate any integer as an outcome,
      <literal>UniversalEvent</literal> contains the set of all
      integers. </para>

    </section>

    <section> <title> Using Events</title>

      <para> To test whether an event contains a sample, use the
      <literal>contains</literal> method:

<screen>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.contains(5)</command>
    1
    &prompt;<command> event.contains(9)</command>
    0
</screen>
      </para>

      <para> Events can be compared using the <literal>==</literal>
      operator, the <literal>!=</literal> operator, the
      <literal>subset</literal> method, and the
      <literal>superset</literal> method:

<screen>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 7))</command>
    &prompt;<command> event3 = SetEvent(Set(12, 3, 5, 2))</command>
    &prompt;<command> event1 == event2</command>               <emphasis>Is event1 equal to event2?</emphasis>
    0
    &prompt;<command> event1 != event2</command>               <emphasis>Is event1 not equal to event2?</emphasis>
    1
    &prompt;<command> event1.superset(event2)</command>        <emphasis>Is event1 a superset of event2?</emphasis>
    1
    &prompt;<command> event2.subset(event1)</command>          <emphasis>Is event2 a subset of event1?</emphasis>
    1
    &prompt;<command> event3.superset(event2)</command>        <emphasis>Is event3 a superset of event2?</emphasis>
    0
    &prompt;<command> event2.subset(event3)</command>          <emphasis>Is event2 a subset of event3?</emphasis>
    0
</screen>
      </para>

      <para> Events can be combined using the
      <literal>union</literal>, <literal>intersection</literal>, and
      <literal>difference</literal> methods:

<screen>
    &prompt;<command> event1 = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event2 = SetEvent(Set(1, 2, 7))</command>
    &prompt;<command> event1.union(event2)</command>
    {Event 1, 2, 4, 5, 7}
    &prompt;<command> event1.intersection(event2)</command>
    {Event 1, 2, 7}
    &prompt;<command> event1.difference(event2)</command>
    {Event 4, 5}
</screen>
      </para>

      <para> To retrieve the set of samples that compose an event, use
      the <literal>samples</literal> method; and to retrieve the
      number of samples contained in an event, use the
      <literal>len</literal> method:

<screen>
    &prompt;<command> event = SetEvent(Set(1, 4, 5, 7))</command>
    &prompt;<command> event.samples()</command>
    {1, 4, 5, 7}
    &prompt;<command> event.len()</command>
    4
</screen>
      </para>

      <para> Many of these member functions can also be accessed via an operator:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Method</entry><entry>Corresponding operator</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal><replaceable>event</replaceable>.contains(
                       <replaceable>sample</replaceable> )</literal></entry>
                <entry><literal><replaceable>sample</replaceable> in 
                       <replaceable>event</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.subset(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &lt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.superset(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> &gt;= 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.union(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> | 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.intersection(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> ^ 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.difference(
                       <replaceable>event2</replaceable> )</literal></entry>
                <entry><literal><replaceable>event1</replaceable> - 
                       <replaceable>event2</replaceable></literal></entry>
              </row>
              <row>
                <entry><literal><replaceable>event1</replaceable>.len()</literal></entry>
                <entry><literal>len(<replaceable>event1</replaceable>)</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>

      <para> Sometimes it is impossible to perform one of these
      operations on some types of events.  For example, an event
      containing an infinite number of samples could not possibly
      implement the <literal>samples</literal> method.  Therefore,
      most of the operations described above are optional; if they are
      not implemented for a given type of event, then using them will
      generate a <literal>NotImplementedError</literal> exception. </para>

      <para> In particular, only the <literal>contains</literal>
      method and the <literal>in</literal> operator are guaranteed to
      work on any event.  However, all of the <literal>Event</literal>
      classes in the toolkit implement all of the optional methods,
      with the following exceptions:

        <informaltable colsep="5">
          <tgroup cols="2">
            <thead><row><entry>Event Type</entry><entry>Methods Not Implemented</entry></row>
            </thead>
            <tbody>
              <row>
                <entry><literal>PredEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>subset</literal>, <literal>superset</literal>, 
                       <literal>samples</literal>, <literal>len</literal> operator</entry>
              </row>
              <row>
                <entry><literal>UniversalEvent</literal></entry>
                <entry><literal>==</literal> operator, <literal>!=</literal> operator, 
                       <literal>samples</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
      
    <para> See the reference documentation for  <ulink
    url="http://nltk.sourceforge.net/ref/nltk.probability.EventI.html">
    <literal>EventI</literal></ulink> for more information on how to use
    events.</para>

    </section>

    <section> <title> Predicated Events</title>
      
      <para> Predicated events are events defined in terms of a
      <glossterm>predicate</glossterm>, or a function that tests
      whether a sample is contained in the event.  Examples of
      predicated events are:

<screen>
    {Event x: x&gt;8}            <emphasis>The event containing all samples </emphasis>
                                  <emphasis>that are greater than 8</emphasis>
    {Event x: x is odd}       <emphasis>The event containing all odd samples</emphasis>
</screen>

      The first event's predicate tests whether a sample is greater
      than <replaceable>x</replaceable>.  The second event's predicate
      tests whether <replaceable>x</replaceable> is odd.  In both
      cases, the events contains all samples that make their predicate
      true. </para>

      <para> Predicated events are constructed using the
      <literal>PredEvent</literal> class.  The
      <literal>PredEvent</literal> constructor expects a single
      predicate function, which will return <literal>true</literal>
      for all samples contained in the new event.

<screen>
    &prompt;<command> def gt8(x): return x&gt;8</command>        <emphasis>Define an function to test</emphasis>
                                      <emphasis>if a sample is greater than 8</emphasis>
    &prompt;<command> def odd(x): return x%2 == 1</command>   <emphasis>Define an "odd" function</emphasis>
    &prompt;<command> oddEvent = PredEvent(odd)</command>
    {Event x: odd(x)}
    &prompt; <command>233 in oddEvent</command>
    1
    &prompt; <command>104 in oddEvent</command>
    0
    &prompt;<command> gt8Event = PredEvent(gt8)</command>
    {Event x: gt8(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</screen>
      </para>

      <para> Predicated events can also be constructed directly from
      expressions using "lambda" functions (also known as "anonymous"
      functions):

<screen>
    &prompt;<command> gt8Event = PredEvent(lambda x: x>8)</command>
    {Event x: &lt;lambda&gt;(x)}
    &prompt;<command> 10 in gt8Event</command>
    1
    &prompt;<command> 5 in gt8Event</command>
    0
</screen>
      </para>

    </section>
    
  </section>

  <section> <title> Frequency Distributions </title>

    <para> A frequency distribution records the number of times each
    outcome of an experiment has occured.  For example, a frequency
    distribution could be used to record the frequency of each word
    type in a document. </para>

    <section> <title> Construction a Frequency Distribution </title>

      <para> Frequency distributions are generally constructed by
      running a number of experiments, and incrementing the count for
      a sample every time it is an outcome of an experiment.  For
      example, the following code will produce a frequency
      distribution that encodes how often each word type occurs in a
      text:

<screen>
    &prompt;<command> freq_dist = SimpleFreqDist()</command>
    &prompt;<command> for token in document:</command>
    &prompt2;<command>     freq_dist.inc(token.type())</command>
</screen>
</para>

    </section>
    <section> <title> Using a Frequency Distribution </title>

      <para> Once we construct a frequency distribution that models a
      system, we can use it to find a number of interesting system
      properties.  This section describes the most important accessors
      that are currently supported by frequency distrutions.  This
      list is likely to grow as the toolkit is developed. </para>

      <para> We can find the number of times a given sample or event
      occured with the <literal>count</literal> method:

<screen>
    <emphasis># How many times did "the" occur?</emphasis>
    &prompt;<command> freq_dist.count('the')</command>
    6

    <emphasis># How many times did a determiner occur?</emphasis>
    &prompt;<command> def is_determiner(wtype):</command>
    &prompt2;<command>     return wtype.lower() in ('a', 'an', 'the')</command>
    &prompt;<command> freq_dist.count(PredEvent(is_determiner))</command>
    10
</screen>
</para>

      <para> The <literal>freq</literal> method tells us the frequency
      of a given sample or event:

<screen>
    <emphasis># What was the frequency of the word "the"?</emphasis>
    &prompt;<command> freq_dist.freq('the')</command>
    0.012

    <emphasis># How frequent were determiners?</emphasis>
    &prompt;<command> def is_determiner(wtype):</command>
    &prompt2;<command>     return wtype.lower() in ('a', 'an', 'the')</command>
    &prompt;<command> freq_dist.freq(PredEvent(is_determiner))</command>
    0.020
</screen>
</para>

      <para> We can find the total number of sample outcomes recorded
      by a frequency distribution with the <literal>N</literal>
      method:

<screen>
    <emphasis># How many words were counted? </emphasis>
    &prompt;<command> freq_dist.N()</command>
    500
</screen>
</para>

      <para> The <literal>samples</literal> method returns a list of
      all samples that have been recorded as outcomes by this
      frequency distribution:

<screen>
    <emphasis># What words were encountered? </emphasis>
    &prompt;<command> freq_dist.samples()[:5]</command>
    ['happy', 'but', 'the', 'in', 'of']
</screen>
</para>

      <para> We can find the sample with the greatest number of
      outcomes with the <literal>max</literal> method:

<screen>
    &prompt;<command> freq_dist.max()</command>
    <emphasis># What was the most common word? </emphasis>
    'the'
</screen>
</para>

      <para> We can find the conditional frequency of a sample or
      event, given another sample or event, with the
      <literal>cond_freq</literal> method:

<screen>
    <emphasis># What's the probability that a word is "the" given that it's a determiner?</emphasis>
    &prompt;<command> freq_dist.condFreq('the', PredEvent(is_determiner))</command>
    0.6
</screen>
</para>

      <para> The <literal>cond_max</literal> method allows us to find
      the sample with the most outcomes, given some conditioning
      event: 

<screen>
    <emphasis># What's the most common word that's more than 6 letters long?</emphasis>
    &prompt;<command> def longer_than_6(wtype):</command>
    &prompt2;<command>     return len(wtype)>6</command>
    &prompt;<command> freq_dist.condMax(PredEvent(longer_than_6))</command>
    'running'
</screen>
</para>

      <para> See the reference documentation for <ulink
      url="http://nltk.sourceforge.net/ref/nltk.probability.FreqDistI.html">
      <literal>FreqDistI</literal></ulink> for more information on
      how to use frequency distributions.</para>
    </section> <!-- Using Frequency Distributions -->

<!--
    <section> <title> Example: Applying Frequency Distributions </title>

      <para> In this section, we explore the relationship between two
      properties of a word: its length, and whether or not it ends in
      a vowel.  We construct a frequency distribution of words, and
      use it to plot the frequency with which words of different
      lengths end in vowels. </para>

      <para> To begin with, we load a corpus from a text file:
<screen>
    &prompt;<command> corpus = open('corpus.txt').read() </command>
    &prompt;<command> tokens = WSTokenizer().tokenize(corpus) </command>
</screen>
</para>

      <para> From this text file, we can construct a frequency
      distribution.  To save time later, we'll also keep track of the
      maximum word length.

<screen>
    &prompt;<command> freq_dist = SimpleFreqDist()</command>
    &prompt;<command> max_wordlen = 0</command>
    &prompt;<command> for token in tokens:</command>
    &prompt2;<command>     freq_dist.inc(token.type())</command>
    &prompt2;<command>     max_wordlen = max(max_wordlen, len(token.type()))</command>
</screen>
</para>

      <para> Next, we define a predicated event, that includes all word
      types that end in vowels (for this example, we define vowels as
      "a", "e", "i", "o", and "u"):

<screen>
    &prompt;<command> def ends_in_vowel(wtype):</command>
    &prompt2;<command>     return wtype[-1].lower() in ('a', 'e', 'i', 'o', 'u')
</screen>

      The second 

 We will use this event to find
      the conditional probabilities that we are interested in (namely,
      the probability that a word ends in a vowel, given that it has a given length)

<screen>
    &prompt;<command> def ends_in_vowel(wtype):</command>
    &prompt2;<command>     return wtype[-1].lower() in ('a', 'e', 'i', 'o', 'u')
</screen>
</para>

-->

  </section> <!-- Frequency Distributions -->

  <section> <title> Probability Distributions </title>
    <para>(under construction)</para>
  </section> <!-- Probability Distributions -->

</article>
