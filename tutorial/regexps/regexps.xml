<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"../../docbook/sgml/docbook/xml-dtd-4.2/docbookx.dtd" [
<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "http://nltk.sourceforge.net/api/public">
<!ENTITY tutdoc "http://nltk.sourceforge.net/tutorial">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Copyright & License -->
<!ENTITY copyright SYSTEM "../copyright.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Steven</firstname><surname>Bird</surname></author>
    <authorinitials>sb</authorinitials>
    <author><firstname>Ewan</firstname><surname>Klein</surname></author>
    <authorinitials>ek</authorinitials>
    <title>NLTK Tutorial: Regular Expressions</title>
    &copyright;
  </articleinfo>

<!-- ********************** Regular Expressions ******************* -->

<section id="overview">
<title>Overview</title>

<para> This chapter provides an introduction to regular expressions
illustrated with examples from language processing.
    
<footnote>
<para>For a more concise introduction please see the Python
documentation <ulink
		     url="http://www.python.org/doc/current/lib/module-re.html"> re -- Regular expression operations</ulink>.</para>
</footnote>
</para>

<para>
We have already noted that a text can be viewed as a string of
characters. What kinds of processing are performed at the character
level?  Perhaps word games are the most familiar example of such
processing.  In completing a crossword we may want to know which
3-letter English words end with the letter <literal>c</literal> (e.g.
<literal>arc</literal>).  We might want to know how many words can be
formed from the letters: <literal>a</literal>, <literal>c</literal>,
<literal>e</literal>, <literal>o</literal>, and <literal>n</literal>
(e.g. <literal>ocean</literal>).  We may want to find out which unique
English word contains the substring <literal>gnt</literal> (left as an
exercise for the reader).  In all these examples, we are considering
which word &mdash; drawn from a large set of candidates &mdash; matches
a given pattern. To put this in a more computational framework, we could
imagine searching through a large digital corpus in order to find all
words that match a particular pattern. There are many serious uses of
this so-called <glossterm>pattern matching</glossterm>.  
</para>

<para>
One instructive example (due to <citation>Friedl:2002:MRA</citation>) is
the task of finding all doubled words in a text; an example would be the
string <literal>for for example</literal>. Notice that we would be
particularly interested in finding cases where the words were split
across a linebreak (in practise, most erroneously doubled words occur in
this context). Consequently, even with such a relatively banal task, we
need to be able to describe patterns which refer not just to
<quote>ordinary</quote> characters, but also to formatting information.
</para>

<para>
There are conventions for indicating structure in strings, also known as
<glossterm>formatting</glossterm>. For example, there are a number of
alternative ways of formatting a <quote>date string</quote>, such as
<literal>23/06/2002</literal>,
<literal>6/23/02</literal>, or <literal>2002-06-23</literal>.  Whole
texts may be formatted, such as an email message which contains header
fields followed by the message body. Another familiar form of formatting
involves visual structure, such as tabular format and bulleted
lists.</para>

<para>Finally, texts may contain explicit <quote>markup</quote>, such as
<sgmltag class="starttag">abbrev</sgmltag>Phil<sgmltag
class="endtag">abbrev</sgmltag>, which provides information about the
interpretation or presentation of some piece of text.  To summarize, in
language processing, strings are ubiquitous, and they often contain
important structure.
</para>

<!--
<para>
... stuff on tokenization moved earlier

Alternatively, we may want to compute the relative frequency of
particular letters in the text in order to guess the language of the
text.  For this we must total up the number of matches for each
character of interest.

</para>
-->

<para> So far we have seen elementary examples of pattern matching, the
matching of individual characters.  More often we are interested in
matching <emphasis>sequences</emphasis> of characters.  For example,
part of the operation of a naive spell-checker could be to remove a
word-final <literal>s</literal> from a suspect word token, in case the
word is a plural, and see if the putative singular form exists in the
dictionary.  For this we must locate <literal>s</literal> and remove it,
but only if it precedes a word boundary.  This requires matching a
pattern consisting of two characters.
</para>

<para> Beyond this pattern matching on the <emphasis>content</emphasis>
of a text, we often want to process the <emphasis>formatting</emphasis>
and <emphasis>markup</emphasis> of a text.  We may want to check the
formatting of a document (e.g. to ensure that every sentence begins with
a capital letter) or to reformat a document (e.g. replacing sequences of
space characters with a single space).  We may want to find all date
strings and extract the year.  We may want to extract all words
contained inside the <sgmltag class="starttag">abbrev</sgmltag> <sgmltag
class="endtag">abbrev</sgmltag> markup in order to construct a list of
abbreviations.
</para>

<para> Processing the content, format and markup of strings is a central
task in most kinds of NLP.  The most widespread method for string
processing uses <glossterm>regular expressions</glossterm>.
    </para>

</section> <!-- Overview -->

<section id="simple"> 
<title> Simple Regular Expressions </title>

<para>In this section we will see the building blocks for simple regular
expressions, along with a selection of linguistic examples. We can think
of a regular expression as <emphasis>a specialised notation for
describing patterns that we want to match</emphasis>. In order to make
explicit when we are talking about a pattern <varname>patt</varname>, we
will use the notation &ulcorn;<literal>patt</literal>&drcorn;. The first
thing to say about regular expressions is that most letters match
themselves. For example, the pattern
&ulcorn;<literal>sing</literal>&drcorn; exactly matches the string
<literal>sing</literal>. In addition, regular expressions provide us
with a set of <emphasis>special characters</emphasis>
<footnote>
<para>
These are often called <glossterm>metacharacters</glossterm>; that is,
characters which express properties of (ordinary) characters.
</para>
</footnote>

which give us a
way to match <emphasis>sets of strings</emphasis>, and we will now look
at these.
</para>

<section id="dot">
<title>The Wildcard</title>

<para> The <quote><literal>.</literal></quote> symbol is called a
<firstterm>wildcard</firstterm>: it matches any single character. For
example, the regular expression &ulcorn;<literal>s.ng</literal>&drcorn;
matches the following English words: <literal>sang</literal>,
<literal>sing</literal>, <literal>song</literal>, and
<literal>sung</literal>. Note that &ulcorn;<literal>.</literal>&drcorn;
will match not only alphabetic characters, but also numeric and
whitespace characters. Consequently,
&ulcorn;<literal>s.ng</literal>&drcorn; will also match non-words such as
<literal>s3ng</literal>.
</para>

<para> We can also use the wildcard symbol for counting characters. For
instance &ulcorn;<literal>....zy</literal>&drcorn; matches six-letter
strings that end in <literal>zy</literal>.  The pattern
&ulcorn;<literal>....berry</literal>&drcorn; finds words like
<literal>cranberry</literal>. In our example text <xref
linkend="wsj_0034"/>, the pattern
&ulcorn;<literal>t...</literal>&drcorn; will match the words
<literal>that</literal> and <literal>term</literal>, and will also match
the word sequence <literal>to a</literal> (since the third
"<literal>.</literal>" in the pattern can match the space character).
<example id="wsj_0034">
<title>Paragraph 12 from <filename>wsj_0034</filename></title>
<literallayout>
It's probably worth paying a premium for funds that invest in markets
that are partially closed to foreign investors, such as South Korea,
some specialists say.  But some European funds recently have
skyrocketed; Spain Fund has surged to a startling 120% premium.  It has
been targeted by Japanese investors as a good long-term play tied to
1992's European economic integration.  And several new funds that aren't
even fully invested yet have jumped to trade at big premiums.

"I'm very alarmed to see these rich valuations," says Smith Barney's
Mr. Porter.
</literallayout>
</example>
</para>

<note><para> Note that &ulcorn;<literal>.</literal>&drcorn; matches
<emphasis>exactly</emphasis> one character, and must be repeated for as
many characters as should be matched.  To match a variable number of
characters we must use notation for <emphasis>optionality</emphasis>.
</para></note>

</section>

<section id="qmk">
<title>Optionality</title>

<para> The <quote><literal>?</literal></quote> symbol indicates that the immediately
preceding regular expression is optional.  The regular expression
&ulcorn;<literal>colou?r</literal>&drcorn; matches both British and
American spellings, <literal>colour</literal> and
<literal>color</literal>.  The expression that precedes the
<literal>?</literal> may be punctuation, such as an optional hyphen.
For instance &ulcorn;<literal>e-?mail</literal>&drcorn; matches both
<literal>e-mail</literal> and <literal>email</literal>.
      </para>

</section>

<section id="plus">
<title>Repeatability</title>

<para> The "<literal>+</literal>" symbol indicates that the immediately
preceding expression is repeatable, up to an arbitrary number of times.
For example, the regular expression
&ulcorn;<literal>coo+l</literal>&drcorn; matches
<literal>cool</literal>, <literal>coool</literal>, and so on.  This
symbol is particularly effective when combined with the
<literal>.</literal> symbol.  For example,
&ulcorn;<literal>f.+f</literal>&drcorn; matches all strings of length
greater than two, that begin
and end with the letter <literal>f</literal> (e.g.
<literal>foolproof</literal>).  The expression
&ulcorn;<literal>.+ed</literal>&drcorn; finds strings that potentially
have the past-tense <literal>-ed</literal> suffix.
      </para>

<para> The <quote><literal>*</literal></quote> symbol indicates that the immediately
preceding expression is both optional and repeatable. For example
&ulcorn;<literal>.*gnt.*</literal>&drcorn; matches all strings that
contain <literal>gnt</literal>. 
      </para>



</section>

<section id="choices">
<title>Choices</title>

<para> Patterns using the wildcard symbol are very effective, but there
are many instances where we want to limit the set of characters that the
wildcard can match.  In such cases we can use the <literal>[]</literal>
notation, which enumerates the set of characters to be matched &mdash;
this is called a <firstterm>character class</firstterm>.  For example,
we can match any English vowel, but no consonant, using
&ulcorn;<literal>[aeiou]</literal>&drcorn;. Note that this pattern can
be interpreted as saying <quote>match <literal>a</literal> or
<literal>e</literal> or &hellip; or <literal>u</literal></quote>; that
is, the pattern resembles the wildcard pattern
&ulcorn;<literal>.</literal>&drcorn; in only matching a string of length
one; unlike the wildcard, it restricts the characters matched to a
specific class (in this case, the vowels).   Note that the order of
vowels in the regular expression is insignificant, and we would have had
the same result with the expression
&ulcorn;<literal>[uoiea]</literal>&drcorn;. As a second example, the
expression &ulcorn;<literal>p[aeiou]t</literal>&drcorn; matches the
words: <literal>pat</literal>, <literal>pet</literal>,
<literal>pit</literal>, <literal>pot</literal>, and
<literal>put</literal>.
</para>

<para> We can combine the <literal>[]</literal> notation with our
notation for repeatability.  For example, expression
&ulcorn;<literal>p[aeiou]+t</literal>&drcorn; matches the words listed
above, along with: <literal>peat</literal>, <literal>poet</literal>, and
<literal>pout</literal>.
</para>

<!--
<note><para> Note that the order of vowels in the regular expression is
insignificant, and we would have had the same result with the expression
&ulcorn;<literal>p[uoiea]+t</literal>&drcorn;.  Thus, inside these
brackets, the characters are interpreted not as a string but as a set of
choices.
</para></note>
-->

<para> Often the choices we want to describe cannot be expressed at the
level of individual characters.  As we will see in [xref to tagging
chapter], different parts of speech are often
<emphasis>tagged</emphasis> using labels from a tagset. In the Brown
tagset, for example, singular nouns have the tag <literal>NN1</literal>,
while plural nouns have the tag <literal>NN2</literal>, while nouns
which are unspecified for number (e.g., <literal>aircraft</literal>) are
tagged <literal>NN0</literal>. So we might use
&ulcorn;<literal>NN.*</literal>&drcorn; as a pattern which will match
any nominal tag. Now, suppose we were processing the output of a tagger
to extract string of tokens corresponding to noun phrases, we might want
to find all nouns (<literal>NN.*</literal>), adjectives
(<literal>JJ.*</literal>), determiners (<literal>DT</literal>) and
cardinals (<literal>CD</literal>), while excluding all other word types
(e.g. verbs <literal>VB.*</literal>).  It is possible, using a single
regular expression, to search for this set of candidates using the
<firstterm>choice operator</firstterm> <literal>|</literal> as follows:
&ulcorn;<literal>NN.*|JJ.*|DT|CD</literal>&drcorn;. This says: match
<literal>NN.*</literal> <emphasis>or</emphasis>
<literal>JJ.*</literal> <emphasis>or</emphasis>
<literal>DT</literal> <emphasis>or</emphasis>
<literal>CD</literal>.
 
</para>

<para> As another example of multi-character choices, suppose that we
wanted to create a program to simplify English prose, replacing rare
words (like <literal>habitation</literal>) with a more frequent,
synonymous word (like <literal>home</literal>).  In this situation, we
need to map from a potentially large set of words to an individual word.
We can match the set of words using the choice operator.  In the case
of the word <literal>home</literal>, we would want to match the regular
expression
&ulcorn;<literal>dwelling|domicile|abode|habitation</literal>&drcorn;.
</para>

<note><para> Note that the choice operator has wide scope, so that
&ulcorn;<literal>abc|def</literal>&drcorn; is a choice between
<literal>abd</literal> and <literal>def</literal>, and not between
<literal>abced</literal> and <literal>abdef</literal>.  The latter
choice must be written using parentheses:
&ulcorn;<literal>ab(c|d)ed</literal>&drcorn;.
</para></note>

</section>

</section>

<section id="intermediate">
<title> More Complex Regular Expressions
</title>

<para>In this section we will cover operators which can be used to
construct more powerful and useful regular expressions.
</para>

<section id="ranges"> <title>Ranges</title>

<para>In <xref linkend="choices"/> we saw how the
<literal>[]</literal> notation could be used to express a set of choices
between individual characters.  Instead of listing each character, it is
also possible to express a <emphasis>range</emphasis> of characters,
using the <literal>-</literal> operator.  For example,
&ulcorn;<literal>[a-z]</literal>&drcorn; matches any lowercase letter.
This allows us to avoid the overpermissive matching we noted above
with the pattern &ulcorn;<literal>t...</literal>&drcorn;. If we were to
use the pattern &ulcorn;<literal>t[a-z][a-z][a-z]</literal>&drcorn;,
then we would no longer match the two word sequence <literal>to a</literal>.
</para>

<para>As expected, ranges can be combined with other operators. For
example &ulcorn;<literal>[A-Z][a-z]*</literal>&drcorn; matches words
that have an initial capital letter followed by any number of lowercase
letters.  The pattern &ulcorn;<literal>20[0-4][0-9]</literal>&drcorn;
matches year expressions in the range 2000 to 2049.
  </para>

<para>Ranges can be combined, e.g.
&ulcorn;<literal>[a-zA-Z]</literal>&drcorn; which matches any lowercase
or uppercase letter.  The expression
&ulcorn;<literal>[b-df-hj-np-tv-z]+</literal>&drcorn; matches words
consisting only of consonants (e.g. <literal>pygmy</literal>).
  </para>

</section>

<section id="complementation"> <title> Complementation </title>

<para>
We just saw that the character class
&ulcorn;<literal>[b-df-hj-np-tv-z]</literal>&drcorn; allows us to match
consonants. However, this expression is quite cumbersome. A better
alternative is to say: let's match anything which isn't a vowel. To do
this, we need a way of expressing
<firstterm>complementation</firstterm>. 

<footnote>
<para>Complementation is a notion drawn from set theory.
Let's assume that our domain of all objects is the set
<varname>U</varname> = &lcub;a, b, c, d, e&rcub;, and let
<varname>V</varname> be the set &lcub;a, e&rcub;. Then the complement of
<varname>V</varname>, often written <varname>V</varname>&apos; is the
result of <quote>subtracting</quote> <varname>V</varname> from
<varname>U</varname>; i.e., the set <varname>V</varname>&apos; =
&lcub;b, c, d &rcub;.</para> </footnote> We do this using the symbol
<quote><literal>^</literal></quote> as the first character within the
class expression <literal>[]</literal>. Let's look at an example.
&ulcorn;<literal>[^aeiou]</literal>&drcorn; is just like our earlier
character class, except now the set of vowels is preceded by
<literal>^</literal>. The expression as a whole is interpreted as
matching anything which <emphasis>fails</emphasis> to match
&ulcorn;<literal>[aeiou]</literal>&drcorn;. In other words, it matches
all lowercase consonants (plus all uppercase letters and non-alphabetic
characters).</para>

<para>As another example, suppose we want to match any string which is
enclosed by the HTML tags for boldface, namely <sgmltag class="starttag">B</sgmltag> and
<sgmltag class="endtag">B</sgmltag>, We might try something like this:
&ulcorn;<literal>&lt;B&gt;.*&lt;/B&gt;</literal>&drcorn;. This would
successfully match <literal>&lt;B&gt;important&lt;/B&gt;</literal>, but
would also match <literal>&lt;B&gt;important&lt;/B&gt; and
&lt;B&gt;urgent&lt;/B&gt;</literal>, since the
&ulcorn;<literal>.*</literal>&drcorn; subpattern will happily match all
the characters from the end of <literal>important</literal> to the end
of <literal>urgent</literal>. One way of ensuring that we only look at
matched pairs of tags would be to use the expression
&ulcorn;<literal>&lt;B&gt;[^<]*&lt;/B&gt;</literal>&drcorn;, where the
chararacter class matches anything other than a left angle bracket.
</para>


<para>Finally, note that character class complementation also works with
ranges. Thus &ulcorn;<literal>[^a-z]</literal>&drcorn; matches
anything other than the lower case alphabetic characters
<literal>a</literal> through <literal>z</literal>.
</para>

</section>

<section id="special"> <title> Common Special Symbols </title>

<para>So far, we have only looked at patterns which match with the
content of character strings. However, it is also useful to be able to
refer to formatting properties of texts. Two important symbols in this
regard are <quote><literal>^</literal></quote> and
<quote><literal>$</literal></quote> which are used to
<emphasis>anchor</emphasis> matches to the beginnings or ends of lines
in a file. 
</para>

<note>
<para><quote><literal>^</literal></quote> has two quite distinct
uses: it is interpreted as complementation when it occurs as the
first symbol within a character class, and as matching the beginning of
lines when it occurs elsewhere in a pattern.</para>
</note>

<para>For example, suppose we wanted to find all the words that
occur at the beginning of lines in  <xref
linkend="wsj_0034"/>. Our first attempt might look like
&ulcorn;<literal>^[A-Za-z]+ </literal>&drcorn;. This says: starting at
the beginning of a line, look for one or more alphabetic characters
(upper or lower case), followed by a space. This will match the words 
<literal>that</literal>, <literal>some</literal>,
<literal>been</literal>, and <literal>even</literal>. However, it fails
to match <literal>It's</literal>, since <literal>'</literal> isn't an
alphabetic character. A second attempt might be &ulcorn;<literal>^[^ ]+
</literal>&drcorn;, which says to match any string starting at the
beginning of a line, followed by one or more characters which are
<emphasis>not</emphasis> the space character, followed by a space. This
matches all the previous words, together with 
<literal>It's</literal>,
<literal>skyrocketed</literal>,
<literal>1992s</literal>,
<literal>I'm</literal> and
<literal>"Mr.</literal>. As a second example, &ulcorn;<literal>
[a-z]*s$</literal>&drcorn; will match words ending in
<literal>s</literal> that occur at the end of a line. Finally, consider
the pattern &ulcorn;<literal>^$</literal>&drcorn;; this matches strings where no
character occurs between the beginning and the end of a line &mdash; in
other words, empty lines!
</para>

<!--
<para>In <xref linkend="intro"/>, we mentioned the problem of
trying to find occurrences of doubled words separated by a line
break. In order to find such cases, we need to a special character to
match linebreaks, and this is accomplished with the symbol
<quote><literal>\n</literal></quote>. Then one way of expressing our
desired pattern would be &ulcorn;<literal>[A-Za-z]+\n</literal>&drcorn;
</para>
<para>^, $, \, \n </para>
-->

<para>
As we have seen, special characters like
<quote><literal>.</literal></quote>,
<quote><literal>*</literal></quote>, <quote><literal>+</literal></quote>
and <quote><literal>$</literal></quote> give us powerful means to
generalise over character strings. But suppose we wanted to match
against a string which itself contains one or more special characters? 
An example would be the arithmetic statement <literal>$5.00 * ($3.05 +
$0.85)</literal>. In this case, we need to resort to the so-called
<glossterm>escape</glossterm> character
<quote><literal>\</literal></quote> (<quote>backslash</quote>). For
example, to match a dollar amount, we might use
&ulcorn;<literal>\$[1-9][0-9]*\.[0-9][0-9]</literal>&drcorn;.
</para>
</section>

</section>

<section id="advanced"> 
<title> Advanced Regular Expressions </title>

<para>greedy vs non-greedy matching</para>

<para>zero-width assertions</para>

<para>more special symbols: \b etc</para>

</section>

<section id="advanced.python_regex"> 
<title> Python Interface </title>

<para>
The Python <application>re</application> module provides a convenient
interface to an underlying regular expression engine. The module allows a
regular expression pattern to be compiled into a object whose methods
can then be called.
</para>

<para>In the next example, we assume that we have a local copy
(i.e., <literal>words</literal>) of the Unix dictionary, which
may be found in the NLTK <filename>data/words</filename> directory.
This file contains over 400,000 words, one per line.
</para>

<programlisting>
<emphasis># Load the regular expression module:</emphasis> 
&prompt;<command>from re import *</command> 

<emphasis># Read a big list of words:</emphasis>
&prompt; <command>words = open('/home/sb/nltk/data/words').read()</command> 

<emphasis># How many words are there?</emphasis>
&prompt; <command>len(words)</command> 409093 

<emphasis># Compile a regexp for words containing a sequence of two 'a's</emphasis>
&prompt; <command>r1 = compile('.*aa.*')</command> 

<emphasis># Find all matches</emphasis> 
&prompt; <command>print r1.findall(words)</command> 
['Afrikaans', 'bazaar', 'bazaars', 'Canaan', 'Haag', 'Haas', 'Isaac', 'Isaacs', 'Isaacson', 'Izaak', 'Salaam', 'Transvaal',
'Waals']
</programlisting>

<para>Suppose now that we want to find all three-letter words ending in
the letter <quote><literal>c</literal></quote>. Our first attempt might
be as follows:
</para>
<programlisting>
<emphasis># Try to compile a regexp for 3-letter words ending in c</emphasis>
&prompt; <command>r1 = compile('..c')</command> 

<emphasis># Find all matches</emphasis> 
&prompt; <command>print r1.findall(words)</command> 
['bac', 'duc', 'duc', 'duc', 'duc', 'duc', 'duc', 'duc', 'anc', 'jec',
'jec', 'jec', 'jec', 'jec', 'eac', 'eac', 'bsc', 'bsc', 'bsc', 'bsc',
'bsc', 'bsc', 'bsc', 'bsc', 'bsc', 'enc', 'enc', 'enc', 'enc', 'rac',
'rac', 'rac', 'rac', 'rac', 'rac', 'rac', 'rac', 'rac', 'rac', 'rac',
'rac', 'anc', 'cac', 'mic', 'mic', ...
</programlisting>
<para>The problem is that we have matched three-letter sequences which
occur <emphasis>anywhere within a word</emphasis>. For example, the
pattern will match <quote><literal>c</literal></quote> in words like
<literal>aback</literal>, <literal>Aerobacter</literal> and
<literal>albacore</literal>. Inspection of the file
<filename>words</filename> reveals that words are listed one to a
line. So we might want to revise our pattern so that the match string is
anchored to the beginning and ends of the line: 
&ulcorn;<literal>^...$</literal>&drcorn;. However, the
<filename>words</filename> is read into Python as a single string
(containing line breaks), and the Python 
<application>re</application> module interprets
&ulcorn;<literal>^</literal>&drcorn; as matching only only at the
beginning of the string as a whole; i.e., in this case, the pattern
would only try to match against the first word of the file. To deal with
this, we use the <firstterm>compilation flag</firstterm>
<literal>MULTILINE</literal> which makes
&ulcorn;<literal>^</literal>&drcorn; also match at the beginning of each
line with a string:
</para>
<programlisting>
<emphasis># Compile the regexp so that it is anchored at the beginning
of lines</emphasis> 
&prompt;<command>r2 = compile('^..c$',MULTILINE)</command>

&prompt;<command>print r2.findall(words)</command>
['arc', 'Doc', 'Lac', 'Mac', 'Vic']
</programlisting>


<para>
In <xref linkend="complementation"/>, we briefly looked at the
task of matching strings which were enclosed by HTML markup. Our first
attempt is illustrated in  the following code example, where we
incorrectly match the whole string, rather than just the substring
<quote><literal>&lt;B&gt;important&lt;/B&gt;</literal></quote>.
</para>

<programlisting>
&prompt;<command>html = '&lt;B&gt;important&lt;/B&gt; and &lt;B&gt;urgent&lt;/B&gt;'</command>
&prompt;<command>r2 = compile('&lt;B&gt;.*&lt;/B&gt;')</command>
&prompt;<command>print r3.findall(html)</command>
['&lt;B&gt;important&lt;/B&gt; and &lt;B&gt;urgent&lt;/B&gt;']
</programlisting>

<para>
As we pointed out, one solution is to use a character class which
matches with the complement of <quote><literal><</literal></quote>:
</para>
<programlisting>
&prompt;<command>r4 = compile('&lt;B&gt;[^&lt;]*&lt;/B&gt;')</command>
&prompt;<command>print r4.findall(html)</command>
['&lt;B&gt;important&lt;/B&gt;', '&lt;B&gt;urgent&lt;/B&gt;']
</programlisting>

<para>However, there is another way of approaching this problem.
&ulcorn;<literal>&lt;B&gt;.*&lt;/B&gt;</literal>&drcorn; gets the wrong
results because the &ulcorn;<literal>*</literal>&drcorn; operator tries
to consume as much input as possible. That is, the matching is said to
be <firstterm>greedy</firstterm>. In the current case,
&ulcorn;<literal>*</literal>&drcorn; matches everything after the
first <literal>&lt;B&gt;</literal>, including the following
<literal>&lt;/B&gt;</literal> and <literal>&lt;B&gt;</literal>.
If we instead use the non-greedy star operator
&ulcorn;<literal>*?</literal>&drcorn;, we get the desired match,
since 
&ulcorn;<literal>*?</literal>&drcorn; tries to consume as little
input as possible.

</para>

</section> <!--Python Interface-->

&index;
</article>
