<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" [

<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "http://nltk.sourceforge.net/ref">
<!ENTITY tutdoc "http://nltk.sourceforge.net/tutorial">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Steven</firstname><surname>Bird</surname></author>
    <authorinitials>sb</authorinitials>
    <title>NLTK Tutorial: Regular Expressions</title>
  </articleinfo>

  <section id="intro"> 
    <title> Introduction </title>

    <note><para> This tutorial provides a gentle introduction to
    regular expressions illustrated with examples from language
    processing.  For a more concise introduction please see the
    Python documentation
    <ulink url="http://www.python.org/doc/current/lib/module-re.html">
    re -- Regular expression operations</ulink>.
    </para></note>

    <para> When written language is stored in a machine it is normally
    represented as a sequence (or <glossterm>string</glossterm>) of
    characters.  Individual words are strings.  A list of words is a
    string.  Entire texts are also strings, including special
    characters for space and newline.  Strings are sometimes
    formatted, such as a "date string" like
    <literal>2002-06-23</literal>.  Whole texts may be formatted, such
    as an email message with header fields followed by the message
    body.  Texts may contain "markup", such as
    <literal>&lt;abbrev&gt;Phila&lt;/abbrev&gt;</literal>, which may
    provide information about the interpretation or presentation of
    some piece of text.  Thus in language processing, strings are
    ubiquitous, and they often contain important structure.
    </para>

    <para> Most language processing is performed above the level of
    characters.  For instance, parsing a sentence is a process that
    operates at the level of whole words.  What kinds of processing
    are performed at the character level?  Perhaps word games are the
    most familiar example of such processing.  In completing a
    crossword we may want to know which 3-letter English words end
    with the letter <literal>c</literal>.  We might want to know how
    many words can be formed from the letters: <literal>a</literal>,
    <literal>c</literal>, <literal>e</literal>, <literal>o</literal>,
    and <literal>n</literal>.  We may want to find out which unique
    English word contains the substring <literal>gnt</literal>.  In
    all these examples, we are considering which of a large set of
    words matches a given pattern.  There are many more serious uses
    of this <glossterm>pattern matching</glossterm>.  We may want to
    break a text into its component words, a process known as
    <glossterm>tokenization</glossterm> (see the <ulink
    url="&tutdoc;/introduction/t1.html">introduction</ulink>).  For
    this we want to search for locations in the text string containing
    whitespace (space, tab, or newline) or certain punctuation
    symbols.  We may want to compute the relative frequency of
    particular letters in the text in order to guess the language of
    the text.  For this we must total up the number of matches for each
    character of interest.
    </para>

    <para> So far we have seen elementary examples of pattern
    matching, the matching of individual characters.  More often we
    are interested in matching sequences.  For example, part of the
    operation of a (naive) spell-checker may be to remove a word-final
    <literal>s</literal> (in case it is a plural) and see if the putative
    singular form exists in the dictionary.  For this we must locate
    <literal>s</literal> and remove it, but only if it precedes a word boundary.
    This requires matching a pattern consisting of two characters.
    </para>

    <para> Beyond this pattern matching on the
    <emphasis>content</emphasis> of a text, we often want to process
    the <emphasis>formatting</emphasis> and
    <emphasis>markup</emphasis> of a text.  We may want to check the
    formatting of a document (e.g. to ensure that every sentence
    begins with a capital letter) or to reformat a document
    (e.g. replacing sequences of space characters with a single
    space).  We may want to find all date strings and extract the
    year.  We may want to extract all words contained inside the
    <literal>&lt;abbrev&gt;&lt;/abbrev&gt;</literal> markup in order
    to construct a list of abbreviations.
    </para>

  </section> <!-- Introduction -->

  <section id="simple"> 
    <title> Simple Regular Expressions </title>

    <para> In this section we will see the building blocks for simple
    regular expressions, along with a selection of linguistic
    examples.
    </para>

    <section id="dot">
      <title>The Wildcard</title>

      <para> The "<literal>.</literal>" symbol matches any character.
      For example, the regular expression <literal>s.ng</literal>
      matches the following English words:
        <literal>sang</literal>,
        <literal>sing</literal>,
        <literal>song</literal>, and
        <literal>sung</literal>.
      </para>

      <para> We can also use this symbol for counting characters.
      For instance <literal>....zy</literal> matches six-letter words
      that end in <literal>zy</literal>.  The pattern
      <literal>....berry</literal> finds words like <literal>cranberry</literal>.
      </para>

    </section>

    <section id="qmk">
      <title>Optionality</title>

      <para> The "<literal>?</literal>" symbol indicates that the
      immediately preceding expression is optional.  The expression
      <literal>colou?r</literal> matches both British and American
      spellings, <literal>colour</literal> and <literal>color</literal>.
      The preceding expression may be punctuation, such as an optional
      hyphen.  For instance <literal>e-?mail</literal> matches both
      <literal>e-mail</literal> and <literal>email</literal>.
      </para>

    </section>

    <section id="plus">
      <title>Repeatability</title>

      <para> The "<literal>+</literal>" symbol indicates that the
      immediately preceding expression is repeatable, up to an arbitrary
      number of times.  For example, the expression
      <literal>coo+l</literal> matches <literal>cool</literal>,
      <literal>coool</literal>, and so on.
      This symbol is particularly effective when combined with the
      <literal>.</literal> symbol.  For example,
      <literal>f.+f</literal> matches all words that begin and end with
      the letter <literal>f</literal>.  The expression <literal>.+ed</literal>
      finds words that potentially have the past-tense <literal>-ed</literal>
      suffix.
      </para>

      <para> The "<literal>*</literal>" symbol indicates that the
      immediately preceding expression is both optional and repeatable.
      For example <literal>.*berry.*</literal> matches all words that
      contain <literal>berry</literal>.
      </para>

    </section>

    <section id="range">
      <title>Choices</title>

      <para> Patterns using the wildcard symbol are very effective,
      but there are many instances where we want to limit the set of
      characters that the wildcard can match.  In such cases we can
      use the <literal>[]</literal> notation.  For example, we can
      match only the vowels using <literal>[aeiou]</literal>.  The
      expression <literal>p[aeiou]+t</literal> matches the words:
        <literal>pat</literal>,
        <literal>peat</literal>,
        <literal>pet</literal>,
        <literal>pit</literal>,
        <literal>poet</literal>,
        <literal>pot</literal>,
        <literal>pout</literal>, and
        <literal>put</literal>.
      The order of vowels in the regular expression is insignificant,
      and we would have had the same result with the expression
      <literal>p[uoiea]+t</literal>.  Thus, inside these brackets,
      the characters are interpreted not as a string but as a set of choices.
      </para>

    </section>

  </section>

  <section id="intermediate"> 
    <title> More Complex Regular Expressions </title>

    <para>ranges, negation</para>

    <para>disjunction</para>

    <para>common special symbols: ^, $, \, \n </para>

  </section>

  <section id="advanced"> 
    <title> Advanced Regular Expressions </title>

    <para>greedy vs non-greedy matching</para>

    <para>zero-width assertions</para>

    <para>more special symbols: \b etc</para>

  </section>

  <section id="python_interface"> 
    <title> Python Interface </title>

    <para> How to do regexps in Python - give a couple of code samples
    for the above prose illustrations.  Use /usr/dict/words - local copy. </para>

<programlisting>
<emphasis># Load the regular expression module:</emphasis>
&prompt; <command>from re import *</command>
<emphasis># Read a big list of words:</emphasis>
&prompt; <command>words = open('/home/sb/nltk/data/words', 'r').read()</command>
<emphasis># How many words are there?</emphasis>
&prompt; <command>len(words)</command>
409093
<emphasis># Compile a regexp for 3-letter words ending in c</emphasis>
&prompt; <command>r = compile(r'^..c$', MULTILINE)</command>
<emphasis># Find all matches</emphasis>
&prompt; <command>print r.findall(words)</command>
['arc', 'Doc', 'Lac', 'Mac', 'Vic']
</programlisting>

  </section>

</article>
