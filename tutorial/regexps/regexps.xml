<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"../../docbook/sgml/docbook/xml-dtd-4.2/docbookx.dtd" [
<!-- Base URL for the reference & tutorial documentation -->
<!ENTITY refdoc "http://nltk.sourceforge.net/api/public">
<!ENTITY tutdoc "http://nltk.sourceforge.net/tutorial">

<!-- Index -->
<!ENTITY index SYSTEM "index.xml">

<!-- Prompts for Python code samples -->
<!ENTITY prompt "<prompt>&gt;</prompt><prompt>&gt;</prompt><prompt>&gt;</prompt>">
<!ENTITY prompt2 "<prompt>...</prompt>">
]>

<article>
  <articleinfo>
    <author><firstname>Steven</firstname><surname>Bird</surname></author>
    <authorinitials>sb</authorinitials>
    <author><firstname>Ewan</firstname><surname>Klein</surname></author>
    <authorinitials>ek</authorinitials>
    <title>NLTK Tutorial: Regular Expressions</title>
  </articleinfo>

<section id="overview">
<title>Overview</title>

    <para> This tutorial provides an introduction to
    regular expressions illustrated with examples from language
    processing.
    <footnote>
     <para>For a more concise introduction please see the Python documentation
    <ulink url="http://www.python.org/doc/current/lib/module-re.html">
    re -- Regular expression operations</ulink>.</para></footnote>
    </para>

    <para> When written language is stored in a machine it is normally
    represented as a sequence (or <glossterm>string</glossterm>) of
    characters.  Individual words are strings.  A list of words is a
    string.  Entire texts are also strings, including special characters
    for space and newline.  Strings are sometimes formatted, such as a
    <quote>date string</quote> like <literal>2002-06-23</literal>.
    Whole texts may be formatted, such as an email message with header
    fields followed by the message body.  Texts may contain
    <quote>markup</quote>, such as <sgmltag
    class="starttag">abbrev</sgmltag>Phil <sgmltag
    class="endtag">abbrev</sgmltag>, which provides information about
    the interpretation or presentation of some piece of text.  Thus in
    language processing, strings are ubiquitous, and they often contain
    important structure.
    </para>

    <para> Most language processing is performed above the level of
    characters.  For instance, parsing a sentence is a process that
    operates at the level of complete words.  What kinds of processing
    are performed at the character level?  Perhaps word games are the
    most familiar example of such processing.  In completing a
    crossword we may want to know which 3-letter English words end
    with the letter <literal>c</literal>
    (e.g. <literal>arc</literal>).  We might want to know how many
    words can be formed from the letters: <literal>a</literal>,
    <literal>c</literal>, <literal>e</literal>, <literal>o</literal>,
    and <literal>n</literal> (e.g. <literal>ocean</literal>).  We may
    want to find out which unique English word contains the substring
    <literal>gnt</literal> (left as an exercise for the reader).  In
    all these examples, we are considering which word &mdash; drawn from a
    large set of candidates &mdash; matches a given pattern.  There are many
    more serious uses of this so-called <glossterm>pattern
    matching</glossterm>.  We may want to break a text into its
    component words, a process known as
    <glossterm>tokenization</glossterm> (see the <ulink
    url="&tutdoc;/introduction/index.html">introduction</ulink>).  For
    simple tokenization we want to search for locations in the text
    string containing whitespace (space, tab, or newline) or certain
    punctuation symbols, and break the text strings into word strings
    at these points.  Alternatively, we may want to compute the
    relative frequency of particular letters in the text in order to
    guess the language of the text.  For this we must total up the
    number of matches for each character of interest.
    </para>

    <para> So far we have seen elementary examples of pattern
    matching, the matching of individual characters.  More often we
    are interested in matching <emphasis>sequences</emphasis> of
    characters.  For example, part of the operation of a naive
    spell-checker could be to remove a word-final <literal>s</literal>,
    in case it is a plural, and see if the putative singular form
    exists in the dictionary.  For this we must locate
    <literal>s</literal> and remove it, but only if it precedes a word
    boundary.  This requires matching a pattern consisting of two
    characters.
    </para>

    <para> Beyond this pattern matching on the
    <emphasis>content</emphasis> of a text, we often want to process the
    <emphasis>formatting</emphasis> and <emphasis>markup</emphasis> of a
    text.  We may want to check the formatting of a document (e.g. to
    ensure that every sentence begins with a capital letter) or to
    reformat a document (e.g. replacing sequences of space characters
    with a single space).  We may want to find all date strings and
    extract the year.  We may want to extract all words contained inside
    the <sgmltag class="starttag">abbrev</sgmltag> <sgmltag
    class="endtag">abbrev</sgmltag> markup in order to construct a list
    of abbreviations.
    </para>

    <para> Processing the content, format and markup of strings is a
    central task in most kinds of NLP.  The most widespread method for
    string processing uses <glossterm>regular expressions</glossterm>.
    </para>

  </section> <!-- Overview -->

  <section id="simple"> 
    <title> Simple Regular Expressions </title>

    <para>In this section we will see the building blocks for simple
    regular expressions, along with a selection of linguistic
    examples. We can think of a regular expression as a specialised
    notation for describing patterns that we want to match. In order to
    make explicit when we are talking about a pattern
    <varname>patt</varname>, we will use the notation
    &ulcorn;<literal>patt</literal>&drcorn;. The first thing to say
    about regular expressions is that most letters match themselves. For
    example, the pattern &ulcorn;<literal>sing</literal>&drcorn; exactly matches
    the string <literal>sing</literal>. In addition, regular expressions
    provide us with a set of <emphasis>special characters</emphasis>
    which give us a ways to match sets of strings, and we will now look
    at these.
    </para>

    <section id="dot">
      <title>The Wildcard</title>

    <para> The "<literal>.</literal>" symbol is called a
     <firstterm>wildcard</firstterm>: it matches any single character.
      For example, the regular expression &ulcorn;<literal>s.ng</literal>&drcorn;
      matches the following English words:
        <literal>sang</literal>,
        <literal>sing</literal>,
        <literal>song</literal>, and
        <literal>sung</literal>.
      </para>

      <para> We can also use the wildcard symbol for counting characters.
      For instance &ulcorn;<literal>....zy</literal>&drcorn; matches six-letter strings
      that end in <literal>zy</literal>.  The pattern
      &ulcorn;<literal>....berry</literal>&drcorn; finds words like <literal>cranberry</literal>.
      </para>

      <note><para> Note that &ulcorn;<literal>.</literal>&drcorn; matches
      <emphasis>exactly</emphasis> one character, and must be repeated
      for as many characters as should be matched.  To match a
      variable number of characters we must use notation for
      <emphasis>optionality</emphasis>. </para></note>

    </section>

    <section id="qmk">
      <title>Optionality</title>

      <para> The "<literal>?</literal>" symbol indicates that the
      immediately preceding regular expression is optional.  The regular
     expression
      &ulcorn;<literal>colou?r</literal>&drcorn; matches both British and American
      spellings, <literal>colour</literal> and
      <literal>color</literal>.  The expression that precedes the
      <literal>?</literal> may be punctuation, such as an optional
      hyphen.  For instance &ulcorn;<literal>e-?mail</literal>&drcorn; matches both
      <literal>e-mail</literal> and <literal>email</literal>.
      </para>

    </section>

    <section id="plus">
      <title>Repeatability</title>

      <para> The "<literal>+</literal>" symbol indicates that the
      immediately preceding expression is repeatable, up to an
      arbitrary number of times.  For example, the regular expression
      &ulcorn;<literal>coo+l</literal>&drcorn; matches <literal>cool</literal>,
      <literal>coool</literal>, and so on.  This symbol is
      particularly effective when combined with the
      <literal>.</literal> symbol.  For example,
      &ulcorn;<literal>f.+f</literal>&drcorn; matches all strings that begin and end
      with the letter <literal>f</literal>
     (e.g. <literal>foolproof</literal>).  The expression
      &ulcorn;<literal>.+ed</literal>&drcorn; finds strings that potentially have the
      past-tense <literal>-ed</literal> suffix.
      </para>

      <para> The "<literal>*</literal>" symbol indicates that the
      immediately preceding expression is both optional and repeatable.
      For example &ulcorn;<literal>.*gnt.*</literal>&drcorn; matches all strings that
      contain <literal>gnt</literal>. 
      </para>

    </section>

    <section id="choices">
      <title>Choices</title>

      <para> Patterns using the wildcard symbol are very effective, but
      there are many instances where we want to limit the set of
      characters that the wildcard can match.  In such cases we can use
      the <literal>[]</literal> notation, which enumerates the set of
      characters to be matched &mdash; this is called a
      <firstterm>character class</firstterm>.  For example, we can match
      any English vowel, but no consonant, using
      &ulcorn;<literal>[aeiou]</literal>&drcorn;. Note that this pattern
      can be interpreted as saying <quote>match <literal>a</literal> or
      <literal>e</literal> or &hellip; or <literal>u</literal></quote>; that is, the pattern
      resembles the wildcard pattern
      &ulcorn;<literal>.</literal>&drcorn; in only matching a string of
      length one; unlike the wildcard, it restricts the characters
      matched to a specific class (in this case, the vowels).  As a
      second example, the expression
      &ulcorn;<literal>p[aeiou]t</literal>&drcorn; matches the words:
      <literal>pat</literal>, <literal>pet</literal>,
      <literal>pit</literal>, <literal>pot</literal>, and
      <literal>put</literal>.
      </para>

      <para> We can combine the <literal>[]</literal> notation with
      our notation for repeatability.  For example, expression
      &ulcorn;<literal>p[aeiou]+t</literal>&drcorn; matches the words listed above,
      along with: <literal>peat</literal>, <literal>poet</literal>,
      and <literal>pout</literal>.
      </para>

      <note><para> Note that the order of vowels in the regular
      expression is insignificant, and we would have had the same
      result with the expression &ulcorn;<literal>p[uoiea]+t</literal>&drcorn;.  Thus,
      inside these brackets, the characters are interpreted not as a
      string but as a set of choices.
      </para></note>

      <para> Often the choices we want to describe cannot be expressed
      at the level of individual characters.  For example, if we were
      processing the output of a tagger to extract noun phrases, we
      might want to find all nouns (<literal>NN.*</literal>), adjectives
      (<literal>JJ.*</literal>), determiners (<literal>DT</literal>) and
      cardinals (<literal>CD</literal>), while excluding all other word
      types (e.g. verbs <literal>VB.*</literal>).  It is possible,
      using a single regular expression, to search for this set of
     candidates using the <firstterm>choice operator</firstterm> <literal>|</literal> as
      follows: &ulcorn;<literal>NN.*|JJ.*|DT|CD</literal>&drcorn;.
      </para>

      <para> As another example of multi-character choices, suppose
      that we wanted to create a program to simplify English prose,
      replacing rare words (like <literal>habitation</literal>) with
      a more frequent, synonymous word (like
      <literal>home</literal>).  In this situation, we need to map
      from a potentially large set of words to an individual word.  We
      can match the set of words using the choice operator.  In the
      case of the word <literal>home</literal>, we would want to
      match the regular expression
      &ulcorn;<literal>dwelling|domicile|abode|habitation</literal>&drcorn;.
      </para>

      <note><para> Note that the choice operator has wide scope, so that
      &ulcorn;<literal>abc|def</literal>&drcorn; is a choice between <literal>abd</literal>
      and <literal>def</literal>, and not between
      <literal>abced</literal> and <literal>abdef</literal>.  The latter
      choice must be written using parentheses: &ulcorn;<literal>ab(c|d)ed</literal>&drcorn;.
      </para></note>

    </section>

  </section>

  <section id="intermediate"> <title> More Complex Regular Expressions
  </title>

    <para>In this section we will cover operators which can be used to
    construct more powerful and useful regular expressions.
    </para>

    <section id="ranges"> <title> Ranges </title>

      <para>In section <xref linkend="choices"/> we saw how the
      <literal>[]</literal> notation could be used to express a set of
      choices between individual characters.  Instead of listing each
      character, it is also possible to express a <emphasis>range</emphasis>
      of characters, using the <literal>-</literal> operator.  For example,
      &ulcorn;<literal>[a-z]</literal>&drcorn; matches any lowercase letter.
      </para>

      <para>As expected, ranges can be combined with other operators.
      For example &ulcorn;<literal>[A-Z][a-z]*</literal>&drcorn; matches words that have
      an initial capital letter followed by any number of lowercase
      letters.  The expression &ulcorn;<literal>20[0-4][0-9]</literal>&drcorn; matches
      years in the range 2000 to 2049.
      </para>

      <para>Ranges can be combined, e.g.
      &ulcorn;<literal>[a-zA-Z]</literal>&drcorn; which matches any lowercase or uppercase
      letter.  The expression &ulcorn;<literal>[b-df-hj-np-tv-z]+</literal>&drcorn; matches
     words consisting only of consonants (e.g. <literal>pygmy</literal>).
      </para>

    </section>

    <section id="complementation"> <title> Complementation </title>

      <para>
     We just saw that the character class 
     &ulcorn;<literal>[b-df-hj-np-tv-z]</literal>&drcorn; allows us to
     match consonants. However, this expression is
     quite cumbersome. A better alternative is to say: let's match
     anything which isn't a vowel. To do this, we need a way of
     expressing <firstterm>complementation</firstterm>. <footnote>
     <para>Complementation is a notion drawn from set theory. Let's
     assume that our domain of all objects is the set
     <varname>U</varname> = &lcub;a, b, c, d, e&rcub;, and let V be the
     set &lcub;a, e&rcub;. Then the complement of <varname>V</varname>,
     often written <varname>V</varname>&apos; is the result of
     <quote>subtracting</quote> <varname>V</varname> from
     <varname>U</varname>; i.e., the set <varname>V</varname>&apos; =
     &lcub;b, c, d &rcub;.</para> </footnote> We do
     this using the symbol <quote><literal>^</literal></quote> as the first character
     within <literal>[]</literal>. Let's look at an
     example. &ulcorn;<literal>[^aeiou]</literal>&drcorn; is just like
     our earlier character class, except now the set of vowels is
     preceded by <literal>^</literal>. The expression as a whole is
     interpreted as matching anything which <emphasis>fails</emphasis>
     to match &ulcorn;<literal>[aeiou]</literal>&drcorn;. In other
     words, it matches all consonants.</para>

    <para>As another example, suppose we want to match any string which
    is enclosed by the HTML tags <sgmltag class="starttag">B</sgmltag>
    and <sgmltag class="endtag">B</sgmltag>, We might try something like
    this:  &ulcorn;<literal>&lt;B&gt;.*&lt;/B&gt;</literal>&drcorn;. This would
    successfully match <literal>&lt;B&gt;important&lt;/B&gt;</literal>, but would
    also match <literal>&lt;B&gt;important&lt;/B&gt; and &lt;B&gt;urgent&lt;/B&gt;</literal>,
    since the &ulcorn;<literal>.*</literal>&drcorn; subpattern will happily
    match all the characters from the end of
    <literal>important</literal> to the end of
    <literal>urgent</literal>. One way of ensuring that we only look at
    matched pairs of tags would be to use the expression
    &ulcorn;<literal>&lt;B&gt;[^<]*&lt;/B&gt;</literal>&drcorn;, where the
    chararacter class matches anything other than a left angle bracket.
    </para>

 
    <para>Finally, note that character class complementation also works
     with for ranges. Thus &ulcorn;<literal>[^a-z]</literal>&drcorn;
     matches anything other than the lower case alphabetic characters
     <literal>a</literal> through <literal>z</literal>.
      </para>

    </section>

    <section id="special"> <title> Common Special Symbols </title>

      <para>^, $, \, \n </para>

    </section>

  </section>

  <section id="advanced"> 
    <title> Advanced Regular Expressions </title>

    <para>greedy vs non-greedy matching</para>

    <para>zero-width assertions</para>

    <para>more special symbols: \b etc</para>

  </section>

  <section id="python_interface"> 
    <title> Python Interface </title>

    <para> How to do regexps in Python - give a couple of code samples
    for the above prose illustrations.  Use /usr/dict/words - local copy. </para>

<programlisting>
<emphasis># Load the regular expression module:</emphasis>
&prompt; <command>from re import *</command>
<emphasis># Read a big list of words:</emphasis>
&prompt; <command>words = open('/home/sb/nltk/data/words', 'r').read()</command>
<emphasis># How many words are there?</emphasis>
&prompt; <command>len(words)</command>
409093
<emphasis># Compile a regexp for 3-letter words ending in c</emphasis>
&prompt; <command>r = compile(r'^..c$', MULTILINE)</command>
<emphasis># Find all matches</emphasis>
&prompt; <command>print r.findall(words)</command>
['arc', 'Doc', 'Lac', 'Mac', 'Vic']
</programlisting>

</section> <!--Python Interface-->
  
&index;

</article>
