%
% Natural Language Toolkit for Python
% Technical Report: Representation Types
% Edward Loper
% 
% Created [03/02/01 12:02 AM]
% $Id$
%

% Note: be careful to say ``x is a kind of y'' instead of ``x is a type 
% of y,'' since we're giving ``type'' special meaning.

% To do:
%   - Figures
%   - SyntaxTree discussion
%   - Summary

\newcommand{\concept}[1]{\textsf{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{epsfig}

\begin{document}
\title{Basic Representation Types\\
\Large Natural Language Processing Toolkit: Technical Report}
\author{Edward Loper}
\maketitle

%============= INTRODUCTION =============%
\section{Introduction}

% We will explain the toolkit's basic types
  The natural language toolkit allows students to manipulate a number
  of conceptual objects, such as words, sentences, and syntax trees.
  Before we can build a consistant framework for manipulating such
  objects, we must decide how they should be represented.  This
  technical report explains basic types used by the toolkit to
  represent a number of conceptual objects.  Furthermore, it attempts
  to justify why this set of basic types was chosen.

% Description of sections
  Section \ref{sec:concepts} describes the basic concepts which this
  technical report attempts to address.  Sections \ref{sec:locations}
  through \ref{sec:trees} describe the basic types that were chosen to
  encapsulate these concepts, and the rational behind choosing those
  types.  Section \ref{sec:summary} provides a summary of the basic
  types, and discusses how they interact.

\newpage
%============= CONCEPTS =============%
\section{Abstract Concepts}
\label{sec:concepts}

% Abstract concepts we wish to address
  The following list of abstract concepts is representative of the
  concepts which should be captured by the basic types defined in this
  techincal report.\footnote{The types used to represent many other
  abstract concepts (such as frequency distributions) are beyond the
  scope of this technical report.}  Where the meaning of the concepts
  are not obvious, I included explanations.

  \begin{itemize}
  
    \item \concept{Document}
  
    \item \concept{Sentence}
  
    \item \concept{Word Type}: A single word (as opposed to a
        \concept{Word Occurance}).
  
    \item \concept{Tagged Word Type}: A word that has been tagged with
        additional information, such as part-of-speech information.
  
    \item \concept{Stemmed Word Type}: A word that has been stripped of
        inflectional suffixes and prefixes.
  
    \item \concept{Case-Normalized Word Type}: A word whose case has been
        normalized (usually to either upper case or lower case).
  
    \item \concept{Word Occurance}: A single occurance of a word type.

    \item \concept{Tagged Word Occurance}
    \item \concept{Stemmed Word Occurance}
    \item \concept{Case-Normalized Word Occurance}
  
    \item \concept{Tokenized Document}: A document that has been divided
        into individual word occurances.
  
    \item \concept{Tokenized Sentence}: A sentence that has been divided
        into individual word occurances.
  
    \item \concept{Location}: The location of one unit of text within
        another unit of text.  A typical location might give the
        location of a word within a document or a sentence.
  
    \item \concept{Tagged Document} or \concept{Tagged Sentence}: A
        document or sentence that has been divided into individual word
        occurances, each of which has been tagged with additional
        information.
  
    \item \concept{Stemmed Document} or \concept{Stemmed Sentence}: A
        document or sentence that has been divided into individual word
        occurances, each of which has been stripped of inflectional
        affixes.
  
    \item \concept{Case-Normalized Document} or \concept{Case-Normalized
        Sentence}: A document or sentence that has been divided into
        individual word occurances, each of which has had its case
        normalized.
  
    \item \concept{Syntax Tree}: A hierarchical representation of the
        structure of a sentence.
  
    \item \concept{Syntax Node}: The annotation appearing at a node in a
        syntax tree.  Typically, this will be a tag, such as ``NP.''
  
    \item \concept{Syntax Tree Occurance}: A single occurance of a syntax
        tree.
  
  \end{itemize}

%============= LOCATIONS =============%
\section{Locations}
\label{sec:locations}
% Should the standard location notation be changed to 
% [s:e], like slices?

  \subsection{Design}

% Location = <start, end> (where start<end)
  The location of an element of text is represented using a span-based
  data structure.  A \emph{span} consists of a \emph{start index} and
  an \emph{end index}, both of which are non-negative integers.  A
  span with start index $s$ and end index $e$ is written ``$[s,e)$,''
  and specifies the location of the text beginning at $s$, and
  including everything up to (but not including) the text at $e$.  It
  is always true that $s<e$.\footnote{Should this be changed to $s\leq
  e$?  If $s=e$, then the span would be empty -- does it make sense to
  have empty locations?}

% Units encode what unit the indices use
  The start and end indices can be based on a variety of different
  \emph{units}, such as character number, word number, or sentence
  number.  However, for any two indeces $x$ and $y$, it should be true
  that $x<y$ if and only if $x$ indicates a location earlier in the
  text than $y$.  The location of an element of text may be explicitly
  tagged with information about what unit its indices use.  Unit
  labels take the form of case-insensitive \code{string}s.  Typical
  examples of unit labels are the strings \code{"character"} and
  \code{"word"}.

% Source encodes where the text came from
  The location of an element of text may also be tagged with its
  \emph{source}.  This is an object that gives an indication of where
  the text was derived from.  A typical example of a source would be a
  \code{string} containing the name of the file from which the element
  of text was read.  Sources may also be represented as locations; for
  example, the source for the location of a word might be the location
  of the sentence that contained it.  This allows locations to be
  specified in a hierarchical fashion. % as shown in figure foo?

  \subsection{Implementation}

  Locations are implemented using the \code{Location} class.
  \code{Location}s consist of:

  \begin{itemize}

    \item A \emph{start index} (accessed via the \code{start()} member
    function).  \\
    Python Type: \code{int}

    \item An \emph{end index} (accessed via the \code{end()} member
    function).  \\
    Python Type: \code{int}

    \item An optional \emph{unit} (accessed via the \code{unit()}
    member function).  \\
    Python Type: \code{string} \emph{(normalized to lower case)}
    

    \item An optional \emph{source} (accessed via the \code{source()}
    member function).  \\
    Python Type: \emph{(any)}

  \end{itemize}

% Ordering of Locations
  \noindent
  \code{Location}s are immutable objects.  \code{Location}s can be
  compared for equality and ordering.  If two \code{Location}s with
  different units or different sources are compared, then an exception
  will be raised.  When \code{Location} comparisons do not raise
  exceptions, they are defined as follows:
  %
  \begin{align*}
     [s_1,e_1) = [s_2,e_2) &\iff s_1=s_2 \quad \land \quad e_1=e_2 \\
     [s_1,e_1) < [s_2,e_2) &\iff e_1 < s_2 \\
     [s_1,e_1) > [s_2,e_2) &\iff s_1 > e_2 \\
     [s_1,e_1) \leq [s_2,e_2) &\iff [s_1,e_1) < [s_2,e_2) \quad \lor \quad
                             [s_1,e_1) = [s_2,e_2) \\
     [s_1,e_1) \geq [s_2,e_2) &\iff [s_1,e_1) > [s_2,e_2) \quad \lor \quad
                             [s_1,e_1) = [s_2,e_2) 
  \end{align*}

  \noindent
  Note that if two \code{Location}s $l_1$ and $l_2$ overlap, then it
  will never be the case that $l_1<l_2$ or $l_1>l_2$.

  \subsection{Discussion}

% Why not more complex/general?
  Originally, I proposed a general, user-extensible notion of
  location.  However, the span-based representation described here
  seems to be sufficiently powerful to represent almost any location.
  We decided that the additional power granted by making the notion of
  location user-extensible did not compensate for the added
  complexity.  Also, if the notion of location built-in, then other
  classes can rely on it for computation.  For example, syntax trees
  can compute their locations as a function of the locations of their
  leaves.  If locations were user-extensible objects, then there would
  be no general way to perform such computations.

% Why not simpler?
  A simpler notion of location, based on a single index, was
  considered.  However, it was decided that the added power provided
  by representing locations as ranges was worthwhile, especially in
  the context of multi-word structures like syntax trees.

% Why units and sources?
  The optional unit and source fields were added to help distinguish
  different sets of locations, and to help ensure that unrelated
  locations are not accidentally compared.  For example, it may be
  useful for a student to keep track of the location of the words in
  two different files; but comparing these locations would be
  meaningless.  We considered simply returning false when locations
  with non-matching units or sources are compared, but decided that
  raising exceptions would be more likely to help students find
  errors.  If students wish to compare two locations that may have
  different sources or units, then they must explicitly compare the
  location's sources or units, or catch and process the exceptions
  raised by the comparison methods.

% Why integer indices?
  We decided to restrict location indices to non-negative integers
  because it simplifies the interface without signifigantly reducing
  its power.  Other alternatives we considered were floating point
  numbers and arbitrary comperable objects.  Floating point numbers
  were rejected because rounding errors can invalidate tests for
  equality and ordering.  If a floating-point index seems appropriate,
  it is recommended that users either multiply the floating point
  numbers by a fixed constant and round them to integers, or create a
  bidirectional mapping between floating-point indices and integer
  indices.  The use of arbitrary comperable objects as indices was
  rejected because it signifigantly complicates the location
  interfaces, without adding signifigant power to the system.  Also,
  arbitrary comperable objects may incur some of the difficulties that
  would be encountered with floating point numbers.

% Why [s,e)?
  A span $[s,e)$ includes the text at $s$ but not the text at $e$ in
  order to be consistant with Python slice notation.  Also, all
  indices are required to be non-negative for consistancy with Python
  slice notation, where negative indices have special meaning.

%============= WORDS =============%
\section{Words}
\label{sec:words}
%  - (type)
%  - token

  \subsection{Design}

% Tokens versus Types
  The term ``word'' is used to refer to a wide variety of different
  abstract concepts, as can be seen by looking through the list of
  concepts from Section \ref{sec:concepts}.  One important distinction
  that is easy to overlook is the difference between a word and an
  individual occurance of a word.  For example, the sentence ``my dog
  likes his dog'' contains four words but five occurances of words
  (since the word ``dog'' appears twice).  In order to make this
  distinction clear, we will use the words \emph{type} and
  \emph{token} to refer to words and to occurances of words,
  respectively.  For example, in the sentence ``my dog likes his
  dog,'' we can say that the second and fifth words are different
  tokens, but that they have the same types.

% Distinguish Tokens via locations
  Individual tokens extracted from the same text can always be
  distinguished based upon their locations.  This fact provides us
  with a convenient mechanism for encoding tokens: a token is simply a
  pair consisting of a type and a location.  Two tokens are only equal
  if both their location and thier type are equal.

% Special Location: None
  Token locations are typically instances of the \code{Location}
  class.  However, Tokens may also have the special location
  \code{None}, which can be used when a token's location is unknown or
  unimportant.  A Token with a location of \code{None} is not
  considered to be equal to any other token.  In particular, even if
  two tokens have the same type, and both have a location of
  \code{None}, they are not considered equal.

% Tokens are more general than words
  The notions of token and type are actually more general than the
  notions of word and word occurance.  In the context of the toolkit,
  types can refer to any object derived from text, and tokens can
  refer to any instances of objects derived from text.  For example,
  syntax trees are actually special kinds of tokens (see Section
  \ref{sec:trees}).

% Types
  The toolkit does not define a specific encoding for individual kinds
  of tokens or token types, like simple words, tagged words, or
  stemmed words.  Instead, it defines the general encoding for tokens,
  and allows students to use almost any object as a type.  For
  example, \code{string}s could be used to encode the types of simple
  words, stemmed words, and case-normalized words; and pairs of
  strings could be used to encode tagged word types.

% Special Types
  However, the toolkit does provide a number of simple classes that
  are intended to be used as types.  Currently, the only class
  provided by the toolkit is the \code{TaggedType} class, which can be
  used to encode the type of a tagged token.  A \code{TaggedType}
  simply consists of a base type and a tag, both of which are
  \code{string}s.

  \subsection{Implementation}

  \subsubsection{Types}
      A Type can be any immutable object that properly implements
      equality comparison and hashing.

  \subsubsection{Tokens}
      Tokens are implemented using the \code{Token} class.
      \code{Token}s consist of:
  
      \begin{itemize}
    
        \item A \emph{location} (accessed via the \code{loc()} member
        function).  \\
        Python Type: \code{Location}
    
        \item A \emph{type} (accessed via the \code{type()} member
        function).  \\
        Python Type: \emph{(any)}
    
      \end{itemize}
      
      \noindent
      \code{Token}s are immutable objects.

  \subsubsection{TaggedTypes}
      The types of tagged tokens can be encoded using the
      \code{TaggedType} class.  A \code{TaggedType} consists of:
  
      \begin{itemize}
    
        \item A \emph{base type} (accessed via the \code{base()}
        member function).  \\
        Python Type: \code{string}
    
        \item A \emph{tag} (accessed via the \code{tag()} member
        function).  \\
        Python Type: \code{string}
    
      \end{itemize}
      
      \noindent
      \code{TaggedType}s are immutable objects.  Two tagged types are
      equal if their bases are equal and their tags are equal.  Note
      that equality of strings is defined to be case-sensitive.
    
  \subsection{Discussion}
  % - why not a class/interface for type?
  % - why location+type?
  % - why not classes to distinguish stemmed/case-normalized/etc?

% Why we considered a class hierarchy
  We considered implementing an interface or class hierarchy for
  types.  Using an interface, rather than allowing arbitrary Python
  objects, has a number of benefits:

  \begin{description}

    \item[Exception Semantics] If an interface is used to define what
    type objects must do, then types can exhibit more precise
    exception semantics.  In particular, it would be possible to
    ensure that comparing two type objects with different classes
    would always raise an exception.  In constrast, it is impossible
    to make such guarantees when comparing arbitrary Python objects.

    \item[Type-kind Distinctions] If each kind of type (e.g., stemmed
    types, case-normalized types, tagged types, etc.) is implemented
    with a separate class, then it is easier to maintain distinctions
    between different kinds of types.  But if built-in Python objects
    such as strings and tuples are used to represent types, then the
    distinctions between different kinds of type will become blurred.
    For example, since strings are likely to be used for simple words,
    stemmed words, and case-normalized words, it will be impossible to
    determine what kind of type a string contains by inspecting the
    string object.

  \end{description}

% Why we rejected a class hierarchy
  However, requiring that all types implement an interface often
  introduces an extra layer of indirection, and complicates the system
  used to represent words.  Since words are fundamental to the
  toolkit, we decided that they should be kept as simple as is
  practical.  Some of the exception semantics can be regained at a
  different level.  For example, even though testing two types for
  equality may not raise an exception if they have different Python
  types, it would be possible to implement the \code{type\_eq()}
  method of tokens to perform this check.\footnote{The
  \code{type\_eq()} method is also included because it can be more
  efficient than extracting the tokens' types and comparing them,
  especially for some special kinds of tokens like trees (see Section
  \ref{sec:trees}).}  Also, although type-kind distinctions cannot be
  derived directly from the type object, these distinctions are
  usually implicit in the history of the object, and it should be rare
  to have a type object without knowing what kind of type it contains.
  Therefore, we decided that the benefits derived from maintaining a
  class hierarchy for types did not justify the increase in complexity
  for the toolkit's set of basic type.

%============= COLLECTIONS =============%
\section{Collections of Words}
\label{sec:collections}
%  - string (sentence/document)
%  - list of token

  \subsection{Design}

% No special collection types
  The toolkit does not implement any special encodings for collections
  of words.  Instead, it relies on Python's built-in types.  However,
  there are a number of standard ways to use Python's built-in types
  to encode collections of words:

% Standard ways to represent collections
  \begin{description}

    \item[Strings] Unprocessed text is usually represented as a single
    string.  For example, when a document is read from a file, it is
    typically read into a string.  Tokenizers can be used to convert
    strings into lists of tokens.

    \item[List of Tokens] A piece of text can be represented as an
    ordered list of the tokens that it contains.

    \begin{itemize}

        \item A list of tokens $l$ is said to be ``properly ordered''
        if, for every $i<j$, $l[i].loc()<l[j].loc()$.

        \item A list of tokens $l$ is said to be ``exhaustive''
        if:\footnote{I might want to change this definition -- this
        one implies properly ordered.  We might want exhaustive and
        properly ordered to be mutually exclusive.}

        \begin{itemize}
          \item for every $i$, $l[i].end() = l[i+1].start()$; 
          \item $l[0].start()$ is the start of the text.
          \item $l[-1].end()$ is the end of the text.
        \end{itemize}

    \end{itemize}

    \item[List of Types] When the locations of individual tokens is
    unimportant, a text can be represented as an ordered list of its
    token's types.

    \item[Set of Tokens]\footnote{Python does not (yet) provide a
    built-in set type; however, the toolkit defines a generic set
    class.} When the order of the tokens in a text is unimportant, the
    text can be represented as a set of tokens.  Since each token's
    location serves to distinguish it from all other tokens, the set
    will not contain any duplicate elements.

    \item[Set of Types] When the order of tokens in a text and the
    presence of multiple tokens with the same type are unimportant,
    the text can be represented as a set of types.

    \item[Dictionary Mappings] Since both tokens and types are
    immutable objects, they can be used as keys in dictionaries.  A
    typical use of a dictionary would be to encode a multiset of types
    as a dictionary mapping types to counts.

  \end{description}

%  \subsection{Implementation}
%  There is no real implementation, is there??

  \subsection{Discussion}

% Why we considered special collection classes
  The wide variety of ways in which students might want to arrange
  collections of words would make it very difficult to design a
  specialized ``word collection'' encoding mechanism.  However, it
  would be possible to create several specific class-based encodings
  for the more common kinds of word collection.  If collections of
  words were encoded using a class, then it would be possible to check
  or enforce a number of restrictions on the members of the
  collections.  For example, for some types of collections, we might
  want to check that:

  \begin{itemize}

    \item All tokens in the collection have the same kind of type.

    \item The tokens in the collection are properly ordered.

    \item The tokens in the collections are exhaustive.

  \end{itemize}

% Why we rejected special collection classes
  However, adding new classes to encapsulate various types of
  collection would complicate the toolkit, making it more difficult to
  learn and to understand.  Furthermore, the fact that only a limited
  set of arrangements would be available would create a division
  between the ``supported'' arrangements and the ``unsupported ones.''
  Given how easy Python's native collection types are to use, we
  decided not to include any explicit ``word collection'' classes or
  interfaces in the toolkit.

%============= TREES =============%
\section{Syntax Trees}
\label{sec:trees}
%  - (node)
%  - tree (type of token)
%      - (node pytype)
%      - (leaf pytype)
%  - treetype

\subsection{Design}

% Text-tree is like a rooted ordered tree
  Syntax trees are represented using the \emph{text-tree} data
  structure, a general structure for representing homogenous
  hierarchical structures spanning text.  Figure~\ref{fig:tree} shows
  the structure of an example text-tree.  Conceptually, text-trees are
  very similar to the mathematical notion of a \emph{rooted ordered
  tree}.  In particular, a text-tree contains of a set of
  \emph{elements}, including a special \emph{root} element.  These
  elements are connected by \emph{edges}, such that there is exactly
  one path from the root element to each other element.  In addition,
  children of each element are ordered.

% Figure: example of Tree data structure
  \begin{figure}
  \begin{centering}
    \epsfbox{tree.eps}\\
  \end{centering}

   \caption{Example of the \emph{text-tree} data structure used to
   represent a syntax tree.  In this text-tree, the nodes are strings
   containing phrase tags, such as \code{"S"} and \code{"VP"}; and the
   leaves are strings containing word types, such as \code{"John"} and
   \code{"Mary"}.}

  \label{fig:tree}
  \end{figure}

\subsubsection{Leaves and Nodes}
% Leaves and nodes are mutually exclusive sets
  However, there are a few signifigant differences between text-trees
  and mathematical trees.  The most important difference is that the
  elements of a text-tree are explicitly divided into two separate
  classes, which we will call \emph{leaves} and \emph{nodes}.  The
  \emph{leaves} represent the individual elements of text spanned by
  the text-tree.  Leaves may not have children.  The \emph{nodes}
  associate information with the text-tree's hierarchical
  constituants.  For example, nodes could be used to label syntactic
  constituants with phrase tags, such as ``NP'' and ``VP.''

% ``Leaf'' and ``node'' don't have their standard definitions
  It is important to realize that these are \emph{not} the standard
  definitions for the terms \emph{leaf} and \emph{node}: in the
  context of a rooted ordered tree, node is synonymous with element,
  and a leaf is any element with no children.  But in the context of
  text-trees, leaf elements and node elements are mutually exclusive,
  and it is possible for node elements to have no children.

% Use standard terminology 
  However, much of the standard terminology for rooted ordered trees
  applies to text-trees.  In particular, the terms \emph{child},
  \emph{descendant}, \emph{parent}, \emph{ancestor}, \emph{sister},
  \emph{root}, \emph{subtree}, \emph{height}, and \emph{depth} have
  their typical meanings.

%\subsubsection{Homogeneity}
%% Text-trees are homogenous
%  Another difference between text-trees and general tree structures is
%  that text-trees must be homogenous.  Before we can formalize this
%  property, we must introduce the term ``pytype'': a Python object's
%  \emph{pytype} is the object's Python type if the object has a
%  built-in type; and is its class if the object is an instance.  The
%  homogeneity requiremenet for text-trees states that:
%
%  \begin{itemize}
%
%    \item Every node in a tree must have the same pytype.
%
%    \item Each leaf in a tree must have the same pytype.
%
%  \end{itemize}

\subsubsection{Proper Use}
% Trees are more general than syntax trees
  Although text-trees were designed to handle syntax trees, they are
  capable of encoding a more general class of objects.  For example,
  text-trees could be used to encode parser rules.  In fact, it would
  be possible to use the text-tree class to represent almost any
  homogenous tree-based data structure.  However, the text-tree class
  is primarily intended to encode structures that exist over spans of
  text, and it should not be used in unrelated contexts.

\subsubsection{Text-Tree Tokens}
% Tokens vs. Types
  As was the case with words, there is an important distinction to be
  made between \emph{occurances} of syntax trees and syntax tree
  \emph{types}.  Occurances of text-trees are represented with the
  \emph{text-tree token} data structure.  This data structure is
  parallel to the text-tree data structure; but instead of containing
  types, the leaves contain tokens.  Figure \ref{fig:treetoken} shows
  the structure of an example text-tree token.

% Figure: example of Tree data structure
  \begin{figure}
  \begin{centering}
    \epsfbox{treetoken.eps}\\
  \end{centering}

   \caption{Example of the \emph{text-tree token} data structure used
   to represent an occurance of a syntax tree.  This text-tree token's
   type is the text-tree shown in figure \ref{fig:tree}; and its
   location is [8, 11).}

  \label{fig:treetoken}
  \end{figure}

% Text-tree tokens are tokens.
  Text-tree tokens are special kinds of tokens; in particular, every
  text-tree token has a type and a location.  A text-tree token's type
  is the text-tree that would be obtained by replacing all the leaf
  tokens with their types.  A text-tree's location spans from the
  beginning of its first leaf token to the end of its last leaf token,
  and has the same unit and source as its tokens.  If a text-tree
  token does not have any leaves, then its location is the special
  value \code{None}.  As with other tokens, a text-tree tokens whose
  locations is \code{None} is never equal to any other text-tree
  token.

% Tree != Type+Location
  Note that the location of a text-tree token contains only the overall
  location of the tree, and not the locations of its individual
  leaves.  As a result, a text-tree token can not be treated as consisting
  of just its location and its type.  In particular, it is possible to
  construct two text-tree tokens that are not equal, even though their
  types and locations are equal (See Figure~\ref{fig:badtree}).
  However, it is highly unlikely that such pairs of text-tree tokens will
  occur in practice.

% Figure: Tree != Type+Location
  % (the [b] puts it at the bottom of the page -- makes it look better)
  \begin{figure}[b]
  \begin{centering}
    \epsfbox{badtree.eps}\\
  \end{centering}

   \caption{(a) and (b) show two text-tree tokens that are not equal,
   even though their types and locations (shown in (c)) are equal.
   However, this should not occur in practice, since it can only occur
   if two tokens derived from the same source have overlapping
   locations.}
  \label{fig:badtree}
  \end{figure}

  \subsubsection{Consistancy Conditions}
  \label{sec:consistancy}

% Consistancy Conditions
  Text-trees and text-tree tokens are constrained by a number of
  consistancy conditions.  These conditions are designed to simplify
  procedures written by students to process text-trees and text-tree
  tokens.  They are also designed to help prevent some common bugs.
  Several of the consistancy conditions require that different
  elements have the ``same kind of value.''  We can formalize this
  notion of ``kind of value'' with the term ``pytype'': a Python
  object's \emph{pytype} is the object's Python type if the object has
  a built-in type; and is its class if the object is an instance.  The
  consistancy conditions are:

  \begin{enumerate}

%Trees must be proper (this is implied by def. of text-tree & token)
%    \item Every text-tree and text-tree token must be a proper tree.
%    In particular, their structure must be acyclic, and may contain no
%    merge points.

% Node values must be consistant
    \item Every node in a text-tree or text-tree token must have the
    same kind of value.  In particular, for any text-tree or text-tree
    token $T$ with nodes $n_1, n_2, \ldots, n_k$, it must be the case that
    $pytype(n_i) = pytype(n_j)$ for all $i$ and $j$, $1\leq i\leq j\leq n$.

% Leaf tokens must be consistant (text-tree)
    \item Every leaf in a text-tree must have the same pytype.  In
    particular, for any text-tree with leaves $l_1, l_2, \ldots, l_n$, it
    must be the case that $pytype(l_i) = pytype(type(l_j))$ for all
    $i$ and $j$, $1\leq i\leq j\leq n$.

% Leaf tokens types must be consistant (text-tree token)
    \item The type field of every leaf token in a text-tree token must
    have the same pytype.  In particular, for any text-tree token with
    leaves $l_1, l_2, \ldots, l_n$, it must be the case that
    $pytype(type(l_i)) = pytype(type(l_j))$ for all $i$ and $j$, $1\leq
    i\leq j\leq n$.

% Leaves must be properly ordered
    \item Every text-tree token's leaves must be properly ordered.  In
    particular, for every text-tree token with children $c_1, c_2, \ldots,
    c_n$, it must be the case that $location(c_i)<location(c_j)$
    whenever $i<j$, $location(c_i)\neq\code{none}$, and
    $location(c_j)\neq\code{none}$.

% Leaf locations must be consistant
    \item The location of every leaf in a text-tree token must have the
    same source and the same unit.  (This condition is actually implied
    by the preceeding condition, since ordering comparison of two
    locations is only defined when two locations have the same source
    and unit.)

  \end{enumerate}

  \subsection{Implementation}

    \subsubsection{Text-Tree}

      Text-trees are represented with recursive data structures based
      on the \code{Tree} class.  The \code{Tree} instances used to
      represent an example text-tree are shown in
      Figure~\ref{fig:tree-impl}.  Each \code{Tree} instance
      encodes the local relationships between a node and its children.
      A \code{Tree} consists of:

% Figure: Implementation of a Tree
      \begin{figure}
      \begin{centering}
        \epsfbox{tree-impl.eps}\\
      \end{centering}

       \caption{The \code{Tree} instances used to encode an example
       text-tree.  The example text-tree is shown in (a), and the
       \code{Tree}-based data structure is shown in (b).}
      \label{fig:tree-impl}
      \end{figure}

      \begin{itemize}
    
        \item A \emph{node} (accessed via the \code{node()}
        member function).  \\
        Python Type: \emph{(nodetype)}, where \emph{(nodetype)} can be
        any (single) Python type.
    
        \item A list of \emph{children}.  (accessed via standard
        sequence operations, such as indexing and slicing) \\
        Python Type: \code{list} of \code{Tree} and
        \emph{(leaftype)}, where \emph{(leaftype)} can be any (single)
        Python type.
    
      \end{itemize}

      \noindent Several auxilliary accessors can be used to return
      various information about a \code{Tree}:

      \begin{itemize}
    
        \item \code{leaves()} will return an ordered list of the
        \code{Tree}'s leaves. \\
        Python Type: list of \emph{(leaftype)}, where
        \emph{(leaftype)} can be any (single) Python type.

        \item \code{nodes()} will a new \code{Tree} that contains all
        of the \code{Tree}'s nodes, but no leaves. \\
        Python Type: \code{Tree}
    
      \end{itemize}

      \noindent \code{Tree}s are immutable objects.

    \subsubsection{Text-Tree Tokens}

      Text-trees tokens are represented with recursive data structures
      based on the \code{TreeToken} class.  The \code{TreeToken}
      instances used to represent an example text-tree occurance are
      shown in Figure~\ref{fig:treetoken-impl}.  Each \code{TreeToken}
      instance encodes the local relationships between a node and its
      children.  A \code{TreeToken} consists of:

% Figure: Implementation of a TreeToken
      \begin{figure}
      \begin{centering}
        \epsfbox{treetoken-impl.eps}\\
      \end{centering}

       \caption{The \code{TreeToken} instances used to encode an
       example text-tree token.  This text-tree token's type is the
       text-tree shown in Figure \ref{fig:tree-impl}.  Its location is
       [10, 14).}
      \label{fig:treetoken-impl}
      \end{figure}

      \begin{itemize}
    
        \item A \emph{node} (accessed via the \code{node()}
        member function).  \\
        Python Type: \emph{(nodetype)}, where \emph{(nodetype)} can be
        any (single) Python type.
    
        \item A list of \emph{children}.  (accessed via standard
        sequence operations, such as indexing and slicing) \\
        Python Type: \code{list} of \code{TreeToken} and \code{Token}.
    
      \end{itemize}

      \noindent Several auxilliary accessors can be used to return
      various information about a \code{TreeToken}:

      \begin{itemize}
    
        \item \code{type()} will return a \code{Tree} encoding the
        \code{TreeToken}'s type. \\
%        In particular, it will
%        return \textit{type}(self), where \textit{type}() is defined as:
%        \begin{align*}
%         \textit{type}\big(\code{TreeToken}(n, c_1, c_2, \ldots, c_n)\big) &= 
%              \code{Tree}\big(n, \textit{type}(c_1), 
%              \textit{type}(c_2), \ldots, \textit{type}(c_n)\big)\\
%         \textit{type}\big(\code{Token}(t, l)\big) &= t
%        \end{align*}
%        \noindent ($n$ is a \code{TreeToken}'s node value, $c_i$
%        are a \code{TreeToken}'s children, $t$ is a \code{Token}'s
%        type, and $l$ is a \code{Token}'s location.)\\
        Python Type: \code{Tree}
    
        \item \code{loc()} will return the \code{TreeToken}'s
        location. \\
        Python Type: \code{Location}

        \item \code{leaves()} will return an ordered list of the
        \code{TreeToken}'s leaves. \\
        Python Type: list of \emph{(leaftype)}, where
        \emph{(leaftype)} can be any (single) Python type.

        \item \code{nodes()} will a new \code{TreeToken} that contains
        all of the \code{TreeToken}'s nodes, but no leaves. \\
        Python Type: \code{TreeToken}
    
      \end{itemize}

      \noindent \code{TreeToken}s are immutable objects.  The
      \code{TreeToken} class is derived from the \code{Token} class.

    \subsubsection{Consistancy Conditions}

      Since many of the consistancy conditions are difficult to
      verify, it is the user's responsibility not to violate any of
      the conditions; however, most of the consistancy conditions will
      be checked at runtime, to help prevent bugs.

\subsection{Discussion}

% Why encode Trees explicitly?
  We decided to encode syntax trees explicitly, rather than relying on
  the built-in Python types, because the built-in types are not well
  suited for handling homogenous trees.  In particular, there are a
  number of operations over homogenous trees, such as finding the set
  of leaves, which are unnecessarily difficult to perform with data
  structures built from the built-in Python types.  Furthermore,
  creating an explicit representation allows us to enforce consistancy
  conditions.  As discussed in Section \ref{sec:consistancy}, these
  conditions can simplify procedures written by students, and can help
  prevent common bugs.

% What other reps did we consider?
  \vspace{4mm}\noindent We considered two alternative proposals for
  representing text-tree tokens:

  \begin{itemize}

% Why not simply use Tokens, TreeTypes, and more simple Locations?
    \item Occurances of text-trees could be represented using simple
    tokens and locations, as described in Sections \ref{sec:locations}
    and \ref{sec:words}.  This approach has the advantage of
    simplicity.  However, it does provide any mechanism with which
    text-trees can store the locations of their constituant elements.
    As a result, it is not possible to create tokens representing the
    constituants.

% Why not simply use Tokens, TreeTypes, and more complex Locations?
    % This really needs more explanation!
    \item Occurances of text-trees could be represented using simple
    tokens, but complex location objects could be used to store the
    position of each of the text-tree's elements.  This approach
    solves some of the problems with the first proposal.  But if
    occurances of text-trees were represented using the standard
    \code{Token} class, then it would be unnecessarily difficult to
    perform a number of tree-specific operations, such as constructing
    a list of the tokens representing a text-tree token's leaves.  

  \end{itemize}

% Why make TreeTokens a subclass of Token?
  \noindent Note that even though occurances of text-trees are not
  directly encoded with the \code{Token} class, the fact that they are
  special types of tokens is represented by the fact that the
  \code{TreeToken} class is a subclass of the \code{Token} class.

% Why immutable?
  \vspace{1mm}\noindent We decided to make text-trees and text-tree
  tokens immutable for two reasons:

  \begin{itemize}

    \item Immutability allows text-trees and text-tree tokens to be
    used as keys in dictionaries and elements of dictionary-based
    sets.

    \item Immutability allows sub-trees to be safely shared.  This
    eliminates an important class of bugs having to do with modifying
    a tree without realizing that it has accidentally been shared.

  \end{itemize}

% Why the constraints?
  We decided to enforce the constraints described in
  \ref{sec:consistancy} because we believe that they will help prevent
  errors in student code.  We may decide to strengthen or weaken the
  consistancy conditions in the future, once we have gained more
  experience with using the system.

%============= SUMMARY =============%
\newpage
\section{Summary}
\label{sec:summary}

  This document defined four classes, which can be used together with
  Python's built-in types to represent a number of conceptual objects
  related to natural language processing.  Figure
  \ref{fig:concept-reprs} shows which classes and types are typically
  used to represent different conceptual objects.

  Figure \ref{fig:containership} shows the internal structure of each
  of the classes defined by this document.  Figure
  \ref{fig:dependencies} shows the dependencies between these classes.

% Overall-picture
% refer to the figures, and explain them.

% Typical representations for concepts from sec:concepts.
  \begin{figure}
  \begin{centering}
  \begin{tabular}{ll}
    Concept & Typical Representation \\
    \hline

    \concept{Document} & \code{String} \\
  
    \concept{Sentence} & \code{String} \\
  
    \concept{Word Type} & \code{String} \\
  
    \concept{Tagged Word Type} & \code{TaggedType} \\
  
    \concept{Stemmed Word Type} & \code{String} \\
  
    \concept{Case-Normalized Word Type} & \code{String} \\
  
    \concept{Word Occurance} & \code{Token} (type=\code{String})\\

    \concept{Tagged Word Occurance} & \code{Token}
    (type=\code{TaggedType})\\

    \concept{Stemmed Word Occurance} & \code{Token}
    (type=\code{String})\\

    \concept{Case-Normalized Word Occurance} & \code{Token}
    (type=\code{String})\\
  
    \concept{Tokenized Document} & \code{list} of \code{Token}\\
  
    \concept{Tokenized Sentence} & \code{list} of \code{Token}\\
  
    \concept{Location} & \code{Location} \\
  
    \concept{Tagged Document/Sentence} &
    \code{list} of \code{Token} (type=\code{String})\\
  
    \concept{Stemmed Document/Sentence} &
    \code{list} of \code{Token} (type=\code{String})\\
  
    \concept{Case-Normalized Document/Sentence} &
    \code{list} of \code{Token} (type=\code{String})\\
  
    \concept{Syntax Tree} & \code{Tree} \\
  
    \concept{Syntax Node} & \code{String} \\
  
    \concept{Syntax Tree Occurance} & \code{TreeToken} \\
  
  \end{tabular}\\
  \end{centering}

  \caption{The mechanisms typically used to encode each of the
  abstract concepts that was listed in section \ref{sec:concepts}.
  (Note, though, that it may sometimes be adventageous to use other
  representations.)}
  \label{fig:concept-reprs}
  \end{figure}

% Containership relations
  \begin{figure}
  \begin{centering}
    \epsfbox{containership.eps}\\
  \end{centering}
  \caption{The constituants that compose each representation class
  described in this document.}
  \label{fig:containership}
  \end{figure}

% Dependancies
  \begin{figure}
  \begin{centering}
    \epsfbox{dependencies.eps}\\
  \end{centering}
  \caption{The dependancies between the basic representation classes
  described in this document.}
  \label{fig:dependencies}
  \end{figure}


\newpage
%============= META-QUESTIONS =============%
\section{Meta-Questions}
\begin{itemize}
  \item Are the terms used in this document correct?  Could better
  terms be chosen?  Especially: properly ordered, exhaustive,
  type-kind.
  \item Are the interfaces presented here reasonable?
  \item Do any decisions need more justification?
  \item Other comments are always appreciated.
\end{itemize}

\end{document}

