%
% Natural Language Toolkit for Python
% Edward Loper
% 
% Created [03/02/01 12:02 AM]
% $Id$
%

\documentclass{article}
\usepackage{fullpage}

\begin{document}
\title{Proposal: A Natural Language Programming Toolkit for Python}
\author{Edward Loper, Steven Bird}
\maketitle

%################################################################
%#  OVERVIEW
%################################################################
\section{Overview}

CIS-530 is an introductory course in natural language processing
(NLP), which is intended to be accessable to both linguists and
computer scientists \cite{cis530}. In such a class, it is instructive
for students to build real NLP systems.  By building real systems,
students can gain an in-depth understanding of the issues involved in
particular aspects of NLP.

However, the students do not necessarily have any experience
programming or designing software systems.  Thus, when students
attempt to build NLP systems, they may spend a signifigant amount of
their time on programming tasks that are not directly related to the
course of the content.

In order to try to remove some of the time overhead associated with
these programming tasks, we propose to design and implement a toolkit
for building natural language systems using the Python
language \cite{python}. This toolkit will help students in a variety
of ways:

\begin{itemize}
  \item It will provide students with basic tools for manipulating
  data and performing tasks that are related to NLP.

  \item It will allow the students to experiment in building NLP
  systems at a variety of levels.  At one extreme, they can implement
  individual components for use with the toolkit.  At the other
  extreme, they can create large systems by combining toolkit
  components.

  \item It will provide the students with an infrastructure for
  building natural language systems, by providing consistant and
  well-defined interfaces for different components.  Thus, students
  will not have to spend their time thinking about system design
  issues.
\end{itemize}

%################################################################
%#  DESIGN GOALS/CRITERIA
%################################################################
\section{Design Criteria}

Several criteria must be considered in the design and implementation
of the toolkit.  The design criteria are divided into primary and
secondary criteria, and within those sections are listed in the order
of their importance.  A set of explicit non-requirements is also
given.  The toolkit is not expected to satisfy any of these
properties. 

\subsection{Primary Design Criteria}

\begin{description}

\item[Ease of Use] The primary purpose of the toolkit is to allow
students to concentrate on building NLP systems.  The more time
students must spend learning to use the toolkit, the less useful it
is.  

\item[Consistancy] The toolkit should use consistant data structures
and interfaces.

\item[Extensibility] The toolkit should easily accomodate new
components, whether those components replicate or extend the toolkit's
existing functionality.  Thus, the toolkit's design should be modular,
with simple and well-defined interfaces between modules.  The toolkit
should also be structured in such a way that it is obvious where new
extensions would fit into the toolkit's infrastructure.

\item[Documentation] The toolkit, its data structures, and its
implementation all need to be carefully and thouroughly documented.

\end{description}

\subsection{Secondary Design Criteria}

\begin{description}
\item[Simplicity] The toolkit should structure the complexities of
building NLP systems, not hide them.  Therefore, each class defined by 
the toolkit should be simple enough that a student could implement it
by the time they finish the course.

\item[Modularity] The interaction between different components of the
toolkit should be kept to a minimum.  In particular, it should be
possible to use complete individaul projects using small parts of the
toolkit, without worrying about how they interact with the rest of the
toolkit.  This will allow students to learn to use the toolkit
incrementally throughout the course.  Modularity also makes it easier
to change or extend the toolkit.
\end{description}

\subsection{Non-Requirements}

\begin{description}
\item[Comprehensiveness] The toolkit is not intended to provide a
comprehensive set of tools.  Indeed, there should be a wide variety of 
ways in which students can extend the toolkit.

\item[Efficiency] The toolkit doe not need to be highly optimized for
runtime performance.  However, it should be efficient enough that
students can use their NLP systems to perform real tasks.

\item[Cleverness] Clear designs and implementations are far preferable 
to ingenious yet indecipherable ones.
\end{description}

%################################################################
%#  TOOLKIT DESIGN AND IMPLEMENTATION
%################################################################
\section{Toolkit Design and Implementation}

\subsection{Infrastructure Design}

The natural langauge processing toolkit will be implemented by a
collection of independant modules\footnote{These modules do not
necessarily correspond to Python \texttt{module}s.}.  These modules are
organized according to two primary axes:

\begin{itemize}
  \item \textbf{Task:} Toolkit modules are generally associated with
  one or more NLP tasks, and several different modules may be
  associated with the same task.

  \item \textbf{Orientation:} Toolkit modules are either
  \emph{data-oriented} or \emph{task-oriented}.

  \begin{itemize}
    \item Data-oriented modules are used to store different types of
    information that are relevant to natural language processing.
    \item Task-oriented modules are used to perform a variety of tasks 
    that are relevant to natural language processing.
  \end{itemize}
\end{itemize}

\subsubsection{Dependancies}

In general, data-oriented modules should be self-contained, and should
exhibit very little inter-dependancy.  Data-oriented modules never
depend on task-oriented modules.

Task-oriented modules should also be relatively self-contained, with
very little inter-dependancy.  However, each task-oriented modules
will usually depend on a variety of data-oriented modules.  When
possible, the number of data-oriented modules that a task-oriented
module depends on should be kept low.  This allows students to use
task-oriented modules without needing to learn how to use a large
number of other modules.

\subsection{Module Design}

Each module define a small set of interfaces, which give
specifications for the types of classes that can be implemented by the
module.  Each module also contains classes that implement each
interface.  Often, a module will contain more than one implementation
for the same interface.

\subsubsection{Example Module: Tokens}

For the sake of concreteness, I will describe the design of a
data-driven module for handling tokens.  

The token module defines two interfaces:

\vspace{1.2mm}\noindent
\begin{tabular}{||p{.21\textwidth}p{.7\textwidth}}
  \textbf{TokenType} & A unit of text, such as a word or a
  punctuation mark. \\

  \textbf{TextLocation} & The location of an entity within a
  text.\\
\end{tabular}
\vspace{1mm}

\noindent
Each of these interfaces specifies a set of methods that classes must
implement if they are to be considered \texttt{TokenType}s or
\texttt{TextLocation}s.  If a class properly implements every method specified
by an interface, then it is said to \emph{implement} that interface.

The token module also defines one top-level class:

\vspace{1.2mm}\noindent
\begin{tabular}{||p{.21\textwidth}p{.7\textwidth}}
  \textbf{Token} & An Occurance of a \texttt{TokenType}
  within a text.  A \texttt{token} consists of a \texttt{TokenType}
  and a \texttt{TextLocation}. \\
\end{tabular}
\vspace{1mm}

\noindent
This is somewhat unusual; most modules do not implement any top-level
classes.  However, when a data structure has only one reasonable
implementation, a top-level class may be used in place of an interface 
and interface specification.  This is the case for \texttt{Token}s,
which are basically just the result of combining a \texttt{TokenType} 
with a \texttt{TextLocation}.

The only method that \texttt{TokenType}s are required to implement is
the comparison operator.  This allows users of \texttt{TokenType}s to
decide whether two \texttt{TokenType}s represent the same unit of
text.  The token module currently defines two implementations for the
\texttt{TokenType} interface:

\vspace{1.2mm}\noindent
\begin{tabular}{||p{.21\textwidth}p{.7\textwidth}}
  \textbf{SimpleTokenType} & A \texttt{TokenType}s that is
  represented by a single Python \texttt{string}.  Examples of
  \texttt{SimpleTokenType} values are ``dog'' and ``walking.'' \\

  \textbf{TaggedTokenType} & A \texttt{TokenType} that is
  represented by a \texttt{string} and a part-of-speech tag.  Examples 
  of \texttt{TaggedTokenType} values are ``dog/NN,'' ``bank/NN,'' and
  ``bank/VB.'' \\
\end{tabular}
\vspace{1mm}

Like \texttt{TokenType}s, the only method that \texttt{TextLocation}s
are required to implement is the comparison operator.  This allows
users of \texttt{TextLocation}s to decide whether two
\texttt{TextLocation}s represent the same location in a text.  The
token module currently defines one implementation for the
\texttt{TextLocation} interface:

\vspace{1.2mm}\noindent
\begin{tabular}{||p{.21\textwidth}p{.7\textwidth}}
  \textbf{IndexTextLocation} & The location of an
  entity within a text, using a numerical index. \\
\end{tabular}
\vspace{1mm}

\subsection{Programming Concepts}

The structure of the Python language directly affects the design and
implementation of the toolkit.  This section discusses how the design
of the toolkit is affected by the Python language.

\subsubsection{Interfaces}

Python does not directly implement interfaces.  The toolkit will
therefore implement interfaces as simple classes, all of whose methods 
raise \texttt{AssertionError} exceptions.  A description of the
functionality provided by the interface will be contained in the
class's documentation string.  Each method's documentation string will 
contain a specification of the behavior for that method.

Occasionally, interfaces will define optional methods.  These are
methods that may be defined by classes that implement the interface,
but need not be.  Instead of raising \texttt{AssertionError}
exceptions, these methods will raise \texttt{NotImplementedError}
exceptions. 

In order to implement an interface, a class should include that
interface as one of its bases, and should override every
(non-optional) method defined by the interface.

Since Python supports multiple inheritance, this implementation of
interfaces will allow a single class to implement multiple
interfaces.  In general, interfaces should be listed after true bases
in the base list, to ensure proper inheritance of methods.

In principle, an interface hierarchy could be built by defining
interfaces whose bases are interfaces.  However, I do not currently
plan to use this ability.

Classes that define interfaces are named with a trailing ``I,'' such
as \texttt{TokenizerI} or \texttt{EventI}.

\subsubsection{Typing}

Type checking is an imporant safety device, that allows programmers to
quickly detect the locations of errors in their code.  This is
especially important for novice programmers, who have less experience
with debugging.  

Therefore, every function and method defined by the toolkit will
perform a complete type check on all of its arguments.  By default,
container types (lists, tuples, and dictionaries) will be checked in a 
``deep'' fashion: every element will be checked to ensure that it is
the correct type.  For example, if a procedure expects a list of
integers, it will check every element of the list to ensure that they
are integers before it begins executing.  

However, such ``deep'' type checking can have a serious performance
cost: every time a procedure is called, the type of every element of a
potentially very large data structure must be checked.  Therefore, the 
toolkit will provide a function which can adjust the level of type
checking performed by all toolkit functions.  This function can be
used to temporarily lower the type checking level when processing
large amounts of data.  However, it is recommended that the highest
level of type checking be used when possible.

\subsubsection{Language Features}

The use of advanced language features and programming styles could
potentially make the toolkit much more difficult to use or to
understand.  The fewer language features that a student must learn in
order to use the toolkit, the faster they can start developing NLP
systems.  This section discusses the advantages and disadvantages of
using a variety of language features.  The language features used by
the toolkit are summarized by figure \ref{table:feature}.

\begin{figure}
\begin{centering}
\begin{tabular}{|l|l|}
\hline
\textbf{Language Feature} & \textbf{Use} \\
\hline
Classes & used \\
Exceptions & error conditions only \\
Operator Overloading & used \\
Python 2.0 Features & used \\
Function Arguments & minimal use \\
Lambda Functions & minimal use \\
Mapping and Filtering & not used \\
List Comprehensions & not used \\
\hline
\end{tabular}\\
\end{centering}
\caption{Summary of which advanced language features are used by the
toolkit.}
\label{table:feature}
\end{figure}

\begin{description}

  \item[Classes] Classes are an integral part of the design of the
  toolkit; they will be used.

  \item[Exceptions] Exceptions are used by the core Python language to
  report error conditions.  Exceptions can also be used to report
  exceptional conditions.  The toolkit will only use exceptions to
  report error conditions.  As a result, students who are using the
  toolkit need not learn anything about raising or catching
  exceptions.  Students who are extending the toolkit should learn how
  to raise exceptions, but need not learn anything about catching
  exceptions.

  \item[Operator Overloading] Python allows programmers to redefine
  the behavior of operators when used with class instances.  The use
  of operator overloading can make classes easier to use, since they
  can behave more like the built-in classes.  However, extensive use
  of operator overloading can make classes difficult to understand and
  difficult to program.  Classes and interfaces defined by the toolkit
  will use operator overloading.

  \item[Python 2.0 Features] Version 2.0 of Python defines a number of
  useful features, such as augmented assignment; string methods; and
  containership operator overloading.  In general, these features will
  make the toolkit easier to use and understand.  However, if the
  toolkit uses these features, then it cannot be used with earlier
  versions of Python.  The toolkit will use Python 2.0 features, and
  thus will require Python 2.0.

  \item[Function Arguments] Allowing functions to act as arguments can
  be a very powerful tool.  For example, by passing a function to the
  built-in function \texttt{sort}, a programmer can sort a list
  according to any arbitrary ordering.  However, the use of functions
  as arguments can be difficult to understand.  The toolkit will
  therefore make minimal use of functions as arguments.  It should
  never be necessary to use function arguments to accomplish a task.

  \item[Lambda Functions] Lambda functions allow simple functions to
  be defined where they are used.  When used in conjunction with
  functional arguments, lambda functions can be a powerful tool.
  However, their use is not always intuitive.  The toolkit will
  therefore make minimal use of lambda functions.  It will only use
  them in the context of simple and well-defined idioms, such as event
  creation: \texttt{FuncEvent(lambda~x:x>3)}.
        
  \item[Mapping and Filtering] Mapping and filtering provide a
  consise way of expressing transformations on lists.  However, they
  are fairly difficult to learn, and generally involve the use of
  \texttt{lambda} functions, so the toolkit will not use them.

  \item[List Comprehensions] List comprehensions provide an even more
  concise way of expressing transformations on lists.  However, in
  order to reduce the number of new language features that students
  must learn to understand the toolkit, they will not be used.

\end{description}

%################################################################
%#  DOCUMENTATION
%################################################################
\section{Documentation}

Two main types of documentation:
  * tutorial docs
  * reference docs

reference docs are generated from inline comments by epydoc.  

%################################################################
%#  PRELININARY DESIGN AND IMPLEMENTATION
%################################################################
\section{Preliminary Design and Implementation}

As part of the preliminary design process, I desinged and implemented
six prototype modules.  

%################################################################
%#  BiIBLIOGRAPHY
%################################################################
\begin{thebibliography}{1}

\bibitem{python}{The Python programming language. \\
    \texttt{http://www.python.org/}}

\bibitem{cis530}{CIS 530 class homepage.  
                 University of Pennsylvania. \\ 
    \texttt{http://www.cis.upenn.edu/~cis530/}}

\bibitem{epydoc}{Epydoc: Edloper's Python Documentation Tool.
    Contact \texttt{ed@loper.org} for more information.}

\end{thebibliography}

\end{document}